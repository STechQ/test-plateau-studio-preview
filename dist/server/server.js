/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["qui"] = factory();
	else
		root["qui"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../node_modules/@fastify/ajv-compiler/index.js":
/*!************************************************************!*\
  !*** ../../../node_modules/@fastify/ajv-compiler/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Ajv = __webpack_require__(/*! ajv */ \"../../../node_modules/ajv/lib/ajv.js\")\n\nfunction ValidatorSelector () {\n  const validatorPool = new Map()\n  const cache = new Map()\n  cache.put = cache.set\n\n  return function buildCompilerFromPool (externalSchemas, options) {\n    const externals = JSON.stringify(externalSchemas)\n    const ajvConfig = JSON.stringify(options.customOptions)\n\n    const uniqueAjvKey = `${externals}${ajvConfig}`\n    if (validatorPool.has(uniqueAjvKey)) {\n      return validatorPool.get(uniqueAjvKey)\n    }\n\n    const compiler = ValidatorCompiler(externalSchemas, options, cache)\n    validatorPool.set(uniqueAjvKey, compiler)\n\n    return compiler\n  }\n}\n\nfunction ValidatorCompiler (externalSchemas, options, cache) {\n  // This instance of Ajv is private\n  // it should not be customized or used\n  const ajv = new Ajv(Object.assign({\n    coerceTypes: true,\n    useDefaults: true,\n    removeAdditional: true,\n    // Explicitly set allErrors to `false`.\n    // When set to `true`, a DoS attack is possible.\n    allErrors: false,\n    nullable: true\n  }, options.customOptions, { cache }))\n\n  if (options.plugins && options.plugins.length > 0) {\n    for (const plugin of options.plugins) {\n      if (Array.isArray(plugin)) {\n        plugin[0](ajv, plugin[1])\n      } else {\n        plugin(ajv)\n      }\n    }\n  }\n\n  const sourceSchemas = Object.values(externalSchemas)\n  for (const extSchema of sourceSchemas) {\n    ajv.addSchema(extSchema)\n  }\n\n  return function ({ schema/*, method, url, httpPart */ }) {\n    // Ajv does not support compiling two schemas with the same\n    // id inside the same instance. Therefore if we have already\n    // compiled the schema with the given id, we just return it.\n    if (schema.$id) {\n      const stored = ajv.getSchema(schema.$id)\n      if (stored) {\n        return stored\n      }\n    }\n\n    return ajv.compile(schema)\n  }\n}\n\nmodule.exports = ValidatorSelector\n\n\n//# sourceURL=webpack://qui/../../../node_modules/@fastify/ajv-compiler/index.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/algae/lib/helpers/searchRootCa.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@stechquick/algae/lib/helpers/searchRootCa.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nvar https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nvar CaHelper = /** @class */ (function () {\n    function CaHelper() {\n    }\n    CaHelper.getAllFiles = function (dir, allFilesList) {\n        if (allFilesList === void 0) { allFilesList = []; }\n        var isValid = false;\n        if (!fs_1.default.existsSync(dir)) {\n            return undefined;\n        }\n        ;\n        var files = fs_1.default.readdirSync(dir);\n        if (!files)\n            return undefined;\n        var certificateExtentions = [\"crt\", \"crl\", \"csr\", \"der\", \"cer\", \"ca-bundle\", \"p7b\", \"p7c\", \"p7s\", \"pem\", \"arm\", \"pfx\"];\n        files.forEach(function (file) {\n            var fileExtention = file.split(\".\").pop();\n            certificateExtentions.forEach(function (ext) {\n                if (fileExtention === ext) {\n                    var name_1 = dir + '/' + file;\n                    allFilesList.push(fs_1.default.readFileSync(name_1, { encoding: \"utf-8\" }));\n                    isValid = true;\n                }\n            });\n        });\n        return (!isValid || allFilesList.length == 0) ? undefined : allFilesList;\n    };\n    CaHelper.registerCaCerts = function (caCerts) {\n        !caCerts ? console.log(\"Invalid Certificate!\") : console.log(caCerts);\n        if (!caCerts || caCerts.length == 0) {\n            return;\n        }\n        ;\n        https_1.default.globalAgent.options.ca = https_1.default.globalAgent.options.ca || [];\n        if (!(https_1.default.globalAgent.options.ca instanceof Array)) {\n            https_1.default.globalAgent.options.ca = [https_1.default.globalAgent.options.ca];\n        }\n        var certificateList = https_1.default.globalAgent.options.ca;\n        caCerts === null || caCerts === void 0 ? void 0 : caCerts.forEach(function (caCert) { return certificateList.push(caCert); });\n    };\n    return CaHelper;\n}());\nexports[\"default\"] = CaHelper;\n//# sourceMappingURL=searchRootCa.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/algae/lib/helpers/searchRootCa.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-common/lib/helpers/corsHelper.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-common/lib/helpers/corsHelper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CorsManager = void 0;\nclass CorsManager {\n    /**\n     *\n     * @returns {keepExecution: this is not}\n     */\n    static ManageCors(data, manageCorsOptions) {\n        const { allowOrigins = { \"*\": true }, maxAge, allowHeaders = [\"X-PINGOTHER\", \"Content-Type\", \"Cookie\", \"Set-Cookie\"], allowMethods = [\"POST\", \"GET\", \"OPTIONS\"] } = manageCorsOptions;\n        if (!data.origin) {\n            return { success: true, keepExecution: true };\n        }\n        if (allowOrigins && allowOrigins[\"*\"] !== true && allowOrigins[data.origin[0]] !== true) {\n            console.log(\"Http header Origin Not allowed\");\n            return { success: false, statusCode: 403, message: \"Forbidden\" };\n        }\n        console.log(\"adding CORS headers\");\n        const headers = {};\n        headers[\"Access-Control-Allow-Origin\"] = data.origin[0] || \"*\";\n        headers[\"Access-Control-Allow-Credentials\"] = \"true\";\n        if (data.method == \"OPTIONS\") {\n            console.log(\"adding CORS OPTIONS headers\");\n            headers[\"Access-Control-Allow-Methods\"] = allowMethods.join(\",\");\n            headers[\"Access-Control-Allow-Headers\"] = allowHeaders.join(\",\");\n            if (maxAge) {\n                headers[\"Access-Control-Max-Age\"] = maxAge;\n            }\n            headers[\"Vary\"] = \"Accept-Encoding, Origin\";\n            return { success: true, keepExecution: false, headers };\n        }\n        return { success: true, keepExecution: true, headers };\n    }\n}\nexports.CorsManager = CorsManager;\n//# sourceMappingURL=corsHelper.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-common/lib/helpers/corsHelper.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-common/lib/helpers/promiseData.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-common/lib/helpers/promiseData.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CreatePromiseData = void 0;\nlet syncResolved = false;\nnew Promise(res => res()).then(() => syncResolved = true);\ntypeof (doNothing) != \"undefined\" && doNothing();\nconst syncResolveProblem = syncResolved === true; // platform has sync resolve problem or not\n/**\n * @param timeout timeout time in ms, undefined if infinite\n */\nfunction CreatePromiseData(timeout, opt = {}) {\n    const syncResolveFixer = (cb) => syncResolveProblem && opt.fixSyncResolve ? (value) => setTimeout(() => cb(value)) : cb;\n    let resolver = undefined, reject = undefined;\n    let timer;\n    const startTimer = (timeout) => {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => { reject(new Error(`The operation has timed out. timeoutValue  : ${timeout}`)); }, timeout);\n    };\n    if (timeout) {\n        startTimer(timeout);\n    }\n    return {\n        startTimer,\n        promise: new Promise((res, rej) => { resolver = syncResolveFixer(res); reject = rej; }),\n        resolver,\n        reject\n    };\n}\nexports.CreatePromiseData = CreatePromiseData;\n//# sourceMappingURL=promiseData.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-common/lib/helpers/promiseData.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/nanoServer.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/nanoServer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RouteParser = exports.NanoRequest = exports.NanoResponse = exports.NanoServer = void 0;\nvar NanoServer_1 = __webpack_require__(/*! ./src/NanoServer */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoServer.js\");\nObject.defineProperty(exports, \"NanoServer\", ({ enumerable: true, get: function () { return NanoServer_1.NanoServer; } }));\nvar NanoRequest_1 = __webpack_require__(/*! ./src/NanoRequest */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoRequest.js\");\nObject.defineProperty(exports, \"NanoRequest\", ({ enumerable: true, get: function () { return NanoRequest_1.NanoRequest; } }));\nvar NanoResponse_1 = __webpack_require__(/*! ./src/NanoResponse */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoResponse.js\");\nObject.defineProperty(exports, \"NanoResponse\", ({ enumerable: true, get: function () { return NanoResponse_1.NanoResponse; } }));\nvar RouteParser_1 = __webpack_require__(/*! ./src/RouteParser */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js\");\nObject.defineProperty(exports, \"RouteParser\", ({ enumerable: true, get: function () { return RouteParser_1.RouteParser; } }));\n//# sourceMappingURL=nanoServer.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/nanoServer.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoRequest.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoRequest.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NanoRequest = void 0;\nvar url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nvar querystring_1 = __importDefault(__webpack_require__(/*! querystring */ \"querystring\"));\nvar httpHelper_1 = __webpack_require__(/*! ./helpers/httpHelper */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/httpHelper.js\");\nvar NanoRequest = /** @class */ (function () {\n    function NanoRequest(httpRequest, routeDict) {\n        this.httpRequest = httpRequest;\n        this.routeDict = routeDict;\n        this.queryStringDict = this.GetQueryString();\n    }\n    NanoRequest.prototype.GetBody = function () {\n        var _this = this;\n        var multiPart = httpHelper_1.IsMultiPart(this.httpRequest.headers[\"content-type\"]);\n        return new Promise(function (res, rej) {\n            var chunkBuffer = [];\n            _this.httpRequest.on(\"data\", function (chunk) {\n                chunkBuffer.push(chunk);\n            });\n            _this.httpRequest.on(\"end\", function () {\n                var finalChunk = Buffer.concat(chunkBuffer);\n                if (multiPart) {\n                    res(finalChunk);\n                    return;\n                }\n                var json = finalChunk.toString();\n                try {\n                    json = JSON.parse(json);\n                }\n                catch (_a) { }\n                res(json);\n            });\n        });\n    };\n    Object.defineProperty(NanoRequest.prototype, \"Headers\", {\n        // public GetQueryStringValue(key: string): string | undefined | null {\n        //     if (!this.httpRequest || !this.httpRequest.url) {\n        //         return undefined;\n        //     }\n        //     key = key.replace(/[\\[\\]]/g, '\\\\$&');\n        //     const regex = new RegExp('[?&]' + key + '(=([^&#]*)|&|#|$)');\n        //     const results = regex.exec(this.httpRequest?.url!);\n        //     if (!results) {\n        //         return undefined;\n        //     }\n        //     if (!results[2]) {\n        //         return null;\n        //     }\n        //     return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n        // }\n        get: function () {\n            var _this = this;\n            var retVal = {};\n            Object.keys(this.httpRequest.headers).forEach(function (headerKey) {\n                var header = _this.httpRequest.headers[headerKey];\n                if (!header) {\n                    return;\n                }\n                retVal[headerKey] = header instanceof Array ? header : [header];\n            });\n            return retVal;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // public get QueryStringParams() {\n    //     const retVal: Record<string, string | undefined> = {};\n    //     const qString = this.httpRequest.url?.split(\"?\")[1];\n    //     if (qString) {\n    //         const values = qString.split(\"&\");\n    //         values.forEach(value => {\n    //             const val = value.split(\"=\");\n    //             retVal[val[0]] = val[1];\n    //         });\n    //     }\n    //     return retVal;\n    // }\n    NanoRequest.prototype.GetQueryString = function () {\n        var urlData = url_1.default.parse(this.httpRequest.url);\n        if (!urlData.query) {\n            return {};\n        }\n        var querystringData = querystring_1.default.parse(urlData.query);\n        return querystringData;\n    };\n    return NanoRequest;\n}());\nexports.NanoRequest = NanoRequest;\n;\n//# sourceMappingURL=NanoRequest.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoRequest.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoResponse.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoResponse.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NanoResponse = void 0;\nvar NanoResponse = /** @class */ (function () {\n    function NanoResponse(httpResponse) {\n        this.httpResponse = httpResponse;\n    }\n    NanoResponse.prototype.writeResponse = function (message, contentType, statusCode) {\n        if (contentType === void 0) { contentType = \"text/html; charset=utf-8\"; }\n        if (statusCode === void 0) { statusCode = 200; }\n        this.httpResponse.writeHead(statusCode, { 'Content-Type': contentType });\n        this.httpResponse.end(message, \"utf-8\");\n    };\n    NanoResponse.prototype.writeHeaders = function (headers) {\n        var _this = this;\n        if (headers) {\n            Object.keys(headers).forEach(function (header) { return _this.httpResponse.setHeader(header, headers[header]); });\n        }\n    };\n    return NanoResponse;\n}());\nexports.NanoResponse = NanoResponse;\n;\n//# sourceMappingURL=NanoResponse.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoResponse.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoServer.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoServer.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NanoServer = void 0;\nvar http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nvar https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nvar path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nvar fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nvar NanoRequest_1 = __webpack_require__(/*! ./NanoRequest */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoRequest.js\");\nvar NanoResponse_1 = __webpack_require__(/*! ./NanoResponse */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoResponse.js\");\nvar RouteParser_1 = __webpack_require__(/*! ./RouteParser */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js\");\nvar fileHandler_1 = __webpack_require__(/*! ./fileHandler */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/fileHandler.js\");\nvar urlHelper_1 = __webpack_require__(/*! ./helpers/urlHelper */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/urlHelper.js\");\nvar fileHelper_1 = __webpack_require__(/*! ./helpers/fileHelper */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/fileHelper.js\");\nvar httpHelper_1 = __webpack_require__(/*! ./helpers/httpHelper */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/httpHelper.js\");\nvar gracefulShutdown_1 = __webpack_require__(/*! ./gracefulShutdown */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/gracefulShutdown.js\");\nvar corsHelper_1 = __webpack_require__(/*! @stechquick/symphony-common/lib/helpers/corsHelper */ \"../../../node_modules/@stechquick/symphony-common/lib/helpers/corsHelper.js\");\nvar promiseData_1 = __webpack_require__(/*! @stechquick/symphony-common/lib/helpers/promiseData */ \"../../../node_modules/@stechquick/symphony-common/lib/helpers/promiseData.js\");\nvar nanoValidations_1 = __webpack_require__(/*! ./validation/nanoValidations */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/validation/nanoValidations.js\");\nvar pipeline_1 = __webpack_require__(/*! ./pipeline */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/pipeline.js\");\nvar defaults = {\n    rootDiskPath: \"./\",\n    bindHost: \"0.0.0.0\",\n    statusCodeRedirects: {},\n    staticFileServing: \"on\",\n};\nvar noHostedPathDict = { \"/\": true, \"\": true };\n;\n;\nvar NanoServer = /** @class */ (function () {\n    function NanoServer(options) {\n        this.portForcingTryCount = 0;\n        var newDef = Object.assign({}, defaults);\n        if (options) {\n            Object.keys(options).forEach(function (curKey) { var _a; return newDef[curKey] = (_a = options[curKey]) !== null && _a !== void 0 ? _a : newDef[curKey]; });\n        }\n        this.options = newDef;\n        this.plugins = [];\n        this.promDatas = {};\n    }\n    NanoServer.prototype.GetServerUrl = function (options) {\n        if (options === void 0) { options = {}; }\n        if (!this.options.httpOptions && !this.options.httpsOptions) {\n            return undefined;\n        }\n        var protocol = options.protocol || (this.options.httpsOptions ? \"https\" : \"http\");\n        var targetOptions = this.options[protocol + \"Options\"];\n        if (!targetOptions) {\n            return undefined;\n        }\n        var port = targetOptions.port;\n        var logHost = this.options.bindHost == defaults.bindHost ? \"localhost\" : this.options.bindHost;\n        return protocol + \"://\" + logHost + \":\" + port;\n    };\n    NanoServer.prototype.Subscribe = function (options) {\n        var promData = this.promDatas[options.event] = this.promDatas[options.event] || promiseData_1.CreatePromiseData();\n        promData.promise.then(options.cb);\n    };\n    NanoServer.prototype.Start = function (startingOptions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpServer;\n            return __generator(this, function (_a) {\n                console.log(\"Starting http server...\");\n                this.options.httpOptions = startingOptions;\n                httpServer = http_1.default.createServer(this.handleRequest.bind(this));\n                this.StartNewServer(httpServer, startingOptions);\n                return [2 /*return*/];\n            });\n        });\n    };\n    NanoServer.prototype.StartHttps = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpsServer;\n            return __generator(this, function (_a) {\n                console.log(\"Starting https server...\");\n                this.options.httpsOptions = options;\n                httpsServer = https_1.default.createServer({ key: options.privateKey, cert: options.certificate }, this.handleRequest.bind(this));\n                this.StartNewServer(httpsServer, options);\n                return [2 /*return*/];\n            });\n        });\n    };\n    NanoServer.prototype.attachPlugin = function (plugin, server) {\n        plugin.Attach(server);\n        console.log(\"plugin registered: \" + plugin.PluginName);\n    };\n    NanoServer.prototype.StartNewServer = function (server, startingOptions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tryIt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                console.log(\"options: \", JSON.parse(JSON.stringify(this.options)));\n                this.portForcingTryCount = 0;\n                gracefulShutdown_1.addShutdown(server);\n                tryIt = function () {\n                    console.log(\"BindHost: \" + _this.options.bindHost);\n                    server.listen(startingOptions.port, _this.options.bindHost, 10, (function () {\n                        var _a, _b, _c;\n                        console.log(\"NS plugins: \" + _this.plugins.length);\n                        (_a = _this.plugins) === null || _a === void 0 ? void 0 : _a.forEach(function (plugin) { return _this.attachPlugin(plugin, server); });\n                        _this.server = server;\n                        (_b = _this.promDatas.onStart) === null || _b === void 0 ? void 0 : _b.resolver();\n                        (_c = startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.successCb) === null || _c === void 0 ? void 0 : _c.call(startingOptions);\n                    }));\n                    server.on('error', function (error) {\n                        var _a;\n                        var isInUse = error.stack && ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.indexOf(\"EADDRINUSE\")) > 0;\n                        if (isInUse && _this.retryForNextPort()) {\n                            startingOptions.port++;\n                            tryIt();\n                        }\n                        else {\n                            if (!(startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.errorCb)) {\n                                throw error;\n                            }\n                            startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.errorCb(error);\n                        }\n                    });\n                };\n                tryIt();\n                return [2 /*return*/];\n            });\n        });\n    };\n    NanoServer.prototype.Stop = function () {\n        if (!this.server) {\n            return;\n        }\n        this.server.shutdown();\n        this.server.close();\n        delete this.server;\n    };\n    NanoServer.prototype.ClearServices = function () {\n        this.options.services = [];\n    };\n    NanoServer.prototype.AddService = function (service) {\n        var _a;\n        var routeParser = new RouteParser_1.RouteParser(this.subtractHostedPath(service.PathStart));\n        this.options.services = (_a = this.options.services) !== null && _a !== void 0 ? _a : [];\n        this.options.services.push(Object.assign(service, { routeParser: routeParser }));\n    };\n    NanoServer.prototype.AddPlugin = function (plugin) {\n        this.plugins.push(plugin);\n        if (!this.server) {\n            return;\n        } // during start, plugins are also attached\n        this.attachPlugin(plugin, this.server);\n    };\n    NanoServer.prototype.AddProxy = function (proxyOptions) {\n        var _this = this;\n        var self = this;\n        Object.keys(proxyOptions).forEach(function (sourceUrl) {\n            var methods = [\"DELETE\", \"GET\", \"OPTIONS\", \"POST\", \"PUT\"];\n            _this.AddService({\n                PathStart: sourceUrl,\n                Methods: new Set(methods), Execute: function (options) { return __awaiter(_this, void 0, void 0, function () {\n                    var proxyTarget, parsed, protocolUrl, targetUrl, method, headers, body, targetUrl, targetPath, parsedPath, serviceOptions;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                proxyTarget = proxyOptions[sourceUrl];\n                                if (!urlHelper_1.UrlHelper.IsDirectUrl(proxyTarget)) return [3 /*break*/, 2];\n                                parsed = urlHelper_1.UrlHelper.DetachProtocol(proxyTarget);\n                                protocolUrl = (parsed.protocol ? parsed.protocol + \"://\" : \"\");\n                                targetUrl = protocolUrl + path_1.default.posix.join(parsed.pureUrl, options.request.matchLeftover || \"\") + (options.request.args ? \"?\" + options.request.args : \"\");\n                                method = options.request.httpRequest.method;\n                                headers = options.request.httpRequest.headers;\n                                if (headers.host) {\n                                    delete headers.host;\n                                    console.debug(\"removed host header\");\n                                }\n                                return [4 /*yield*/, options.request.GetBody()];\n                            case 1:\n                                body = _a.sent();\n                                console.log(\"http redirect: \" + sourceUrl + \" --> \" + targetUrl);\n                                httpHelper_1.Proxy(options.response.httpResponse, targetUrl, { method: method, headers: headers, body: body });\n                                return [3 /*break*/, 3];\n                            case 2:\n                                targetUrl = proxyTarget;\n                                targetPath = path_1.default.join(targetUrl, options.request.matchLeftover || \"\");\n                                if (fileHelper_1.IsRelativePath(targetUrl)) {\n                                    targetPath = path_1.default.join(self.options.rootDiskPath, targetPath);\n                                }\n                                console.log(\"disk redirect: \" + sourceUrl + \" --> \" + targetPath);\n                                parsedPath = RouteParser_1.RouteParser.ParseUrl(targetPath);\n                                serviceOptions = { request: new NanoRequest_1.NanoRequest(options.request.httpRequest, {}), response: new NanoResponse_1.NanoResponse(options.response.httpResponse) };\n                                self.handleFileRequest(\"\", parsedPath, serviceOptions);\n                                _a.label = 3;\n                            case 3: return [2 /*return*/];\n                        }\n                    });\n                }); }\n            });\n        });\n    };\n    // // where is this used ???\n    // public GetServedFileList(): string[] {\n    //     const getAllFiles = (dirPath: string, arrayOfFiles?: string[]) => {\n    //         const files = fs.readdirSync(dirPath)\n    //         arrayOfFiles = arrayOfFiles || [];\n    //         files.forEach((file) => {\n    //             if (fs.statSync(dirPath + \"/\" + file).isDirectory()) {\n    //                 arrayOfFiles = getAllFiles(dirPath + \"/\" + file, arrayOfFiles);\n    //             } else {\n    //                 const fullPath = path.join(dirPath, file);\n    //                 const item = this.GetServerUrl() + fullPath.replace(this.options.rootDiskPath, \"\").replace(/\\\\/gi, \"/\");\n    //                 arrayOfFiles!.push(item);\n    //             }\n    //         });\n    //         return arrayOfFiles\n    //     }\n    //     return getAllFiles(this.options.rootDiskPath);\n    // }\n    NanoServer.prototype.GetOptions = function () {\n        var _a, _b;\n        var _c = this.options, bindHost = _c.bindHost, hostedPath = _c.hostedPath, rootDiskPath = _c.rootDiskPath, staticFileServing = _c.staticFileServing, portSeekOffset = _c.portSeekOffset;\n        var retVal = {\n            bindHost: bindHost, hostedPath: hostedPath, rootDiskPath: rootDiskPath, staticFileServing: staticFileServing, portSeekOffset: portSeekOffset,\n            httpPort: (_a = this.options.httpOptions) === null || _a === void 0 ? void 0 : _a.port,\n            httpsPort: (_b = this.options.httpsOptions) === null || _b === void 0 ? void 0 : _b.port\n        };\n        return retVal;\n    };\n    NanoServer.prototype.retryForNextPort = function () {\n        var forcingCount = this.options.portSeekOffset;\n        if (forcingCount && forcingCount > this.portForcingTryCount) {\n            this.portForcingTryCount++;\n            return true;\n        }\n        return false;\n    };\n    NanoServer.prototype.handleRequest = function (request, response) {\n        return __awaiter(this, void 0, void 0, function () {\n            var err_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.tryHandleRequest(request, response)];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        err_1 = _a.sent();\n                        console.error(\"Ex in request handing: \", err_1);\n                        response.writeHead(500, { \"Content-Type\": \"text/html; charset=utf-8\", \"Content-Length\": 0 });\n                        response.end();\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    NanoServer.prototype.subtractHostedPath = function (url) {\n        if (!this.options.hostedPath || noHostedPathDict[this.options.hostedPath] || !url.startsWith(this.options.hostedPath)) {\n            return url;\n        }\n        var hostedPathLength = this.options.hostedPath.length;\n        if (this.options.hostedPath[hostedPathLength - 1] == \"/\") {\n            hostedPathLength--;\n        }\n        return url.slice(hostedPathLength);\n    };\n    NanoServer.prototype.tryHandleRequest = function (request, response) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function () {\n            var url, parsedUrl, serviceOptions, validationResp, _c, content, handleResponse, handleResponseOverride;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        url = request.url || \"\";\n                        url = this.subtractHostedPath(url);\n                        console.log(\"requested: \" + url);\n                        response.on(\"finish\", function () { return request.destroy(); });\n                        parsedUrl = RouteParser_1.RouteParser.ParseUrl(url);\n                        serviceOptions = { request: new NanoRequest_1.NanoRequest(request, {}), response: new NanoResponse_1.NanoResponse(response) };\n                        validationResp = new nanoValidations_1.NanoValidations().ValidateUrl(parsedUrl);\n                        if (validationResp) {\n                            new pipeline_1.Pipeline().Respond(validationResp, serviceOptions, parsedUrl, this.options);\n                            return [2 /*return*/];\n                        }\n                        //fix root\n                        if (parsedUrl.dir == \"/\" && parsedUrl.base == \"\") {\n                            parsedUrl.name = \"index\";\n                            parsedUrl.ext = \".html\";\n                            parsedUrl.base = parsedUrl.name + parsedUrl.ext;\n                        }\n                        return [4 /*yield*/, this.handleService(parsedUrl, serviceOptions)];\n                    case 1:\n                        if (_d.sent()) {\n                            return [2 /*return*/];\n                        }\n                        _c = this.options.staticFileServing == \"on\";\n                        if (!_c) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.handleFileRequest(this.options.rootDiskPath, parsedUrl, serviceOptions, this.options.manageCors)];\n                    case 2:\n                        _c = (_d.sent());\n                        _d.label = 3;\n                    case 3:\n                        if (_c) {\n                            return [2 /*return*/];\n                        }\n                        content = \"Service Unavailable: \" + url.substring(0, 50) + (url.length > 50 ? \"...\" : \"\");\n                        handleResponse = {\n                            content: content,\n                            headers: { \"Content-Type\": \"text/html; charset=utf-8\", \"Content-Length\": content.length.toString() }, status: 503\n                        };\n                        handleResponseOverride = ((_b = (_a = this.options.statusCodeRedirects)[503]) === null || _b === void 0 ? void 0 : _b.call(_a, serviceOptions.request.httpRequest, parsedUrl, handleResponse)) || handleResponse;\n                        response.writeHead(handleResponseOverride.status, handleResponseOverride.headers);\n                        response.end(handleResponseOverride.content, \"utf-8\");\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    NanoServer.prototype.isBinaryFile = function (ext) {\n        var mimeTypes = {\n            '.html': false,\n            '.js': false,\n            '.css': false,\n            '.json': false,\n            '.png': true,\n            '.jpg': true,\n            '.gif': true,\n            '.wav': true,\n            '.mp4': true,\n            '.woff': true,\n            '.ttf': true,\n            '.eot': false,\n            '.otf': false,\n            '.svg': false,\n            \".dll\": false,\n            \".txt\": false,\n        };\n        return mimeTypes[ext];\n    };\n    NanoServer.prototype.handleFileRequest = function (basePath, parsedPath, serviceOptions, manageCors) {\n        var _a, _b, _c;\n        if (manageCors) {\n            var method = serviceOptions.request.httpRequest.method;\n            var origin = serviceOptions.request.httpRequest.headers.origin;\n            var corsResp = corsHelper_1.CorsManager.ManageCors({ method: method, origin: origin ? [origin] : undefined }, manageCors);\n            if (!corsResp.success) {\n                var resp = serviceOptions.response.httpResponse;\n                resp.statusCode = corsResp.statusCode;\n                resp.end(corsResp.message);\n                return true;\n            }\n            serviceOptions.response.writeHeaders(corsResp.headers);\n        }\n        if (this.isBinaryFile(parsedPath.ext)) {\n            var filePath = path_1.default.resolve(path_1.default.join(basePath, parsedPath.dir, parsedPath.base));\n            var stream = fs_1.default.createReadStream(filePath);\n            stream.on('open', function () {\n                stream.pipe(serviceOptions.response.httpResponse);\n            });\n            stream.on('error', function (e) {\n                console.log(\"Image error:\", e);\n                serviceOptions.response.httpResponse.setHeader('Content-Type', 'text/plain');\n                serviceOptions.response.httpResponse.statusCode = 404;\n                serviceOptions.response.httpResponse.end('Not found');\n            });\n            return true;\n        }\n        var fileResponse = new fileHandler_1.FileHandler().handleFileRequest(basePath, parsedPath);\n        var redirect = (_c = (_a = this.options) === null || _a === void 0 ? void 0 : (_b = _a.statusCodeRedirects)[fileResponse.status]) === null || _c === void 0 ? void 0 : _c.call(_b, serviceOptions.request.httpRequest, parsedPath, fileResponse);\n        if (redirect) {\n            fileResponse = redirect;\n            console.log(\"custom redirect status: \" + redirect.status + \" headers:\", redirect.headers);\n        }\n        serviceOptions.response.httpResponse.writeHead(fileResponse.status, fileResponse.headers);\n        serviceOptions.response.httpResponse.end(fileResponse.content, \"utf-8\");\n        return true;\n    };\n    NanoServer.prototype.handleService = function (parsedUrl, serviceOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function () {\n            var retVal, method, initialObj, matchResult, matchData;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        retVal = false;\n                        method = serviceOptions.request.httpRequest.method;\n                        if (!this.options.services || !method) {\n                            return [2 /*return*/, retVal];\n                        }\n                        initialObj = { result: { match: false, routeDict: {}, power: 0 } };\n                        matchResult = this.options.services.reduce(function (prev, service) {\n                            if (!service.Methods.has(method)) {\n                                return prev;\n                            }\n                            var matchResult = service.routeParser.MatchAndGetRouteDict(parsedUrl);\n                            if (!matchResult.match) {\n                                return prev;\n                            }\n                            return matchResult.power > prev.result.power ? { service: service, result: matchResult } : prev;\n                        }, initialObj);\n                        if (!matchResult.result.match) return [3 /*break*/, 2];\n                        retVal = true;\n                        serviceOptions.request.routeDict = matchResult.result.routeDict;\n                        matchData = (_b = (_a = matchResult.result).getMatchData) === null || _b === void 0 ? void 0 : _b.call(_a);\n                        serviceOptions.request.matchLeftover = matchData === null || matchData === void 0 ? void 0 : matchData.matchLeftOver;\n                        serviceOptions.request.args = matchData === null || matchData === void 0 ? void 0 : matchData.args;\n                        return [4 /*yield*/, matchResult.service.Execute(serviceOptions)];\n                    case 1:\n                        _c.sent();\n                        _c.label = 2;\n                    case 2: return [2 /*return*/, retVal];\n                }\n            });\n        });\n    };\n    return NanoServer;\n}());\nexports.NanoServer = NanoServer;\n//# sourceMappingURL=NanoServer.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/NanoServer.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RouteParser = void 0;\nvar path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nvar url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\n;\n;\nvar RouteParser = /** @class */ (function () {\n    function RouteParser(templatePath) {\n        var _this = this;\n        var pathParts = templatePath.split(\"/\").filter(function (pathPart) { return pathPart; });\n        this.staticParts = Array(pathParts.length);\n        this.dynamicParts = Array(pathParts.length);\n        var counter = 0;\n        pathParts.forEach(function (pathPart) {\n            if (pathPart.startsWith(\"{\")) {\n                _this.dynamicParts[counter] = pathPart.substring(1, pathPart.length - 1);\n            }\n            else {\n                _this.staticParts[counter] = pathPart.toLowerCase();\n            }\n            counter++;\n        });\n    }\n    RouteParser.ParseUrl = function (urlString) {\n        var _a;\n        var urlData = url_1.default.parse(urlString);\n        var parsedPath = path_1.default.parse(urlData.pathname);\n        var args = (_a = urlData.query) !== null && _a !== void 0 ? _a : \"\";\n        return __assign(__assign({}, parsedPath), { args: args });\n    };\n    RouteParser.prototype.MatchAndGetRouteDict = function (parsedUrl) {\n        var retVal = { match: false, routeDict: {}, power: 0 };\n        var pureUrl = parsedUrl.dir + \"/\" + parsedUrl.name + parsedUrl.ext;\n        var incommingPathParts = pureUrl.split(\"/\").filter(function (part) { return part; });\n        if (incommingPathParts.length < this.staticParts.length) {\n            return retVal;\n        }\n        var counter = 0;\n        for (var i = 0, len = this.staticParts.length; i < len; i++) {\n            var dynamicPart = this.dynamicParts[i];\n            var currentStatic = this.staticParts[i];\n            retVal.match = true;\n            if (currentStatic == \"*\") {\n                break;\n            }\n            if (dynamicPart) {\n                retVal.routeDict[dynamicPart] = decodeURIComponent(incommingPathParts[i]);\n            }\n            else if (incommingPathParts[counter].length > 0) {\n                if (incommingPathParts[counter].toLowerCase() != currentStatic) {\n                    retVal.match = false;\n                    break;\n                }\n            }\n            counter++;\n        }\n        if (retVal.match) {\n            retVal.getMatchData = function () { return ({\n                args: parsedUrl.args,\n                matchLeftOver: incommingPathParts.length >= counter ? incommingPathParts.slice(counter).map(function (item) { return \"/\" + item; }).join(\"\") : undefined,\n            }); };\n            retVal.power = counter;\n        }\n        return retVal;\n    };\n    return RouteParser;\n}());\nexports.RouteParser = RouteParser;\n//# sourceMappingURL=RouteParser.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/fileHandler.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/fileHandler.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileHandler = void 0;\nvar path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nvar fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nvar FileHandler = /** @class */ (function () {\n    function FileHandler() {\n    }\n    FileHandler.prototype.handleFileRequest = function (basePath, parsedUrl) {\n        var filePath = path_1.default.resolve(path_1.default.join(basePath, parsedUrl.dir, parsedUrl.base));\n        var fileDetailError = \"basePath: \" + basePath + \" dir:\" + parsedUrl.dir + \" fileName:\" + parsedUrl.base + \" \";\n        if (!fs_1.default.existsSync(filePath)) {\n            var fnf = \"File Not Found\";\n            console.error(fnf + \": \" + filePath, fileDetailError);\n            return { status: 404, content: fnf };\n        }\n        var contentType = this.getContentType(parsedUrl.ext);\n        try {\n            var file = fs_1.default.readFileSync(filePath);\n            return { status: 200, headers: { \"Content-Type\": contentType, \"Content-Length\": file.length.toString() }, content: file };\n        }\n        catch (ex) {\n            console.error(\"File read error: \" + filePath, ex, fileDetailError);\n            return { status: 500, content: \"Sorry, check error: \" + ex.code };\n        }\n    };\n    FileHandler.prototype.getContentType = function (extension) {\n        var textPlain = \"text/plain\";\n        var mimeTypes = {\n            '.html': 'text/html',\n            '.js': 'application/javascript; charset=UTF-8',\n            '.css': 'text/css',\n            '.json': 'application/json',\n            '.png': 'image/png',\n            '.jpg': 'image/jpg',\n            '.gif': 'image/gif',\n            '.wav': 'audio/wav',\n            '.mp4': 'video/mp4',\n            '.woff': 'application/font-woff',\n            '.ttf': 'application/font-ttf',\n            '.eot': 'application/vnd.ms-fontobject',\n            '.otf': 'application/font-otf',\n            '.svg': 'image/svg+xml',\n            \".dll\": \"application/octet-stream\",\n            \".txt\": textPlain\n        };\n        var contentType = mimeTypes[extension] || textPlain;\n        return contentType;\n    };\n    return FileHandler;\n}());\nexports.FileHandler = FileHandler;\n//# sourceMappingURL=fileHandler.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/fileHandler.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/gracefulShutdown.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/gracefulShutdown.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar log_on = false;\nfunction log(msg) {\n    if (!log_on) {\n        return;\n    }\n    console.log(msg);\n}\n/**\n * Adds shutdown functionaility to the `http.Server` object\n * @param {http.Server} server The server to add shutdown functionaility to\n */\nfunction addShutdown(server) {\n    var connections = {};\n    var isShuttingDown = false;\n    var connectionCounter = 0;\n    function destroy(socket, force) {\n        if (force || (socket._isIdle && isShuttingDown)) {\n            socket.destroy();\n            delete connections[socket._connectionId];\n        }\n    }\n    ;\n    function onConnection(socket) {\n        log(\"server on connection\");\n        var id = connectionCounter++;\n        socket._isIdle = true;\n        socket._connectionId = id;\n        connections[id] = socket;\n        socket.on('close', function () {\n            log(\"socket close\");\n            delete connections[id];\n        });\n    }\n    ;\n    server.on('request', function (req, res) {\n        log(\"server on request\");\n        req.socket._isIdle = false;\n        res.on('finish', function () {\n            log(\"response finish\");\n            req.socket._isIdle = true;\n            destroy(req.socket);\n        });\n    });\n    server.on('connection', onConnection);\n    server.on('secureConnection', onConnection);\n    function shutdown(force, cb) {\n        log(\"shutdown\");\n        isShuttingDown = true;\n        server.close(function (err) {\n            if (cb) {\n                process.nextTick(function () { cb(err); });\n            }\n        });\n        Object.keys(connections).forEach(function (key) {\n            destroy(connections[key], force);\n        });\n    }\n    ;\n    server.shutdown = function (cb) {\n        shutdown(false, cb);\n    };\n    server.forceShutdown = function (cb) {\n        shutdown(true, cb);\n    };\n    return server;\n}\n;\n/**\n * Extends the {http.Server} object with shutdown functionaility.\n \n */\nexports.extend = function () {\n    http.Server.prototype.withShutdown = function () {\n        return addShutdown(this);\n    };\n    https.Server.prototype.withShutdown = function () {\n        return addShutdown(this);\n    };\n};\nexports.addShutdown = addShutdown;\n//# sourceMappingURL=gracefulShutdown.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/gracefulShutdown.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/fileHelper.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/fileHelper.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IsRelativePath = void 0;\nfunction IsRelativePath(path) {\n    return path.startsWith(\".\");\n}\nexports.IsRelativePath = IsRelativePath;\n//# sourceMappingURL=fileHelper.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/fileHelper.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/httpHelper.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/httpHelper.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IsMultiPart = exports.CommonContentTypes = exports.Proxy = void 0;\nvar http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nvar https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nvar urlHelper_1 = __webpack_require__(/*! ./urlHelper */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/urlHelper.js\");\nfunction Proxy(serverResponse, targetUrl, _a) {\n    var method = _a.method, headers = _a.headers, body = _a.body;\n    var protocol = urlHelper_1.UrlHelper.GetUrlProtocol(targetUrl) == \"https\" ? https_1.default : http_1.default;\n    var proxyReq = protocol.request(targetUrl, { method: method, headers: headers }, function (res) {\n        var _a;\n        serverResponse.writeHead((_a = res.statusCode) !== null && _a !== void 0 ? _a : 500, res.headers);\n        res.on(\"data\", function (chunk) {\n            if (res.headers[\"content-encoding\"]) {\n                serverResponse.write(chunk, \"binary\");\n            }\n            else {\n                serverResponse.write(chunk);\n            }\n        });\n        res.on(\"end\", function () {\n            serverResponse.end();\n        });\n    });\n    proxyReq.on(\"error\", function (err) {\n        console.error(targetUrl + \" returned err\", err);\n        serverResponse.writeHead(502);\n        serverResponse.end(\"selamlar olmadı\", \"utf-8\");\n    });\n    if (body) {\n        var req = body;\n        switch (typeof (body)) {\n            case \"object\":\n                if (body instanceof Buffer) {\n                    req = body;\n                }\n                else {\n                    req = JSON.stringify(body);\n                }\n                break;\n        }\n        proxyReq.write(req);\n    }\n    proxyReq.end();\n}\nexports.Proxy = Proxy;\nvar CommonContentTypes;\n(function (CommonContentTypes) {\n    CommonContentTypes[\"multipart/form-data\"] = \"multipart/form-data\";\n    CommonContentTypes[\"text/html\"] = \"text/html\";\n    CommonContentTypes[\"application/json\"] = \"application/json\";\n})(CommonContentTypes = exports.CommonContentTypes || (exports.CommonContentTypes = {}));\n;\nfunction IsMultiPart(contentType) {\n    var multipartIndex = contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(CommonContentTypes[\"multipart/form-data\"]);\n    if (multipartIndex === undefined) {\n        return false;\n    } // must be ===\n    return multipartIndex > -1;\n}\nexports.IsMultiPart = IsMultiPart;\n//# sourceMappingURL=httpHelper.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/httpHelper.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/urlHelper.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/urlHelper.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlHelper = void 0;\nvar UrlHelper = /** @class */ (function () {\n    function UrlHelper() {\n    }\n    UrlHelper.IsDirectUrl = function (pathOrUrl) {\n        return pathOrUrl.startsWith(\"http:\") || pathOrUrl.startsWith(\"https:\") || pathOrUrl.startsWith(\"blob:\");\n    };\n    UrlHelper.GetUrlProtocol = function (url) {\n        var urlLower = url.toLowerCase();\n        if (url.startsWith(\"http:\")) {\n            return \"http\";\n        }\n        if (url.startsWith(\"https:\")) {\n            return \"https\";\n        }\n        return undefined;\n    };\n    UrlHelper.DetachProtocol = function (url) {\n        var protocol = UrlHelper.GetUrlProtocol(url);\n        if (!protocol) {\n            return { pureUrl: url };\n        }\n        return { protocol: protocol, pureUrl: url.substring(protocol.length + \"://\".length) };\n    };\n    return UrlHelper;\n}());\nexports.UrlHelper = UrlHelper;\n//# sourceMappingURL=urlHelper.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/helpers/urlHelper.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/pipeline.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/pipeline.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pipeline = void 0;\nvar Pipeline = /** @class */ (function () {\n    function Pipeline() {\n    }\n    Pipeline.prototype.Respond = function (handleResponse, serviceOptions, parsedUrl, options) {\n        var _a, _b;\n        var redirect = (_b = options === null || options === void 0 ? void 0 : (_a = options.statusCodeRedirects)[handleResponse.status]) === null || _b === void 0 ? void 0 : _b.call(_a, serviceOptions.request.httpRequest, parsedUrl, handleResponse);\n        if (redirect) {\n            handleResponse = redirect;\n            console.log(\"custom redirect status: \" + redirect.status + \" headers:\", redirect.headers);\n        }\n        serviceOptions.response.httpResponse.writeHead(handleResponse.status, handleResponse.headers);\n        serviceOptions.response.httpResponse.end(handleResponse.content, \"utf-8\");\n    };\n    return Pipeline;\n}());\nexports.Pipeline = Pipeline;\n//# sourceMappingURL=pipeline.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/pipeline.js?");

/***/ }),

/***/ "../../../node_modules/@stechquick/symphony-nanoserver/dist/src/validation/nanoValidations.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@stechquick/symphony-nanoserver/dist/src/validation/nanoValidations.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NanoValidations = void 0;\nvar NanoValidations = /** @class */ (function () {\n    function NanoValidations() {\n    }\n    NanoValidations.prototype.ValidateUrl = function (path) {\n        if (path.dir.indexOf(\"/..\") > -1) {\n            //why 400 -> https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml [RFC7231, Section 6.5.1]\n            //RFC7231 ->\n            //https://datatracker.ietf.org/doc/html/rfc7231  Section 6.5.1 -> deceptive request routing\n            return { status: 400, content: \"deceptive request routing\" };\n        }\n        return undefined;\n    };\n    return NanoValidations;\n}());\nexports.NanoValidations = NanoValidations;\n//# sourceMappingURL=nanoValidations.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/@stechquick/symphony-nanoserver/dist/src/validation/nanoValidations.js?");

/***/ }),

/***/ "../../../node_modules/abstract-logging/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/abstract-logging/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nfunction noop () { }\n\nconst proto = {\n  fatal: noop,\n  error: noop,\n  warn: noop,\n  info: noop,\n  debug: noop,\n  trace: noop\n}\n\nObject.defineProperty(module, 'exports', {\n  get () {\n    return Object.create(proto)\n  }\n})\n\n\n//# sourceURL=webpack://qui/../../../node_modules/abstract-logging/index.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/ajv.js":
/*!********************************************!*\
  !*** ../../../node_modules/ajv/lib/ajv.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar compileSchema = __webpack_require__(/*! ./compile */ \"../../../node_modules/ajv/lib/compile/index.js\")\n  , resolve = __webpack_require__(/*! ./compile/resolve */ \"../../../node_modules/ajv/lib/compile/resolve.js\")\n  , Cache = __webpack_require__(/*! ./cache */ \"../../../node_modules/ajv/lib/cache.js\")\n  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ \"../../../node_modules/ajv/lib/compile/schema_obj.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"../../../node_modules/fast-json-stable-stringify/index.js\")\n  , formats = __webpack_require__(/*! ./compile/formats */ \"../../../node_modules/ajv/lib/compile/formats.js\")\n  , rules = __webpack_require__(/*! ./compile/rules */ \"../../../node_modules/ajv/lib/compile/rules.js\")\n  , $dataMetaSchema = __webpack_require__(/*! ./data */ \"../../../node_modules/ajv/lib/data.js\")\n  , util = __webpack_require__(/*! ./compile/util */ \"../../../node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = Ajv;\n\nAjv.prototype.validate = validate;\nAjv.prototype.compile = compile;\nAjv.prototype.addSchema = addSchema;\nAjv.prototype.addMetaSchema = addMetaSchema;\nAjv.prototype.validateSchema = validateSchema;\nAjv.prototype.getSchema = getSchema;\nAjv.prototype.removeSchema = removeSchema;\nAjv.prototype.addFormat = addFormat;\nAjv.prototype.errorsText = errorsText;\n\nAjv.prototype._addSchema = _addSchema;\nAjv.prototype._compile = _compile;\n\nAjv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ \"../../../node_modules/ajv/lib/compile/async.js\");\nvar customKeyword = __webpack_require__(/*! ./keyword */ \"../../../node_modules/ajv/lib/keyword.js\");\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.prototype.validateKeyword = customKeyword.validate;\n\nvar errorClasses = __webpack_require__(/*! ./compile/error_classes */ \"../../../node_modules/ajv/lib/compile/error_classes.js\");\nAjv.ValidationError = errorClasses.Validation;\nAjv.MissingRefError = errorClasses.MissingRef;\nAjv.$dataMetaSchema = $dataMetaSchema;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];\nvar META_SUPPORT_DATA = ['/properties'];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  opts = this._opts = util.copy(opts) || {};\n  setLogger(this);\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n  this._getId = chooseGetId(opts);\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  if (opts.serialize === undefined) opts.serialize = stableStringify;\n  this._metaOpts = getMetaSchemaOptions(this);\n\n  if (opts.formats) addInitialFormats(this);\n  if (opts.keywords) addInitialKeywords(this);\n  addDefaultMetaSchema(this);\n  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);\n  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});\n  addInitialSchemas(this);\n}\n\n\n\n/**\n * Validate data using schema\n * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.\n * @this   Ajv\n * @param  {String|Object} schemaKeyRef key, ref or schema object\n * @param  {Any} data to be validated\n * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n */\nfunction validate(schemaKeyRef, data) {\n  var v;\n  if (typeof schemaKeyRef == 'string') {\n    v = this.getSchema(schemaKeyRef);\n    if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n  } else {\n    var schemaObj = this._addSchema(schemaKeyRef);\n    v = schemaObj.validate || this._compile(schemaObj);\n  }\n\n  var valid = v(data);\n  if (v.$async !== true) this.errors = v.errors;\n  return valid;\n}\n\n\n/**\n * Create validating function for passed schema.\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n * @return {Function} validating function\n */\nfunction compile(schema, _meta) {\n  var schemaObj = this._addSchema(schema, undefined, _meta);\n  return schemaObj.validate || this._compile(schemaObj);\n}\n\n\n/**\n * Adds schema to the instance.\n * @this   Ajv\n * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n * @return {Ajv} this for method chaining\n */\nfunction addSchema(schema, key, _skipValidation, _meta) {\n  if (Array.isArray(schema)){\n    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);\n    return this;\n  }\n  var id = this._getId(schema);\n  if (id !== undefined && typeof id != 'string')\n    throw new Error('schema id must be string');\n  key = resolve.normalizeId(key || id);\n  checkUnique(this, key);\n  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n  return this;\n}\n\n\n/**\n * Add schema that will be used to validate other schemas\n * options in META_IGNORE_OPTIONS are alway set to false\n * @this   Ajv\n * @param {Object} schema schema object\n * @param {String} key optional schema key\n * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n * @return {Ajv} this for method chaining\n */\nfunction addMetaSchema(schema, key, skipValidation) {\n  this.addSchema(schema, key, skipValidation, true);\n  return this;\n}\n\n\n/**\n * Validate schema\n * @this   Ajv\n * @param {Object} schema schema to validate\n * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n * @return {Boolean} true if schema is valid\n */\nfunction validateSchema(schema, throwOrLogError) {\n  var $schema = schema.$schema;\n  if ($schema !== undefined && typeof $schema != 'string')\n    throw new Error('$schema must be a string');\n  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n  if (!$schema) {\n    this.logger.warn('meta-schema not available');\n    this.errors = null;\n    return true;\n  }\n  var valid = this.validate($schema, schema);\n  if (!valid && throwOrLogError) {\n    var message = 'schema is invalid: ' + this.errorsText();\n    if (this._opts.validateSchema == 'log') this.logger.error(message);\n    else throw new Error(message);\n  }\n  return valid;\n}\n\n\nfunction defaultMeta(self) {\n  var meta = self._opts.meta;\n  self._opts.defaultMeta = typeof meta == 'object'\n                            ? self._getId(meta) || meta\n                            : self.getSchema(META_SCHEMA_ID)\n                              ? META_SCHEMA_ID\n                              : undefined;\n  return self._opts.defaultMeta;\n}\n\n\n/**\n * Get compiled schema from the instance by `key` or `ref`.\n * @this   Ajv\n * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n * @return {Function} schema validating function (with property `schema`).\n */\nfunction getSchema(keyRef) {\n  var schemaObj = _getSchemaObj(this, keyRef);\n  switch (typeof schemaObj) {\n    case 'object': return schemaObj.validate || this._compile(schemaObj);\n    case 'string': return this.getSchema(schemaObj);\n    case 'undefined': return _getSchemaFragment(this, keyRef);\n  }\n}\n\n\nfunction _getSchemaFragment(self, ref) {\n  var res = resolve.schema.call(self, { schema: {} }, ref);\n  if (res) {\n    var schema = res.schema\n      , root = res.root\n      , baseId = res.baseId;\n    var v = compileSchema.call(self, schema, root, undefined, baseId);\n    self._fragments[ref] = new SchemaObject({\n      ref: ref,\n      fragment: true,\n      schema: schema,\n      root: root,\n      baseId: baseId,\n      validate: v\n    });\n    return v;\n  }\n}\n\n\nfunction _getSchemaObj(self, keyRef) {\n  keyRef = resolve.normalizeId(keyRef);\n  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n}\n\n\n/**\n * Remove cached schema(s).\n * If no parameter is passed all schemas but meta-schemas are removed.\n * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n * @this   Ajv\n * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n * @return {Ajv} this for method chaining\n */\nfunction removeSchema(schemaKeyRef) {\n  if (schemaKeyRef instanceof RegExp) {\n    _removeAllSchemas(this, this._schemas, schemaKeyRef);\n    _removeAllSchemas(this, this._refs, schemaKeyRef);\n    return this;\n  }\n  switch (typeof schemaKeyRef) {\n    case 'undefined':\n      _removeAllSchemas(this, this._schemas);\n      _removeAllSchemas(this, this._refs);\n      this._cache.clear();\n      return this;\n    case 'string':\n      var schemaObj = _getSchemaObj(this, schemaKeyRef);\n      if (schemaObj) this._cache.del(schemaObj.cacheKey);\n      delete this._schemas[schemaKeyRef];\n      delete this._refs[schemaKeyRef];\n      return this;\n    case 'object':\n      var serialize = this._opts.serialize;\n      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n      this._cache.del(cacheKey);\n      var id = this._getId(schemaKeyRef);\n      if (id) {\n        id = resolve.normalizeId(id);\n        delete this._schemas[id];\n        delete this._refs[id];\n      }\n  }\n  return this;\n}\n\n\nfunction _removeAllSchemas(self, schemas, regex) {\n  for (var keyRef in schemas) {\n    var schemaObj = schemas[keyRef];\n    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n      self._cache.del(schemaObj.cacheKey);\n      delete schemas[keyRef];\n    }\n  }\n}\n\n\n/* @this   Ajv */\nfunction _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n  if (typeof schema != 'object' && typeof schema != 'boolean')\n    throw new Error('schema should be object or boolean');\n  var serialize = this._opts.serialize;\n  var cacheKey = serialize ? serialize(schema) : schema;\n  var cached = this._cache.get(cacheKey);\n  if (cached) return cached;\n\n  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n\n  var id = resolve.normalizeId(this._getId(schema));\n  if (id && shouldAddSchema) checkUnique(this, id);\n\n  var willValidate = this._opts.validateSchema !== false && !skipValidation;\n  var recursiveMeta;\n  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n    this.validateSchema(schema, true);\n\n  var localRefs = resolve.ids.call(this, schema);\n\n  var schemaObj = new SchemaObject({\n    id: id,\n    schema: schema,\n    localRefs: localRefs,\n    cacheKey: cacheKey,\n    meta: meta\n  });\n\n  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;\n  this._cache.put(cacheKey, schemaObj);\n\n  if (willValidate && recursiveMeta) this.validateSchema(schema, true);\n\n  return schemaObj;\n}\n\n\n/* @this   Ajv */\nfunction _compile(schemaObj, root) {\n  if (schemaObj.compiling) {\n    schemaObj.validate = callValidate;\n    callValidate.schema = schemaObj.schema;\n    callValidate.errors = null;\n    callValidate.root = root ? root : callValidate;\n    if (schemaObj.schema.$async === true)\n      callValidate.$async = true;\n    return callValidate;\n  }\n  schemaObj.compiling = true;\n\n  var currentOpts;\n  if (schemaObj.meta) {\n    currentOpts = this._opts;\n    this._opts = this._metaOpts;\n  }\n\n  var v;\n  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }\n  catch(e) {\n    delete schemaObj.validate;\n    throw e;\n  }\n  finally {\n    schemaObj.compiling = false;\n    if (schemaObj.meta) this._opts = currentOpts;\n  }\n\n  schemaObj.validate = v;\n  schemaObj.refs = v.refs;\n  schemaObj.refVal = v.refVal;\n  schemaObj.root = v.root;\n  return v;\n\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var _validate = schemaObj.validate;\n    var result = _validate.apply(this, arguments);\n    callValidate.errors = _validate.errors;\n    return result;\n  }\n}\n\n\nfunction chooseGetId(opts) {\n  switch (opts.schemaId) {\n    case 'auto': return _get$IdOrId;\n    case 'id': return _getId;\n    default: return _get$Id;\n  }\n}\n\n/* @this   Ajv */\nfunction _getId(schema) {\n  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);\n  return schema.id;\n}\n\n/* @this   Ajv */\nfunction _get$Id(schema) {\n  if (schema.id) this.logger.warn('schema id ignored', schema.id);\n  return schema.$id;\n}\n\n\nfunction _get$IdOrId(schema) {\n  if (schema.$id && schema.id && schema.$id != schema.id)\n    throw new Error('schema $id is different from id');\n  return schema.$id || schema.id;\n}\n\n\n/**\n * Convert array of error message objects to string\n * @this   Ajv\n * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n * @param  {Object} options optional options with properties `separator` and `dataVar`.\n * @return {String} human readable string with all errors descriptions\n */\nfunction errorsText(errors, options) {\n  errors = errors || this.errors;\n  if (!errors) return 'No errors';\n  options = options || {};\n  var separator = options.separator === undefined ? ', ' : options.separator;\n  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n  var text = '';\n  for (var i=0; i<errors.length; i++) {\n    var e = errors[i];\n    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n  }\n  return text.slice(0, -separator.length);\n}\n\n\n/**\n * Add custom format\n * @this   Ajv\n * @param {String} name format name\n * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n * @return {Ajv} this for method chaining\n */\nfunction addFormat(name, format) {\n  if (typeof format == 'string') format = new RegExp(format);\n  this._formats[name] = format;\n  return this;\n}\n\n\nfunction addDefaultMetaSchema(self) {\n  var $dataSchema;\n  if (self._opts.$data) {\n    $dataSchema = __webpack_require__(/*! ./refs/data.json */ \"../../../node_modules/ajv/lib/refs/data.json\");\n    self.addMetaSchema($dataSchema, $dataSchema.$id, true);\n  }\n  if (self._opts.meta === false) return;\n  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"../../../node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n}\n\n\nfunction addInitialSchemas(self) {\n  var optsSchemas = self._opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);\n  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);\n}\n\n\nfunction addInitialFormats(self) {\n  for (var name in self._opts.formats) {\n    var format = self._opts.formats[name];\n    self.addFormat(name, format);\n  }\n}\n\n\nfunction addInitialKeywords(self) {\n  for (var name in self._opts.keywords) {\n    var keyword = self._opts.keywords[name];\n    self.addKeyword(name, keyword);\n  }\n}\n\n\nfunction checkUnique(self, id) {\n  if (self._schemas[id] || self._refs[id])\n    throw new Error('schema with key or id \"' + id + '\" already exists');\n}\n\n\nfunction getMetaSchemaOptions(self) {\n  var metaOpts = util.copy(self._opts);\n  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n    delete metaOpts[META_IGNORE_OPTIONS[i]];\n  return metaOpts;\n}\n\n\nfunction setLogger(self) {\n  var logger = self._opts.logger;\n  if (logger === false) {\n    self.logger = {log: noop, warn: noop, error: noop};\n  } else {\n    if (logger === undefined) logger = console;\n    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))\n      throw new Error('logger must implement log, warn and error methods');\n    self.logger = logger;\n  }\n}\n\n\nfunction noop() {}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/ajv.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/cache.js":
/*!**********************************************!*\
  !*** ../../../node_modules/ajv/lib/cache.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\nvar Cache = module.exports = function Cache() {\n  this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n  this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n  return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n  delete this._cache[key];\n};\n\n\nCache.prototype.clear = function Cache_clear() {\n  this._cache = {};\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/cache.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/async.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/async.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar MissingRefError = (__webpack_require__(/*! ./error_classes */ \"../../../node_modules/ajv/lib/compile/error_classes.js\").MissingRef);\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/async.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/equal.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/equal.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// do NOT remove this file - it would break pre-compiled schemas\n// https://github.com/ajv-validator/ajv/issues/889\nmodule.exports = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\");\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/equal.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/error_classes.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/error_classes.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"../../../node_modules/ajv/lib/compile/resolve.js\");\n\nmodule.exports = {\n  Validation: errorSubclass(ValidationError),\n  MissingRef: errorSubclass(MissingRefError)\n};\n\n\nfunction ValidationError(errors) {\n  this.message = 'validation failed';\n  this.errors = errors;\n  this.ajv = this.validation = true;\n}\n\n\nMissingRefError.message = function (baseId, ref) {\n  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;\n};\n\n\nfunction MissingRefError(baseId, ref, message) {\n  this.message = message || MissingRefError.message(baseId, ref);\n  this.missingRef = resolve.url(baseId, ref);\n  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));\n}\n\n\nfunction errorSubclass(Subclass) {\n  Subclass.prototype = Object.create(Error.prototype);\n  Subclass.prototype.constructor = Subclass;\n  return Subclass;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/error_classes.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/formats.js":
/*!********************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/formats.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"../../../node_modules/ajv/lib/compile/util.js\");\n\nvar DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nvar HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nvar URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nvar URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\n// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.\n// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nvar URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;\nvar UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nvar JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nvar JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nvar RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: UUID,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nformats.full = {\n  date: date,\n  time: time,\n  'date-time': date_time,\n  uri: uri,\n  'uri-reference': URIREF,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: HOSTNAME,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  uuid: UUID,\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nfunction isLeapYear(year) {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var year = +matches[1];\n  var month = +matches[2];\n  var day = +matches[3];\n\n  return month >= 1 && month <= 12 && day >= 1 &&\n          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\n\n\nfunction time(str, full) {\n  var matches = str.match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  var timeZone = matches[5];\n  return ((hour <= 23 && minute <= 59 && second <= 59) ||\n          (hour == 23 && minute == 59 && second == 60)) &&\n         (!full || timeZone);\n}\n\n\nvar DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nvar Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n  if (Z_ANCHOR.test(str)) return false;\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/formats.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"../../../node_modules/ajv/lib/compile/resolve.js\")\n  , util = __webpack_require__(/*! ./util */ \"../../../node_modules/ajv/lib/compile/util.js\")\n  , errorClasses = __webpack_require__(/*! ./error_classes */ \"../../../node_modules/ajv/lib/compile/error_classes.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"../../../node_modules/fast-json-stable-stringify/index.js\");\n\nvar validateGenerator = __webpack_require__(/*! ../dotjs/validate */ \"../../../node_modules/ajv/lib/dotjs/validate.js\");\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\nvar equal = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\");\n\n// this error is thrown by async schemas to return validation errors via exception\nvar ValidationError = errorClasses.Validation;\n\nmodule.exports = compile;\n\n\n/**\n * Compiles schema to validation function\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Object} root object with information about the root schema for this schema\n * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution\n * @param  {String} baseId base ID for IDs in the schema\n * @return {Function} validation function\n */\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  /* eslint no-shadow: 0 */\n  var self = this\n    , opts = this._opts\n    , refVal = [ undefined ]\n    , refs = {}\n    , patterns = []\n    , patternsHash = {}\n    , defaults = []\n    , defaultsHash = {}\n    , customRules = [];\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var c = checkCompiling.call(this, schema, root, baseId);\n  var compilation = this._compilations[c.index];\n  if (c.compiling) return (compilation.callValidate = callValidate);\n\n  var formats = this._formats;\n  var RULES = this.RULES;\n\n  try {\n    var v = localCompile(schema, root, localRefs, baseId);\n    compilation.validate = v;\n    var cv = compilation.callValidate;\n    if (cv) {\n      cv.schema = v.schema;\n      cv.errors = null;\n      cv.refs = v.refs;\n      cv.refVal = v.refVal;\n      cv.root = v.root;\n      cv.$async = v.$async;\n      if (opts.sourceCode) cv.source = v.source;\n    }\n    return v;\n  } finally {\n    endCompiling.call(this, schema, root, baseId);\n  }\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var validate = compilation.validate;\n    var result = validate.apply(this, arguments);\n    callValidate.errors = validate.errors;\n    return result;\n  }\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var $async = _schema.$async === true;\n\n    var sourceCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errSchemaPath: '#',\n      errorPath: '\"\"',\n      MissingRefError: errorClasses.MissingRef,\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      useDefault: useDefault,\n      useCustomRule: useCustomRule,\n      opts: opts,\n      formats: formats,\n      logger: self.logger,\n      self: self\n    });\n\n    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)\n                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)\n                   + sourceCode;\n\n    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);\n    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));\n    var validate;\n    try {\n      var makeValidate = new Function(\n        'self',\n        'RULES',\n        'formats',\n        'root',\n        'refVal',\n        'defaults',\n        'customRules',\n        'equal',\n        'ucs2length',\n        'ValidationError',\n        sourceCode\n      );\n\n      validate = makeValidate(\n        self,\n        RULES,\n        formats,\n        root,\n        refVal,\n        defaults,\n        customRules,\n        equal,\n        ucs2length,\n        ValidationError\n      );\n\n      refVal[0] = validate;\n    } catch(e) {\n      self.logger.error('Error compiling schema, function code:', sourceCode);\n      throw e;\n    }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n    if ($async) validate.$async = true;\n    if (opts.sourceCode === true) {\n      validate.source = {\n        code: sourceCode,\n        patterns: patterns,\n        defaults: defaults\n      };\n    }\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot && root.refs) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (v === undefined) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v === undefined) {\n      removeLocalRef(ref);\n    } else {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function removeLocalRef(ref) {\n    delete refs[ref];\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(refVal, code) {\n    return typeof refVal == 'object' || typeof refVal == 'boolean'\n            ? { code: code, schema: refVal, inline: true }\n            : { code: code, $async: refVal && !!refVal.$async };\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n\n  function useDefault(value) {\n    switch (typeof value) {\n      case 'boolean':\n      case 'number':\n        return '' + value;\n      case 'string':\n        return util.toQuotedString(value);\n      case 'object':\n        if (value === null) return 'null';\n        var valueStr = stableStringify(value);\n        var index = defaultsHash[valueStr];\n        if (index === undefined) {\n          index = defaultsHash[valueStr] = defaults.length;\n          defaults[index] = value;\n        }\n        return 'default' + index;\n    }\n  }\n\n  function useCustomRule(rule, schema, parentSchema, it) {\n    if (self._opts.validateSchema !== false) {\n      var deps = rule.definition.dependencies;\n      if (deps && !deps.every(function(keyword) {\n        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);\n      }))\n        throw new Error('parent schema must have all required keywords: ' + deps.join(','));\n\n      var validateSchema = rule.definition.validateSchema;\n      if (validateSchema) {\n        var valid = validateSchema(schema);\n        if (!valid) {\n          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);\n          if (self._opts.validateSchema == 'log') self.logger.error(message);\n          else throw new Error(message);\n        }\n      }\n    }\n\n    var compile = rule.definition.compile\n      , inline = rule.definition.inline\n      , macro = rule.definition.macro;\n\n    var validate;\n    if (compile) {\n      validate = compile.call(self, schema, parentSchema, it);\n    } else if (macro) {\n      validate = macro.call(self, schema, parentSchema, it);\n      if (opts.validateSchema !== false) self.validateSchema(validate, true);\n    } else if (inline) {\n      validate = inline.call(self, it, rule.keyword, schema, parentSchema);\n    } else {\n      validate = rule.definition.validate;\n      if (!validate) return;\n    }\n\n    if (validate === undefined)\n      throw new Error('custom keyword \"' + rule.keyword + '\"failed to compile');\n\n    var index = customRules.length;\n    customRules[index] = validate;\n\n    return {\n      code: 'customRule' + index,\n      validate: validate\n    };\n  }\n}\n\n\n/**\n * Checks if the schema is currently compiled\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Object} object with properties \"index\" (compilation index) and \"compiling\" (boolean)\n */\nfunction checkCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var index = compIndex.call(this, schema, root, baseId);\n  if (index >= 0) return { index: index, compiling: true };\n  index = this._compilations.length;\n  this._compilations[index] = {\n    schema: schema,\n    root: root,\n    baseId: baseId\n  };\n  return { index: index, compiling: false };\n}\n\n\n/**\n * Removes the schema from the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n */\nfunction endCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var i = compIndex.call(this, schema, root, baseId);\n  if (i >= 0) this._compilations.splice(i, 1);\n}\n\n\n/**\n * Index of schema compilation in the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Integer} compilation index\n */\nfunction compIndex(schema, root, baseId) {\n  /* jshint validthis: true */\n  for (var i=0; i<this._compilations.length; i++) {\n    var c = this._compilations[i];\n    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;\n  }\n  return -1;\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction defaultCode(i) {\n  return 'var default' + i + ' = defaults[' + i + '];';\n}\n\n\nfunction refValCode(i, refVal) {\n  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';\n}\n\n\nfunction customRuleCode(i) {\n  return 'var customRule' + i + ' = customRules[' + i + '];';\n}\n\n\nfunction vars(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/index.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/resolve.js":
/*!********************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/resolve.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar URI = __webpack_require__(/*! uri-js */ \"../../../node_modules/uri-js/dist/es5/uri.all.js\")\n  , equal = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\")\n  , util = __webpack_require__(/*! ./util */ \"../../../node_modules/ajv/lib/compile/util.js\")\n  , SchemaObject = __webpack_require__(/*! ./schema_obj */ \"../../../node_modules/ajv/lib/compile/schema_obj.js\")\n  , traverse = __webpack_require__(/*! json-schema-traverse */ \"../../../node_modules/json-schema-traverse/index.js\");\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n\n\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = URI.parse(ref)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(this._getId(root.schema));\n  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\n/* @this Ajv */\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    var id = this._getId(schema);\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.fragment = parsedRef.fragment || '';\n  if (parsedRef.fragment.slice(0,1) != '/') return;\n  var parts = parsedRef.fragment.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n  if (schema !== undefined && schema !== root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum'\n]);\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = URI.parse(id);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return URI.serialize(p).split('#')[0] + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\n\n\n/* @this Ajv */\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {'': schemaId};\n  var fullPaths = {'': getFullPath(schemaId, false)};\n  var localRefs = {};\n  var self = this;\n\n  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n    var id = self._getId(sch);\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined)\n      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);\n\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema))\n          throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id]))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n\n  return localRefs;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/resolve.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/rules.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/rules.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ruleModules = __webpack_require__(/*! ../dotjs */ \"../../../node_modules/ajv/lib/dotjs/index.js\")\n  , toHash = (__webpack_require__(/*! ./util */ \"../../../node_modules/ajv/lib/compile/util.js\").toHash);\n\nmodule.exports = function rules() {\n  var RULES = [\n    { type: 'number',\n      rules: [ { 'maximum': ['exclusiveMaximum'] },\n               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },\n    { type: 'string',\n      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n    { type: 'array',\n      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },\n    { type: 'object',\n      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',\n               { 'properties': ['additionalProperties', 'patternProperties'] } ] },\n    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }\n  ];\n\n  var ALL = [ 'type', '$comment' ];\n  var KEYWORDS = [\n    '$schema', '$id', 'id', '$data', '$async', 'title',\n    'description', 'default', 'definitions',\n    'examples', 'readOnly', 'writeOnly',\n    'contentMediaType', 'contentEncoding',\n    'additionalItems', 'then', 'else'\n  ];\n  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];\n  RULES.all = toHash(ALL);\n  RULES.types = toHash(TYPES);\n\n  RULES.forEach(function (group) {\n    group.rules = group.rules.map(function (keyword) {\n      var implKeywords;\n      if (typeof keyword == 'object') {\n        var key = Object.keys(keyword)[0];\n        implKeywords = keyword[key];\n        keyword = key;\n        implKeywords.forEach(function (k) {\n          ALL.push(k);\n          RULES.all[k] = true;\n        });\n      }\n      ALL.push(keyword);\n      var rule = RULES.all[keyword] = {\n        keyword: keyword,\n        code: ruleModules[keyword],\n        implements: implKeywords\n      };\n      return rule;\n    });\n\n    RULES.all.$comment = {\n      keyword: '$comment',\n      code: ruleModules.$comment\n    };\n\n    if (group.type) RULES.types[group.type] = group;\n  });\n\n  RULES.keywords = toHash(ALL.concat(KEYWORDS));\n  RULES.custom = {};\n\n  return RULES;\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/rules.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/schema_obj.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/schema_obj.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"../../../node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n  util.copy(obj, this);\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/schema_obj.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/ucs2length.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/ucs2length.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nmodule.exports = function ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/ucs2length.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/compile/util.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/ajv/lib/compile/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  coerceToTypes: coerceToTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  equal: __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\"),\n  ucs2length: __webpack_require__(/*! ./ucs2length */ \"../../../node_modules/ajv/lib/compile/ucs2length.js\"),\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  schemaHasRules: schemaHasRules,\n  schemaHasRulesExcept: schemaHasRulesExcept,\n  schemaUnknownRules: schemaUnknownRules,\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath,\n  getData: getData,\n  unescapeFragment: unescapeFragment,\n  unescapeJsonPointer: unescapeJsonPointer,\n  escapeFragment: escapeFragment,\n  escapeJsonPointer: escapeJsonPointer\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, strictNumbers, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1)' +\n                           AND + data + EQUAL + data +\n                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    case 'number': return '(typeof ' + data + EQUAL + '\"' + dataType + '\"' +\n                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data, strictNumbers) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);\n\n      return code;\n  }\n}\n\n\nvar COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);\nfunction coerceToTypes(optionCoerceTypes, dataTypes) {\n  if (Array.isArray(dataTypes)) {\n    var types = [];\n    for (var i=0; i<dataTypes.length; i++) {\n      var t = dataTypes[i];\n      if (COERCE_TO_TYPES[t]) types[types.length] = t;\n      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;\n    }\n    if (types.length) return types;\n  } else if (COERCE_TO_TYPES[dataTypes]) {\n    return [dataTypes];\n  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {\n    return ['array'];\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return typeof key == 'number'\n          ? '[' + key + ']'\n          : IDENTIFIER.test(key)\n            ? '.' + key\n            : \"['\" + escapeQuotes(key) + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\f/g, '\\\\f')\n            .replace(/\\t/g, '\\\\t');\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  expr = expr.replace(/\\$/g, '$$$$');\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == 'boolean') return !schema;\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction schemaHasRulesExcept(schema, rules, exceptKeyword) {\n  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';\n  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;\n}\n\n\nfunction schemaUnknownRules(schema, rules) {\n  if (typeof schema == 'boolean') return;\n  for (var key in schema) if (!rules[key]) return key;\n}\n\n\nfunction toQuotedString(str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr(currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers // false by default\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath(currentPath, prop, jsonPointers) {\n  var path = jsonPointers // false by default\n              ? toQuotedString('/' + escapeJsonPointer(prop))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, lvl, paths) {\n  var up, jsonPointer, data, matches;\n  if ($data === '') return 'rootData';\n  if ($data[0] == '/') {\n    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);\n    jsonPointer = $data;\n    data = 'rootData';\n  } else {\n    matches = $data.match(RELATIVE_JSON_POINTER);\n    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);\n    up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer == '#') {\n      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);\n      return paths[lvl - up];\n    }\n\n    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);\n    data = 'data' + ((lvl - up) || '');\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split('/');\n  for (var i=0; i<segments.length; i++) {\n    var segment = segments[i];\n    if (segment) {\n      data += getProperty(unescapeJsonPointer(segment));\n      expr += ' && ' + data;\n    }\n  }\n  return expr;\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/([^\\\\])' \\+ '/g, '$1');\n}\n\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\n\nfunction escapeJsonPointer(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/compile/util.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/data.js":
/*!*********************************************!*\
  !*** ../../../node_modules/ajv/lib/data.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar KEYWORDS = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum',\n  'maxLength',\n  'minLength',\n  'pattern',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'maxProperties',\n  'minProperties',\n  'required',\n  'additionalProperties',\n  'enum',\n  'format',\n  'const'\n];\n\nmodule.exports = function (metaSchema, keywordsJsonPointers) {\n  for (var i=0; i<keywordsJsonPointers.length; i++) {\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    var segments = keywordsJsonPointers[i].split('/');\n    var keywords = metaSchema;\n    var j;\n    for (j=1; j<segments.length; j++)\n      keywords = keywords[segments[j]];\n\n    for (j=0; j<KEYWORDS.length; j++) {\n      var key = KEYWORDS[j];\n      var schema = keywords[key];\n      if (schema) {\n        keywords[key] = {\n          anyOf: [\n            schema,\n            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n    }\n  }\n\n  return metaSchema;\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/data.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/definition_schema.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/ajv/lib/definition_schema.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"../../../node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n\nmodule.exports = {\n  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',\n  definitions: {\n    simpleTypes: metaSchema.definitions.simpleTypes\n  },\n  type: 'object',\n  dependencies: {\n    schema: ['validate'],\n    $data: ['validate'],\n    statements: ['inline'],\n    valid: {not: {required: ['macro']}}\n  },\n  properties: {\n    type: metaSchema.properties.type,\n    schema: {type: 'boolean'},\n    statements: {type: 'boolean'},\n    dependencies: {\n      type: 'array',\n      items: {type: 'string'}\n    },\n    metaSchema: {type: 'object'},\n    modifying: {type: 'boolean'},\n    valid: {type: 'boolean'},\n    $data: {type: 'boolean'},\n    async: {type: 'boolean'},\n    errors: {\n      anyOf: [\n        {type: 'boolean'},\n        {const: 'full'}\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/definition_schema.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/_limit.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/_limit.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limit(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $isMax = $keyword == 'maximum',\n    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',\n    $schemaExcl = it.schema[$exclusiveKeyword],\n    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,\n    $op = $isMax ? '<' : '>',\n    $notOp = $isMax ? '>' : '<',\n    $errorKeyword = undefined;\n  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {\n    throw new Error($keyword + ' must be number');\n  }\n  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {\n    throw new Error($exclusiveKeyword + ' must be number or boolean');\n  }\n  if ($isDataExcl) {\n    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),\n      $exclusive = 'exclusive' + $lvl,\n      $exclType = 'exclType' + $lvl,\n      $exclIsNumber = 'exclIsNumber' + $lvl,\n      $opExpr = 'op' + $lvl,\n      $opStr = '\\' + ' + $opExpr + ' + \\'';\n    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';\n    $schemaValueExcl = 'schemaExcl' + $lvl;\n    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';\n    var $errorKeyword = $exclusiveKeyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else if ( ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n    }\n    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';\n    if ($schema === undefined) {\n      $errorKeyword = $exclusiveKeyword;\n      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n      $schemaValue = $schemaValueExcl;\n      $isData = $isDataExcl;\n    }\n  } else {\n    var $exclIsNumber = typeof $schemaExcl == 'number',\n      $opStr = $op;\n    if ($exclIsNumber && $isData) {\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';\n    } else {\n      if ($exclIsNumber && $schema === undefined) {\n        $exclusive = true;\n        $errorKeyword = $exclusiveKeyword;\n        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n        $schemaValue = $schemaExcl;\n        $notOp += '=';\n      } else {\n        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);\n        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {\n          $exclusive = true;\n          $errorKeyword = $exclusiveKeyword;\n          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n          $notOp += '=';\n        } else {\n          $exclusive = false;\n          $opStr += '=';\n        }\n      }\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';\n    }\n  }\n  $errorKeyword = $errorKeyword || $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($opStr) + ' ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/_limit.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/_limitItems.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxItems' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxItems') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' items\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/_limitItems.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/_limitLength.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitLength(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxLength' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be ';\n      if ($keyword == 'maxLength') {\n        out += 'longer';\n      } else {\n        out += 'shorter';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' characters\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/_limitLength.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitProperties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxProperties' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxProperties') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' properties\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/_limitProperties.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/allOf.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/allOf.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_allOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $allSchemasEmpty = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $allSchemasEmpty = false;\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    if ($allSchemasEmpty) {\n      out += ' if (true) { ';\n    } else {\n      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/allOf.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/anyOf.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/anyOf.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_anyOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));\n  });\n  if ($noEmptySchema) {\n    var $currentBaseId = $it.baseId;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match some schema in anyOf\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/anyOf.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/comment.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/comment.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_comment(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $comment = it.util.toQuotedString($schema);\n  if (it.opts.$comment === true) {\n    out += ' console.log(' + ($comment) + ');';\n  } else if (typeof it.opts.$comment == 'function') {\n    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/comment.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/const.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/const.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_const(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!$isData) {\n    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to constant\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/const.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/contains.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/contains.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_contains(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId,\n    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($nonEmptySchema) {\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    out += ' if (' + ($nextValid) + ') break; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';\n  } else {\n    out += ' if (' + ($data) + '.length == 0) {';\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should contain a valid item\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } else { ';\n  if ($nonEmptySchema) {\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n  }\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/contains.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/custom.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/custom.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_custom(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $rule = this,\n    $definition = 'definition' + $lvl,\n    $rDef = $rule.definition,\n    $closingBraces = '';\n  var $compile, $inline, $macro, $ruleValidate, $validateCode;\n  if ($isData && $rDef.$data) {\n    $validateCode = 'keywordValidate' + $lvl;\n    var $validateSchema = $rDef.validateSchema;\n    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';\n  } else {\n    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);\n    if (!$ruleValidate) return;\n    $schemaValue = 'validate.schema' + $schemaPath;\n    $validateCode = $ruleValidate.code;\n    $compile = $rDef.compile;\n    $inline = $rDef.inline;\n    $macro = $rDef.macro;\n  }\n  var $ruleErrs = $validateCode + '.errors',\n    $i = 'i' + $lvl,\n    $ruleErr = 'ruleErr' + $lvl,\n    $asyncKeyword = $rDef.async;\n  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');\n  if (!($inline || $macro)) {\n    out += '' + ($ruleErrs) + ' = null;';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($isData && $rDef.$data) {\n    $closingBraces += '}';\n    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';\n    if ($validateSchema) {\n      $closingBraces += '}';\n      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';\n    }\n  }\n  if ($inline) {\n    if ($rDef.statements) {\n      out += ' ' + ($ruleValidate.validate) + ' ';\n    } else {\n      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';\n    }\n  } else if ($macro) {\n    var $it = it.util.copy(it);\n    var $closingBraces = '';\n    $it.level++;\n    var $nextValid = 'valid' + $it.level;\n    $it.schema = $ruleValidate.validate;\n    $it.schemaPath = '';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($code);\n  } else {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    out += '  ' + ($validateCode) + '.call( ';\n    if (it.opts.passContext) {\n      out += 'this';\n    } else {\n      out += 'self';\n    }\n    if ($compile || $rDef.schema === false) {\n      out += ' , ' + ($data) + ' ';\n    } else {\n      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';\n    }\n    out += ' , (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';\n    var def_callRuleValidate = out;\n    out = $$outStack.pop();\n    if ($rDef.errors === false) {\n      out += ' ' + ($valid) + ' = ';\n      if ($asyncKeyword) {\n        out += 'await ';\n      }\n      out += '' + (def_callRuleValidate) + '; ';\n    } else {\n      if ($asyncKeyword) {\n        $ruleErrs = 'customErrors' + $lvl;\n        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';\n      } else {\n        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';\n      }\n    }\n  }\n  if ($rDef.modifying) {\n    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';\n  }\n  out += '' + ($closingBraces);\n  if ($rDef.valid) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  } else {\n    out += ' if ( ';\n    if ($rDef.valid === undefined) {\n      out += ' !';\n      if ($macro) {\n        out += '' + ($nextValid);\n      } else {\n        out += '' + ($valid);\n      }\n    } else {\n      out += ' ' + (!$rDef.valid) + ' ';\n    }\n    out += ') { ';\n    $errorKeyword = $rule.keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    var def_customError = out;\n    out = $$outStack.pop();\n    if ($inline) {\n      if ($rDef.errors) {\n        if ($rDef.errors != 'full') {\n          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } ';\n        }\n      } else {\n        if ($rDef.errors === false) {\n          out += ' ' + (def_customError) + ' ';\n        } else {\n          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } } ';\n        }\n      }\n    } else if ($macro) {\n      out += '   var err =   '; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError(vErrors); ';\n        } else {\n          out += ' validate.errors = vErrors; return false; ';\n        }\n      }\n    } else {\n      if ($rDef.errors === false) {\n        out += ' ' + (def_customError) + ' ';\n      } else {\n        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\";  ';\n        if (it.opts.verbose) {\n          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n        }\n        out += ' } } else { ' + (def_customError) + ' } ';\n      }\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/custom.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/dependencies.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/dependencies.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_dependencies(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $schemaDeps = {},\n    $propertyDeps = {},\n    $ownProperties = it.opts.ownProperties;\n  for ($property in $schema) {\n    if ($property == '__proto__') continue;\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  var $currentErrorPath = it.errorPath;\n  out += 'var missing' + ($lvl) + ';';\n  for (var $property in $propertyDeps) {\n    $deps = $propertyDeps[$property];\n    if ($deps.length) {\n      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      if ($breakOnError) {\n        out += ' && ( ';\n        var arr1 = $deps;\n        if (arr1) {\n          var $propertyKey, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $propertyKey = arr1[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ')) {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should have ';\n            if ($deps.length == 1) {\n              out += 'property ' + (it.util.escapeQuotes($deps[0]));\n            } else {\n              out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n            }\n            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      } else {\n        out += ' ) { ';\n        var arr2 = $deps;\n        if (arr2) {\n          var $propertyKey, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $propertyKey = arr2[i2 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should have ';\n                if ($deps.length == 1) {\n                  out += 'property ' + (it.util.escapeQuotes($deps[0]));\n                } else {\n                  out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n                }\n                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n      out += ' }   ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n  }\n  it.errorPath = $currentErrorPath;\n  var $currentBaseId = $it.baseId;\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      out += ') { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/dependencies.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/enum.js":
/*!***************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/enum.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_enum(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $i = 'i' + $lvl,\n    $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ';';\n  if ($isData) {\n    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n  }\n  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';\n  if ($isData) {\n    out += '  }  ';\n  }\n  out += ' if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of the allowed values\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/enum.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/format.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/format.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_format(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  if (it.opts.format === false) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n    return out;\n  }\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $unknownFormats = it.opts.unknownFormats,\n    $allowUnknown = Array.isArray($unknownFormats);\n  if ($isData) {\n    var $format = 'format' + $lvl,\n      $isObject = 'isObject' + $lvl,\n      $formatType = 'formatType' + $lvl;\n    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';\n    if (it.async) {\n      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';\n    }\n    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n    }\n    out += ' (';\n    if ($unknownFormats != 'ignore') {\n      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';\n      if ($allowUnknown) {\n        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';\n      }\n      out += ') || ';\n    }\n    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';\n    if (it.async) {\n      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';\n    } else {\n      out += ' ' + ($format) + '(' + ($data) + ') ';\n    }\n    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';\n  } else {\n    var $format = it.formats[$schema];\n    if (!$format) {\n      if ($unknownFormats == 'ignore') {\n        it.logger.warn('unknown format \"' + $schema + '\" ignored in schema at path \"' + it.errSchemaPath + '\"');\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else {\n        throw new Error('unknown format \"' + $schema + '\" is used in schema at path \"' + it.errSchemaPath + '\"');\n      }\n    }\n    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;\n    var $formatType = $isObject && $format.type || 'string';\n    if ($isObject) {\n      var $async = $format.async === true;\n      $format = $format.validate;\n    }\n    if ($formatType != $ruleType) {\n      if ($breakOnError) {\n        out += ' if (true) { ';\n      }\n      return out;\n    }\n    if ($async) {\n      if (!it.async) throw new Error('async format in sync schema');\n      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';\n      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';\n    } else {\n      out += ' if (! ';\n      var $formatRef = 'formats' + it.util.getProperty($schema);\n      if ($isObject) $formatRef += '.validate';\n      if (typeof $format == 'function') {\n        out += ' ' + ($formatRef) + '(' + ($data) + ') ';\n      } else {\n        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';\n      }\n      out += ') { ';\n    }\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match format \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/format.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/if.js":
/*!*************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/if.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_if(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $thenSch = it.schema['then'],\n    $elseSch = it.schema['else'],\n    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),\n    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),\n    $currentBaseId = $it.baseId;\n  if ($thenPresent || $elsePresent) {\n    var $ifClause;\n    $it.createErrors = false;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += '  ' + (it.validate($it)) + ' ';\n    $it.baseId = $currentBaseId;\n    $it.createErrors = true;\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    if ($thenPresent) {\n      out += ' if (' + ($nextValid) + ') {  ';\n      $it.schema = it.schema['then'];\n      $it.schemaPath = it.schemaPath + '.then';\n      $it.errSchemaPath = it.errSchemaPath + '/then';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';\n      } else {\n        $ifClause = '\\'then\\'';\n      }\n      out += ' } ';\n      if ($elsePresent) {\n        out += ' else { ';\n      }\n    } else {\n      out += ' if (!' + ($nextValid) + ') { ';\n    }\n    if ($elsePresent) {\n      $it.schema = it.schema['else'];\n      $it.schemaPath = it.schemaPath + '.else';\n      $it.errSchemaPath = it.errSchemaPath + '/else';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';\n      } else {\n        $ifClause = '\\'else\\'';\n      }\n      out += ' } ';\n    }\n    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match \"\\' + ' + ($ifClause) + ' + \\'\" schema\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/if.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/index.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': __webpack_require__(/*! ./ref */ \"../../../node_modules/ajv/lib/dotjs/ref.js\"),\n  allOf: __webpack_require__(/*! ./allOf */ \"../../../node_modules/ajv/lib/dotjs/allOf.js\"),\n  anyOf: __webpack_require__(/*! ./anyOf */ \"../../../node_modules/ajv/lib/dotjs/anyOf.js\"),\n  '$comment': __webpack_require__(/*! ./comment */ \"../../../node_modules/ajv/lib/dotjs/comment.js\"),\n  const: __webpack_require__(/*! ./const */ \"../../../node_modules/ajv/lib/dotjs/const.js\"),\n  contains: __webpack_require__(/*! ./contains */ \"../../../node_modules/ajv/lib/dotjs/contains.js\"),\n  dependencies: __webpack_require__(/*! ./dependencies */ \"../../../node_modules/ajv/lib/dotjs/dependencies.js\"),\n  'enum': __webpack_require__(/*! ./enum */ \"../../../node_modules/ajv/lib/dotjs/enum.js\"),\n  format: __webpack_require__(/*! ./format */ \"../../../node_modules/ajv/lib/dotjs/format.js\"),\n  'if': __webpack_require__(/*! ./if */ \"../../../node_modules/ajv/lib/dotjs/if.js\"),\n  items: __webpack_require__(/*! ./items */ \"../../../node_modules/ajv/lib/dotjs/items.js\"),\n  maximum: __webpack_require__(/*! ./_limit */ \"../../../node_modules/ajv/lib/dotjs/_limit.js\"),\n  minimum: __webpack_require__(/*! ./_limit */ \"../../../node_modules/ajv/lib/dotjs/_limit.js\"),\n  maxItems: __webpack_require__(/*! ./_limitItems */ \"../../../node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  minItems: __webpack_require__(/*! ./_limitItems */ \"../../../node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  maxLength: __webpack_require__(/*! ./_limitLength */ \"../../../node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  minLength: __webpack_require__(/*! ./_limitLength */ \"../../../node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  maxProperties: __webpack_require__(/*! ./_limitProperties */ \"../../../node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  minProperties: __webpack_require__(/*! ./_limitProperties */ \"../../../node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  multipleOf: __webpack_require__(/*! ./multipleOf */ \"../../../node_modules/ajv/lib/dotjs/multipleOf.js\"),\n  not: __webpack_require__(/*! ./not */ \"../../../node_modules/ajv/lib/dotjs/not.js\"),\n  oneOf: __webpack_require__(/*! ./oneOf */ \"../../../node_modules/ajv/lib/dotjs/oneOf.js\"),\n  pattern: __webpack_require__(/*! ./pattern */ \"../../../node_modules/ajv/lib/dotjs/pattern.js\"),\n  properties: __webpack_require__(/*! ./properties */ \"../../../node_modules/ajv/lib/dotjs/properties.js\"),\n  propertyNames: __webpack_require__(/*! ./propertyNames */ \"../../../node_modules/ajv/lib/dotjs/propertyNames.js\"),\n  required: __webpack_require__(/*! ./required */ \"../../../node_modules/ajv/lib/dotjs/required.js\"),\n  uniqueItems: __webpack_require__(/*! ./uniqueItems */ \"../../../node_modules/ajv/lib/dotjs/uniqueItems.js\"),\n  validate: __webpack_require__(/*! ./validate */ \"../../../node_modules/ajv/lib/dotjs/validate.js\")\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/index.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/items.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/items.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_items(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';\n      var $currErrSchemaPath = $errSchemaPath;\n      $errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += '  if (!' + ($valid) + ') {   ';\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' } ';\n      $errSchemaPath = $currErrSchemaPath;\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          var $passData = $data + '[' + $i + ']';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errSchemaPath = $errSchemaPath + '/' + $i;\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          $it.dataPathArr[$dataNxt] = $i;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + '[' + $idx + ']';\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!' + ($nextValid) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!' + ($nextValid) + ') break; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/items.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/multipleOf.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_multipleOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  out += 'var division' + ($lvl) + ';if (';\n  if ($isData) {\n    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';\n  }\n  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';\n  if (it.opts.multipleOfPrecision) {\n    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';\n  } else {\n    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';\n  }\n  out += ' ) ';\n  if ($isData) {\n    out += '  )  ';\n  }\n  out += ' ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/multipleOf.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/not.js":
/*!**************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/not.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_not(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.createErrors = false;\n    var $allErrorsOption;\n    if ($it.opts.allErrors) {\n      $allErrorsOption = $it.opts.allErrors;\n      $it.opts.allErrors = false;\n    }\n    out += ' ' + (it.validate($it)) + ' ';\n    $it.createErrors = true;\n    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (' + ($nextValid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/not.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/oneOf.js":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/oneOf.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_oneOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $prevValid = 'prevValid' + $lvl,\n    $passingSchemas = 'passingSchemas' + $lvl;\n  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n      } else {\n        out += ' var ' + ($nextValid) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; return false; ';\n    }\n  }\n  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/oneOf.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/pattern.js":
/*!******************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/pattern.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_pattern(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n  }\n  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/pattern.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/properties.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/properties.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_properties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $key = 'key' + $lvl,\n    $idx = 'idx' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $dataProperties = 'dataProperties' + $lvl;\n  var $schemaKeys = Object.keys($schema || {}).filter(notProto),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties).filter(notProto),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $ownProperties = it.opts.ownProperties,\n    $currentBaseId = it.baseId;\n  var $required = it.schema.required;\n  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {\n    var $requiredHash = it.util.toHash($required);\n  }\n\n  function notProto(p) {\n    return p !== '__proto__';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';\n  if ($ownProperties) {\n    out += ' var ' + ($dataProperties) + ' = undefined;';\n  }\n  if ($checkAdditional) {\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 8) {\n          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      var $additionalProperty = '\\' + ' + $key + ' + \\'';\n      if (it.opts._errorDataPathProperty) {\n        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n      }\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n        } else {\n          out += ' ' + ($nextValid) + ' = false; ';\n          var $currErrSchemaPath = $errSchemaPath;\n          $errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = ''; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is an invalid additional property';\n              } else {\n                out += 'should NOT have additional properties';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            /* istanbul ignore if */\n            if (it.async) {\n              out += ' throw new ValidationError([' + (__err) + ']); ';\n            } else {\n              out += ' validate.errors = [' + (__err) + ']; return false; ';\n            }\n          } else {\n            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          $errSchemaPath = $currErrSchemaPath;\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (' + ($nextValid) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  var $useDefaults = it.opts.useDefaults && !it.compositeRule;\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop,\n            $hasDefault = $useDefaults && $sch.default !== undefined;\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($hasDefault) {\n            out += ' ' + ($code) + ' ';\n          } else {\n            if ($requiredHash && $requiredHash[$propertyKey]) {\n              out += ' if ( ' + ($useData) + ' === undefined ';\n              if ($ownProperties) {\n                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n              }\n              out += ') { ' + ($nextValid) + ' = false; ';\n              var $currentErrorPath = it.errorPath,\n                $currErrSchemaPath = $errSchemaPath,\n                $missingProperty = it.util.escapeQuotes($propertyKey);\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              $errSchemaPath = it.errSchemaPath + '/required';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'';\n                  if (it.opts._errorDataPathProperty) {\n                    out += 'is a required property';\n                  } else {\n                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              $errSchemaPath = $currErrSchemaPath;\n              it.errorPath = $currentErrorPath;\n              out += ' } else { ';\n            } else {\n              if ($breakOnError) {\n                out += ' if ( ' + ($useData) + ' === undefined ';\n                if ($ownProperties) {\n                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ') { ' + ($nextValid) + ' = true; } else { ';\n              } else {\n                out += ' if (' + ($useData) + ' !== undefined ';\n                if ($ownProperties) {\n                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ' ) { ';\n              }\n            }\n            out += ' ' + ($code) + ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($pPropertyKeys.length) {\n    var arr4 = $pPropertyKeys;\n    if (arr4) {\n      var $pProperty, i4 = -1,\n        l4 = arr4.length - 1;\n      while (i4 < l4) {\n        $pProperty = arr4[i4 += 1];\n        var $sch = $pProperties[$pProperty];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          $it.schema = $sch;\n          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);\n          if ($ownProperties) {\n            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n          } else {\n            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n          }\n          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n          out += ' } ';\n          if ($breakOnError) {\n            out += ' else ' + ($nextValid) + ' = true; ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/properties.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/propertyNames.js":
/*!************************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_propertyNames(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  out += 'var ' + ($errs) + ' = errors;';\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    var $key = 'key' + $lvl,\n      $idx = 'idx' + $lvl,\n      $i = 'i' + $lvl,\n      $invalidName = '\\' + ' + $key + ' + \\'',\n      $dataNxt = $it.dataLevel = it.dataLevel + 1,\n      $nextData = 'data' + $dataNxt,\n      $dataProperties = 'dataProperties' + $lvl,\n      $ownProperties = it.opts.ownProperties,\n      $currentBaseId = it.baseId;\n    if ($ownProperties) {\n      out += ' var ' + ($dataProperties) + ' = undefined; ';\n    }\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    out += ' var startErrs' + ($lvl) + ' = errors; ';\n    var $passData = $key;\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    if ($breakOnError) {\n      out += ' break; ';\n    }\n    out += ' } }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/propertyNames.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/ref.js":
/*!**************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/ref.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_ref(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $async, $refCode;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      $async = it.async;\n      $refCode = 'validate';\n    } else {\n      $async = it.root.schema.$async === true;\n      $refCode = 'root.refVal[0]';\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = it.MissingRefError.message(it.baseId, $schema);\n      if (it.opts.missingRefs == 'fail') {\n        it.logger.error($message);\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        it.logger.warn($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        throw new it.MissingRefError(it.baseId, $schema, $message);\n      }\n    } else if ($refVal.inline) {\n      var $it = it.util.copy(it);\n      $it.level++;\n      var $nextValid = 'valid' + $it.level;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      $it.errSchemaPath = $schema;\n      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);\n      out += ' ' + ($code) + ' ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n      }\n    } else {\n      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);\n      $refCode = $refVal.code;\n    }\n  }\n  if ($refCode) {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    if (it.opts.passContext) {\n      out += ' ' + ($refCode) + '.call(this, ';\n    } else {\n      out += ' ' + ($refCode) + '( ';\n    }\n    out += ' ' + ($data) + ', (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';\n    var __callValidate = out;\n    out = $$outStack.pop();\n    if ($async) {\n      if (!it.async) throw new Error('async schema referenced by sync schema');\n      if ($breakOnError) {\n        out += ' var ' + ($valid) + '; ';\n      }\n      out += ' try { await ' + (__callValidate) + '; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = true; ';\n      }\n      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = false; ';\n      }\n      out += ' } ';\n      if ($breakOnError) {\n        out += ' if (' + ($valid) + ') { ';\n      }\n    } else {\n      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/ref.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/required.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/required.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_required(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {\n      var $required = [];\n      var arr1 = $schema;\n      if (arr1) {\n        var $property, i1 = -1,\n          l1 = arr1.length - 1;\n        while (i1 < l1) {\n          $property = arr1[i1 += 1];\n          var $propertySch = it.schema.properties[$property];\n          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {\n            $required[$required.length] = $property;\n          }\n        }\n      }\n    } else {\n      var $required = $schema;\n    }\n  }\n  if ($isData || $required.length) {\n    var $currentErrorPath = it.errorPath,\n      $loopRequired = $isData || $required.length >= it.opts.loopRequired,\n      $ownProperties = it.opts.ownProperties;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        out += ' var ' + ($valid) + ' = true; ';\n        if ($isData) {\n          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';\n        if ($ownProperties) {\n          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += '; if (!' + ($valid) + ') break; } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n        out += '  if (!' + ($valid) + ') {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $propertyKey, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $propertyKey = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ') {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        if ($isData) {\n          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is a required property';\n              } else {\n                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';\n        if ($ownProperties) {\n          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += ') {  var err =   '; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n      } else {\n        var arr3 = $required;\n        if (arr3) {\n          var $propertyKey, i3 = -1,\n            l3 = arr3.length - 1;\n          while (i3 < l3) {\n            $propertyKey = arr3[i3 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'';\n                if (it.opts._errorDataPathProperty) {\n                  out += 'is a required property';\n                } else {\n                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/required.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_uniqueItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (($schema || $isData) && it.opts.uniqueItems !== false) {\n    if ($isData) {\n      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';\n    }\n    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';\n    var $itemType = it.schema.items && it.schema.items.type,\n      $typeIsArray = Array.isArray($itemType);\n    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {\n      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';\n    } else {\n      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';\n      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');\n      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';\n      if ($typeIsArray) {\n        out += ' if (typeof item == \\'string\\') item = \\'\"\\' + item; ';\n      }\n      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';\n    }\n    out += ' } ';\n    if ($isData) {\n      out += '  }  ';\n    }\n    out += ' if (!' + ($valid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema:  ';\n        if ($isData) {\n          out += 'validate.schema' + ($schemaPath);\n        } else {\n          out += '' + ($schema);\n        }\n        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/uniqueItems.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/dotjs/validate.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/ajv/lib/dotjs/validate.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_validate(it, $keyword, $ruleType) {\n  var out = '';\n  var $async = it.schema.$async === true,\n    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),\n    $id = it.self._getId(it.schema);\n  if (it.opts.strictKeywords) {\n    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n    if ($unknownKwd) {\n      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;\n      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);\n      else throw new Error($keywordsMsg);\n    }\n  }\n  if (it.isTop) {\n    out += ' var validate = ';\n    if ($async) {\n      it.async = true;\n      out += 'async ';\n    }\n    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';\n    if ($id && (it.opts.sourceCode || it.opts.processCode)) {\n      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';\n    }\n  }\n  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {\n    var $keyword = 'false schema';\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = 'data' + ($dataLvl || '');\n    var $valid = 'valid' + $lvl;\n    if (it.schema === false) {\n      if (it.isTop) {\n        $breakOnError = true;\n      } else {\n        out += ' var ' + ($valid) + ' = false; ';\n      }\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'boolean schema is false\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n    } else {\n      if (it.isTop) {\n        if ($async) {\n          out += ' return data; ';\n        } else {\n          out += ' validate.errors = null; return true; ';\n        }\n      } else {\n        out += ' var ' + ($valid) + ' = true; ';\n      }\n    }\n    if (it.isTop) {\n      out += ' }; return validate; ';\n    }\n    return out;\n  }\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    it.dataPathArr = [\"\"];\n    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n      var $defaultMsg = 'default is ignored in the schema root';\n      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n      else throw new Error($defaultMsg);\n    }\n    out += ' var vErrors = null; ';\n    out += ' var errors = 0;     ';\n    out += ' if (rootData === undefined) rootData = data; ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if ($id) it.baseId = it.resolve.url(it.baseId, $id);\n    if ($async && !it.async) throw new Error('async schema in sync schema');\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $errorKeyword;\n  var $typeSchema = it.schema.type,\n    $typeIsArray = Array.isArray($typeSchema);\n  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n    if ($typeIsArray) {\n      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');\n    } else if ($typeSchema != 'null') {\n      $typeSchema = [$typeSchema, 'null'];\n      $typeIsArray = true;\n    }\n  }\n  if ($typeIsArray && $typeSchema.length == 1) {\n    $typeSchema = $typeSchema[0];\n    $typeIsArray = false;\n  }\n  if (it.schema.$ref && $refKeywords) {\n    if (it.opts.extendRefs == 'fail') {\n      throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)');\n    } else if (it.opts.extendRefs !== true) {\n      $refKeywords = false;\n      it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n    }\n  }\n  if (it.schema.$comment && it.opts.$comment) {\n    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));\n  }\n  if ($typeSchema) {\n    if (it.opts.coerceTypes) {\n      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);\n    }\n    var $rulesGroup = it.RULES.types[$typeSchema];\n    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type';\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type',\n        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';\n      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';\n      if ($coerceToTypes) {\n        var $dataType = 'dataType' + $lvl,\n          $coerced = 'coerced' + $lvl;\n        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';\n        if (it.opts.coerceTypes == 'array') {\n          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';\n        }\n        out += ' if (' + ($coerced) + ' !== undefined) ; ';\n        var arr1 = $coerceToTypes;\n        if (arr1) {\n          var $type, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $type = arr1[$i += 1];\n            if ($type == 'string') {\n              out += ' else if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';\n            } else if ($type == 'number' || $type == 'integer') {\n              out += ' else if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';\n              if ($type == 'integer') {\n                out += ' && !(' + ($data) + ' % 1)';\n              }\n              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';\n            } else if ($type == 'boolean') {\n              out += ' else if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';\n            } else if ($type == 'null') {\n              out += ' else if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';\n            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {\n              out += ' else if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';\n            }\n          }\n        }\n        out += ' else {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } if (' + ($coerced) + ' !== undefined) {  ';\n        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';\n        if (!$dataLvl) {\n          out += 'if (' + ($parentData) + ' !== undefined)';\n        }\n        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';\n      } else {\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      }\n      out += ' } ';\n    }\n  }\n  if (it.schema.$ref && !$refKeywords) {\n    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';\n    if ($breakOnError) {\n      out += ' } if (errors === ';\n      if ($top) {\n        out += '0';\n      } else {\n        out += 'errs_' + ($lvl);\n      }\n      out += ') { ';\n      $closingBraces2 += '}';\n    }\n  } else {\n    var arr2 = it.RULES;\n    if (arr2) {\n      var $rulesGroup, i2 = -1,\n        l2 = arr2.length - 1;\n      while (i2 < l2) {\n        $rulesGroup = arr2[i2 += 1];\n        if ($shouldUseGroup($rulesGroup)) {\n          if ($rulesGroup.type) {\n            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';\n          }\n          if (it.opts.useDefaults) {\n            if ($rulesGroup.type == 'object' && it.schema.properties) {\n              var $schema = it.schema.properties,\n                $schemaKeys = Object.keys($schema);\n              var arr3 = $schemaKeys;\n              if (arr3) {\n                var $propertyKey, i3 = -1,\n                  l3 = arr3.length - 1;\n                while (i3 < l3) {\n                  $propertyKey = arr3[i3 += 1];\n                  var $sch = $schema[$propertyKey];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + it.util.getProperty($propertyKey);\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {\n              var arr4 = it.schema.items;\n              if (arr4) {\n                var $sch, $i = -1,\n                  l4 = arr4.length - 1;\n                while ($i < l4) {\n                  $sch = arr4[$i += 1];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + '[' + $i + ']';\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            }\n          }\n          var arr5 = $rulesGroup.rules;\n          if (arr5) {\n            var $rule, i5 = -1,\n              l5 = arr5.length - 1;\n            while (i5 < l5) {\n              $rule = arr5[i5 += 1];\n              if ($shouldUseRule($rule)) {\n                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);\n                if ($code) {\n                  out += ' ' + ($code) + ' ';\n                  if ($breakOnError) {\n                    $closingBraces1 += '}';\n                  }\n                }\n              }\n            }\n          }\n          if ($breakOnError) {\n            out += ' ' + ($closingBraces1) + ' ';\n            $closingBraces1 = '';\n          }\n          if ($rulesGroup.type) {\n            out += ' } ';\n            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {\n              out += ' else { ';\n              var $schemaPath = it.schemaPath + '.type',\n                $errSchemaPath = it.errSchemaPath + '/type';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n                if ($typeIsArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'should be ';\n                  if ($typeIsArray) {\n                    out += '' + ($typeSchema.join(\",\"));\n                  } else {\n                    out += '' + ($typeSchema);\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              out += ' } ';\n            }\n          }\n          if ($breakOnError) {\n            out += ' if (errors === ';\n            if ($top) {\n              out += '0';\n            } else {\n              out += 'errs_' + ($lvl);\n            }\n            out += ') { ';\n            $closingBraces2 += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    if ($async) {\n      out += ' if (errors === 0) return data;           ';\n      out += ' else throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; ';\n      out += ' return errors === 0;       ';\n    }\n    out += ' }; return validate;';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    var rules = $rulesGroup.rules;\n    for (var i = 0; i < rules.length; i++)\n      if ($shouldUseRule(rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));\n  }\n\n  function $ruleImplementsSomeKeyword($rule) {\n    var impl = $rule.implements;\n    for (var i = 0; i < impl.length; i++)\n      if (it.schema[impl[i]] !== undefined) return true;\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/dotjs/validate.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/keyword.js":
/*!************************************************!*\
  !*** ../../../node_modules/ajv/lib/keyword.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = __webpack_require__(/*! ./dotjs/custom */ \"../../../node_modules/ajv/lib/dotjs/custom.js\");\nvar definitionSchema = __webpack_require__(/*! ./definition_schema */ \"../../../node_modules/ajv/lib/definition_schema.js\");\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/keyword.js?");

/***/ }),

/***/ "../../../node_modules/archy/index.js":
/*!********************************************!*\
  !*** ../../../node_modules/archy/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = function archy (obj, prefix, opts) {\n    if (prefix === undefined) prefix = '';\n    if (!opts) opts = {};\n    var chr = function (s) {\n        var chars = {\n            '│' : '|',\n            '└' : '`',\n            '├' : '+',\n            '─' : '-',\n            '┬' : '-'\n        };\n        return opts.unicode === false ? chars[s] : s;\n    };\n    \n    if (typeof obj === 'string') obj = { label : obj };\n    \n    var nodes = obj.nodes || [];\n    var lines = (obj.label || '').split('\\n');\n    var splitter = '\\n' + prefix + (nodes.length ? chr('│') : ' ') + ' ';\n    \n    return prefix\n        + lines.join(splitter) + '\\n'\n        + nodes.map(function (node, ix) {\n            var last = ix === nodes.length - 1;\n            var more = node.nodes && node.nodes.length;\n            var prefix_ = prefix + (last ? ' ' : chr('│')) + ' ';\n            \n            return prefix\n                + (last ? chr('└') : chr('├')) + chr('─')\n                + (more ? chr('┬') : chr('─')) + ' '\n                + archy(node, prefix_, opts).slice(prefix.length + 2)\n            ;\n        }).join('')\n    ;\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/archy/index.js?");

/***/ }),

/***/ "../../../node_modules/atomic-sleep/index.js":
/*!***************************************************!*\
  !*** ../../../node_modules/atomic-sleep/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* global SharedArrayBuffer, Atomics */\n\nif (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {\n  const nil = new Int32Array(new SharedArrayBuffer(4))\n\n  function sleep (ms) {\n    // also filters out NaN, non-number types, including empty strings, but allows bigints\n    const valid = ms > 0 && ms < Infinity \n    if (valid === false) {\n      if (typeof ms !== 'number' && typeof ms !== 'bigint') {\n        throw TypeError('sleep: ms must be a number')\n      }\n      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')\n    }\n\n    Atomics.wait(nil, 0, 0, Number(ms))\n  }\n  module.exports = sleep\n} else {\n\n  function sleep (ms) {\n    // also filters out NaN, non-number types, including empty strings, but allows bigints\n    const valid = ms > 0 && ms < Infinity \n    if (valid === false) {\n      if (typeof ms !== 'number' && typeof ms !== 'bigint') {\n        throw TypeError('sleep: ms must be a number')\n      }\n      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')\n    }\n    const target = Date.now() + Number(ms)\n    while (target > Date.now()){}\n  }\n\n  module.exports = sleep\n\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/atomic-sleep/index.js?");

/***/ }),

/***/ "../../../node_modules/avvio/boot.js":
/*!*******************************************!*\
  !*** ../../../node_modules/avvio/boot.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastq = __webpack_require__(/*! fastq */ \"../../../node_modules/fastq/queue.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst inherits = (__webpack_require__(/*! util */ \"util\").inherits)\nconst TimeTree = __webpack_require__(/*! ./time-tree */ \"../../../node_modules/avvio/time-tree.js\")\nconst Plugin = __webpack_require__(/*! ./plugin */ \"../../../node_modules/avvio/plugin.js\")\nconst debug = __webpack_require__(/*! debug */ \"../../../node_modules/debug/src/index.js\")('avvio')\nconst kAvvio = Symbol('kAvvio')\nconst kThenifyDoNotWrap = Symbol('kThenifyDoNotWrap')\n\nfunction wrap (server, opts, instance) {\n  const expose = opts.expose || {}\n  const useKey = expose.use || 'use'\n  const afterKey = expose.after || 'after'\n  const readyKey = expose.ready || 'ready'\n  const onCloseKey = expose.onClose || 'onClose'\n  const closeKey = expose.close || 'close'\n\n  if (server[useKey]) {\n    throw new Error(useKey + '() is already defined, specify an expose option')\n  }\n\n  if (server[afterKey]) {\n    throw new Error(afterKey + '() is already defined, specify an expose option')\n  }\n\n  if (server[readyKey]) {\n    throw new Error(readyKey + '() is already defined, specify an expose option')\n  }\n\n  server[useKey] = function (fn, opts) {\n    instance.use(fn, opts)\n    return this\n  }\n\n  Object.defineProperty(server, 'then', { get: thenify.bind(instance) })\n  server[kAvvio] = true\n\n  server[afterKey] = function (func) {\n    if (typeof func !== 'function') {\n      return instance._loadRegistered()\n    }\n    instance.after(encapsulateThreeParam(func, this))\n    return this\n  }\n\n  server[readyKey] = function (func) {\n    if (func && typeof func !== 'function') {\n      throw new Error('not a function')\n    }\n    return instance.ready(func ? encapsulateThreeParam(func, this) : undefined)\n  }\n\n  server[onCloseKey] = function (func) {\n    if (typeof func !== 'function') {\n      throw new Error('not a function')\n    }\n    instance.onClose(encapsulateTwoParam(func, this))\n    return this\n  }\n\n  server[closeKey] = function (func) {\n    if (func && typeof func !== 'function') {\n      throw new Error('not a function')\n    }\n\n    if (func) {\n      instance.close(encapsulateThreeParam(func, this))\n      return this\n    }\n\n    // this is a Promise\n    return instance.close()\n  }\n}\n\nfunction Boot (server, opts, done) {\n  if (typeof server === 'function' && arguments.length === 1) {\n    done = server\n    opts = {}\n    server = null\n  }\n\n  if (typeof opts === 'function') {\n    done = opts\n    opts = {}\n  }\n\n  opts = opts || {}\n\n  if (!(this instanceof Boot)) {\n    const instance = new Boot(server, opts, done)\n\n    if (server) {\n      wrap(server, opts, instance)\n    }\n\n    return instance\n  }\n\n  if (opts.autostart !== false) {\n    opts.autostart = true\n  }\n\n  server = server || this\n\n  this._timeout = Number(opts.timeout) || 0\n  this._server = server\n  this._current = []\n  this._error = null\n  this._isOnCloseHandlerKey = Symbol('isOnCloseHandler')\n  this._lastUsed = null\n\n  this.setMaxListeners(0)\n\n  if (done) {\n    this.once('start', done)\n  }\n\n  this.started = false\n  this.booted = false\n  this.pluginTree = new TimeTree()\n\n  this._readyQ = fastq(this, callWithCbOrNextTick, 1)\n  this._readyQ.pause()\n  this._readyQ.drain = () => {\n    this.emit('start')\n    // nooping this, we want to emit start only once\n    this._readyQ.drain = noop\n  }\n\n  this._closeQ = fastq(this, closeWithCbOrNextTick, 1)\n  this._closeQ.pause()\n  this._closeQ.drain = () => {\n    this.emit('close')\n    // nooping this, we want to emit start only once\n    this._closeQ.drain = noop\n  }\n\n  this._doStart = null\n  this._root = new Plugin(this, root.bind(this), opts, false, 0)\n  this._root.once('start', (serverName, funcName, time) => {\n    const nodeId = this.pluginTree.start(null, funcName, time)\n    this._root.once('loaded', (serverName, funcName, time) => {\n      this.pluginTree.stop(nodeId, time)\n    })\n  })\n\n  Plugin.loadPlugin.call(this, this._root, (err) => {\n    debug('root plugin ready')\n    try {\n      this.emit('preReady')\n      this._root = null\n    } catch (prereadyError) {\n      err = err || this._error || prereadyError\n    }\n\n    if (err) {\n      this._error = err\n      if (this._readyQ.length() === 0) {\n        throw err\n      }\n    } else {\n      this.booted = true\n    }\n    this._readyQ.resume()\n  })\n}\n\nfunction root (s, opts, done) {\n  this._doStart = done\n  if (opts.autostart) {\n    this.start()\n  }\n}\n\ninherits(Boot, EE)\n\nBoot.prototype.start = function () {\n  this.started = true\n\n  // we need to wait any call to use() to happen\n  process.nextTick(this._doStart)\n  return this\n}\n\n// allows to override the instance of a server, given a plugin\nBoot.prototype.override = function (server, func, opts) {\n  return server\n}\n\nfunction assertPlugin (plugin) {\n  // Faux modules are modules built with TypeScript\n  // or Babel that they export a .default property.\n  if (plugin && typeof plugin === 'object' && typeof plugin.default === 'function') {\n    plugin = plugin.default\n  }\n  if (!(plugin && (typeof plugin === 'function' || typeof plugin.then === 'function'))) {\n    throw new Error('plugin must be a function or a promise')\n  }\n  return plugin\n}\n\nBoot.prototype[kAvvio] = true\n\n// load a plugin\nBoot.prototype.use = function (plugin, opts) {\n  this._lastUsed = this._addPlugin(plugin, opts, false)\n  return this\n}\n\nBoot.prototype._loadRegistered = function () {\n  const plugin = this._current[0]\n  const weNeedToStart = !this.started && !this.booted\n\n  // if the root plugin is not loaded, let's resume that\n  // so one can use after() befor calling ready\n  if (weNeedToStart) {\n    process.nextTick(() => this._root.q.resume())\n  }\n\n  if (!plugin) {\n    return Promise.resolve()\n  }\n\n  return plugin.loadedSoFar()\n}\n\nObject.defineProperty(Boot.prototype, 'then', { get: thenify })\n\nBoot.prototype._addPlugin = function (plugin, opts, isAfter) {\n  plugin = assertPlugin(plugin)\n  opts = opts || {}\n\n  if (this.booted) {\n    throw new Error('root plugin has already booted')\n  }\n\n  // we always add plugins to load at the current element\n  const current = this._current[0]\n\n  const obj = new Plugin(this, plugin, opts, isAfter)\n  obj.once('start', (serverName, funcName, time) => {\n    const nodeId = this.pluginTree.start(current.name, funcName, time)\n    obj.once('loaded', (serverName, funcName, time) => {\n      this.pluginTree.stop(nodeId, time)\n    })\n  })\n\n  if (current.loaded) {\n    throw new Error(`Impossible to load \"${obj.name}\" plugin because the parent \"${current.name}\" was already loaded`)\n  }\n\n  // we add the plugin to be loaded at the end of the current queue\n  current.enqueue(obj, (err) => {\n    if (err) {\n      this._error = err\n    }\n  })\n\n  return obj\n}\n\nBoot.prototype.after = function (func) {\n  if (!func) {\n    return this._loadRegistered()\n  }\n\n  this._addPlugin(_after.bind(this), {}, true)\n\n  function _after (s, opts, done) {\n    callWithCbOrNextTick.call(this, func, done)\n  }\n\n  return this\n}\n\nBoot.prototype.onClose = function (func) {\n  // this is used to distinguish between onClose and close handlers\n  // because they share the same queue but must be called with different signatures\n\n  if (typeof func !== 'function') {\n    throw new Error('not a function')\n  }\n\n  func[this._isOnCloseHandlerKey] = true\n  this._closeQ.unshift(func, callback.bind(this))\n\n  function callback (err) {\n    if (err) this._error = err\n  }\n\n  return this\n}\n\nBoot.prototype.close = function (func) {\n  let promise\n\n  if (func) {\n    if (typeof func !== 'function') {\n      throw new Error('not a function')\n    }\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      func = function (err) {\n        if (err) {\n          return reject(err)\n        }\n        resolve()\n      }\n    })\n  }\n\n  this.ready(() => {\n    this._error = null\n    this._closeQ.push(func)\n    process.nextTick(this._closeQ.resume.bind(this._closeQ))\n  })\n\n  return promise\n}\n\nBoot.prototype.ready = function (func) {\n  if (func) {\n    if (typeof func !== 'function') {\n      throw new Error('not a function')\n    }\n    this._readyQ.push(func)\n    this.start()\n    return\n  }\n\n  return new Promise((resolve, reject) => {\n    this._readyQ.push(readyPromiseCB)\n    this.start()\n\n    /**\n     * The `encapsulateThreeParam` let callback function\n     * bind to the right server instance.\n     * In promises we need to track the last server\n     * instance loaded, the first one in the _current queue.\n     */\n    const relativeContext = this._current[0].server\n\n    function readyPromiseCB (err, context, done) {\n      // the context is always binded to the root server\n      if (err) {\n        reject(err)\n      } else {\n        resolve(relativeContext)\n      }\n      process.nextTick(done)\n    }\n  })\n}\n\nBoot.prototype.prettyPrint = function () {\n  return this.pluginTree.prittyPrint()\n}\n\nBoot.prototype.toJSON = function () {\n  return this.pluginTree.toJSON()\n}\n\nfunction noop () { }\n\nfunction thenify () {\n  // If the instance is ready, then there is\n  // nothing to await. This is true during\n  // await server.ready() as ready() resolves\n  // with the server, end we will end up here\n  // because of automatic promise chaining.\n  if (this.booted) {\n    debug('thenify returning null because we are already booted')\n    return\n  }\n\n  // Calling resolve(this._server) would fetch the then\n  // property on the server, which will lead it here.\n  // If we do not break the recursion, we will loop\n  // forever.\n  if (this[kThenifyDoNotWrap]) {\n    this[kThenifyDoNotWrap] = false\n    return\n  }\n\n  debug('thenify')\n  return (resolve, reject) => {\n    const p = this._loadRegistered()\n    return p.then(() => {\n      this[kThenifyDoNotWrap] = true\n      return resolve(this._server)\n    }, reject)\n  }\n}\n\nfunction callWithCbOrNextTick (func, cb, context) {\n  context = this._server\n  const err = this._error\n  let res\n\n  // with this the error will appear just in the next after/ready callback\n  this._error = null\n  if (func.length === 0) {\n    this._error = err\n    res = func()\n    if (res && !res[kAvvio] && typeof res.then === 'function') {\n      res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e))\n    } else {\n      process.nextTick(cb)\n    }\n  } else if (func.length === 1) {\n    res = func(err)\n    if (res && !res[kAvvio] && typeof res.then === 'function') {\n      res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e))\n    } else {\n      process.nextTick(cb)\n    }\n  } else {\n    if (this._timeout === 0) {\n      if (func.length === 2) {\n        func(err, cb)\n      } else {\n        func(err, context, cb)\n      }\n    } else {\n      timeoutCall.call(this, func, err, context, cb)\n    }\n  }\n}\n\nfunction timeoutCall (func, rootErr, context, cb) {\n  const name = func.name\n  debug('setting up ready timeout', name, this._timeout)\n  let timer = setTimeout(() => {\n    debug('timed out', name)\n    timer = null\n    const toutErr = new Error(`ERR_AVVIO_READY_TIMEOUT: plugin did not start in time: ${name}. You may have forgotten to call 'done' function or to resolve a Promise`)\n    toutErr.code = 'ERR_AVVIO_READY_TIMEOUT'\n    toutErr.fn = func\n    this._error = toutErr\n    cb(toutErr)\n  }, this._timeout)\n\n  if (func.length === 2) {\n    func(rootErr, timeoutCb.bind(this))\n  } else {\n    func(rootErr, context, timeoutCb.bind(this))\n  }\n\n  function timeoutCb (err) {\n    if (timer) {\n      clearTimeout(timer)\n      this._error = err\n      cb(this._error)\n    } else {\n      // timeout has been triggered\n      // can not call cb twice\n    }\n  }\n}\n\nfunction closeWithCbOrNextTick (func, cb, context) {\n  context = this._server\n  const isOnCloseHandler = func[this._isOnCloseHandlerKey]\n  if (func.length === 0 || func.length === 1) {\n    let promise\n    if (isOnCloseHandler) {\n      promise = func(context)\n    } else {\n      promise = func(this._error)\n    }\n    if (promise && typeof promise.then === 'function') {\n      debug('resolving close/onClose promise')\n      promise.then(\n        () => process.nextTick(cb),\n        (e) => process.nextTick(cb, e))\n    } else {\n      process.nextTick(cb)\n    }\n  } else if (func.length === 2) {\n    if (isOnCloseHandler) {\n      func(context, cb)\n    } else {\n      func(this._error, cb)\n    }\n  } else {\n    if (isOnCloseHandler) {\n      func(context, cb)\n    } else {\n      func(this._error, context, cb)\n    }\n  }\n}\n\nfunction encapsulateTwoParam (func, that) {\n  return _encapsulateTwoParam.bind(that)\n  function _encapsulateTwoParam (context, cb) {\n    let res\n    if (func.length === 0) {\n      res = func()\n      if (res && res.then) {\n        res.then(function () {\n          process.nextTick(cb)\n        }, cb)\n      } else {\n        process.nextTick(cb)\n      }\n    } else if (func.length === 1) {\n      res = func(this)\n\n      if (res && res.then) {\n        res.then(function () {\n          process.nextTick(cb)\n        }, cb)\n      } else {\n        process.nextTick(cb)\n      }\n    } else {\n      func(this, cb)\n    }\n  }\n}\n\nfunction encapsulateThreeParam (func, that) {\n  return _encapsulateThreeParam.bind(that)\n  function _encapsulateThreeParam (err, cb) {\n    let res\n    if (!func) {\n      process.nextTick(cb)\n    } else if (func.length === 0) {\n      res = func()\n      if (res && res.then) {\n        res.then(function () {\n          process.nextTick(cb, err)\n        }, cb)\n      } else {\n        process.nextTick(cb, err)\n      }\n    } else if (func.length === 1) {\n      res = func(err)\n      if (res && res.then) {\n        res.then(function () {\n          process.nextTick(cb)\n        }, cb)\n      } else {\n        process.nextTick(cb)\n      }\n    } else if (func.length === 2) {\n      func(err, cb)\n    } else {\n      func(err, this, cb)\n    }\n  }\n}\n\nmodule.exports = Boot\nmodule.exports.express = function (app) {\n  return Boot(app, {\n    expose: {\n      use: 'load'\n    }\n  })\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/avvio/boot.js?");

/***/ }),

/***/ "../../../node_modules/avvio/plugin.js":
/*!*********************************************!*\
  !*** ../../../node_modules/avvio/plugin.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"../../../node_modules/queue-microtask/index.js\")\nconst fastq = __webpack_require__(/*! fastq */ \"../../../node_modules/fastq/queue.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst inherits = (__webpack_require__(/*! util */ \"util\").inherits)\nconst debug = __webpack_require__(/*! debug */ \"../../../node_modules/debug/src/index.js\")('avvio')\nconst CODE_PLUGIN_TIMEOUT = 'ERR_AVVIO_PLUGIN_TIMEOUT'\n\nfunction getName (func) {\n  // let's see if this is a file, and in that case use that\n  // this is common for plugins\n  const cache = __webpack_require__.c\n  const keys = Object.keys(cache)\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i < keys.length; i++) {\n    if (cache[keys[i]].exports === func) {\n      return keys[i]\n    }\n  }\n\n  // if not maybe it's a named function, so use that\n  if (func.name) {\n    return func.name\n  }\n\n  // takes the first two lines of the function if nothing else works\n  return func.toString().split('\\n').slice(0, 2).map(s => s.trim()).join(' -- ')\n}\n\nfunction promise () {\n  const obj = {}\n\n  obj.promise = new Promise((resolve, reject) => {\n    obj.resolve = resolve\n    obj.reject = reject\n  })\n\n  return obj\n}\n\nfunction Plugin (parent, func, optsOrFunc, isAfter, timeout) {\n  this.started = false\n  this.func = func\n  this.opts = optsOrFunc\n  this.onFinish = null\n  this.parent = parent\n  this.timeout = timeout === undefined ? parent._timeout : timeout\n  this.name = getName(func)\n  this.isAfter = isAfter\n  this.q = fastq(parent, loadPlugin, 1)\n  this.q.pause()\n  this._error = null\n  this.loaded = false\n  this._promise = null\n\n  // always start the queue in the next tick\n  // because we try to attach subsequent call to use()\n  // to the right plugin. we need to defer them,\n  // or they will end up at the top of _current\n}\n\ninherits(Plugin, EE)\n\nPlugin.prototype.exec = function (server, cb) {\n  const func = this.func\n  let completed = false\n  const name = this.name\n\n  if (this.parent._error && !this.isAfter) {\n    debug('skipping loading of plugin as parent errored and it is not an after', name)\n    process.nextTick(cb)\n    return\n  }\n\n  if (!this.isAfter) {\n    // Skip override for after\n    try {\n      this.server = this.parent.override(server, func, this.opts)\n    } catch (err) {\n      debug('override errored', name)\n      return cb(err)\n    }\n  } else {\n    this.server = server\n  }\n\n  this.opts = typeof this.opts === 'function' ? this.opts(this.server) : this.opts\n\n  debug('exec', name)\n\n  let timer\n\n  const done = (err) => {\n    if (completed) {\n      debug('loading complete', name)\n      return\n    }\n\n    this._error = err\n\n    if (err) {\n      debug('exec errored', name)\n    } else {\n      debug('exec completed', name)\n    }\n\n    completed = true\n\n    if (timer) {\n      clearTimeout(timer)\n    }\n\n    cb(err)\n  }\n\n  if (this.timeout > 0) {\n    debug('setting up timeout', name, this.timeout)\n    timer = setTimeout(function () {\n      debug('timed out', name)\n      timer = null\n      const err = new Error(`${CODE_PLUGIN_TIMEOUT}: plugin did not start in time: ${name}. You may have forgotten to call 'done' function or to resolve a Promise`)\n      err.code = CODE_PLUGIN_TIMEOUT\n      err.fn = func\n      done(err)\n    }, this.timeout)\n  }\n\n  this.started = true\n  this.emit('start', this.server ? this.server.name : null, this.name, Date.now())\n  const promise = func(this.server, this.opts, done)\n\n  if (promise && typeof promise.then === 'function') {\n    debug('exec: resolving promise', name)\n\n    promise.then(\n      () => process.nextTick(done),\n      (e) => process.nextTick(done, e))\n  }\n}\n\nPlugin.prototype.loadedSoFar = function () {\n  if (this.loaded) {\n    return Promise.resolve()\n  }\n\n  const setup = () => {\n    this.server.after((err, cb) => {\n      this._error = err\n      this.q.pause()\n\n      if (err) {\n        debug('rejecting promise', this.name, err)\n        this._promise.reject(err)\n      } else {\n        debug('resolving promise', this.name)\n        this._promise.resolve()\n      }\n      this._promise = null\n\n      process.nextTick(cb, err)\n    })\n    this.q.resume()\n  }\n\n  let res\n\n  if (!this._promise) {\n    this._promise = promise()\n    res = this._promise.promise\n\n    if (!this.server) {\n      this.on('start', setup)\n    } else {\n      setup()\n    }\n  } else {\n    res = Promise.resolve()\n  }\n\n  return res\n}\n\nPlugin.prototype.enqueue = function (obj, cb) {\n  debug('enqueue', this.name, obj.name)\n  this.emit('enqueue', this.server ? this.server.name : null, this.name, Date.now())\n  this.q.push(obj, cb)\n}\n\nPlugin.prototype.finish = function (err, cb) {\n  debug('finish', this.name, err)\n  const done = () => {\n    if (this.loaded) {\n      return\n    }\n\n    debug('loaded', this.name)\n    this.emit('loaded', this.server ? this.server.name : null, this.name, Date.now())\n    this.loaded = true\n\n    cb(err)\n  }\n\n  if (err) {\n    if (this._promise) {\n      this._promise.reject(err)\n      this._promise = null\n    }\n    done()\n    return\n  }\n\n  const check = () => {\n    debug('check', this.name, this.q.length(), this.q.running(), this._promise)\n    if (this.q.length() === 0 && this.q.running() === 0) {\n      if (this._promise) {\n        const wrap = () => {\n          debug('wrap')\n          queueMicrotask(check)\n        }\n        this._promise.resolve()\n        this._promise.promise.then(wrap, wrap)\n        this._promise = null\n      } else {\n        done()\n      }\n    } else {\n      debug('delayed', this.name)\n      // finish when the queue of nested plugins to load is empty\n      this.q.drain = () => {\n        debug('drain', this.name)\n        this.q.drain = noop\n\n        // we defer the check, as a safety net for things\n        // that might be scheduled in the loading callback\n        queueMicrotask(check)\n      }\n    }\n  }\n\n  queueMicrotask(check)\n\n  // we start loading the dependents plugins only once\n  // the current level is finished\n  this.q.resume()\n}\n\n// loads a plugin\nfunction loadPlugin (toLoad, cb) {\n  if (typeof toLoad.func.then === 'function') {\n    toLoad.func.then((fn) => {\n      if (typeof fn.default === 'function') {\n        fn = fn.default\n      }\n      toLoad.func = fn\n      loadPlugin.call(this, toLoad, cb)\n    }, cb)\n    return\n  }\n\n  const last = this._current[0]\n\n  // place the plugin at the top of _current\n  this._current.unshift(toLoad)\n\n  toLoad.exec((last && last.server) || this._server, (err) => {\n    toLoad.finish(err, (err) => {\n      this._current.shift()\n      cb(err)\n    })\n  })\n}\n\nfunction noop () {}\n\nmodule.exports = Plugin\nmodule.exports.loadPlugin = loadPlugin\n\n\n//# sourceURL=webpack://qui/../../../node_modules/avvio/plugin.js?");

/***/ }),

/***/ "../../../node_modules/avvio/time-tree.js":
/*!************************************************!*\
  !*** ../../../node_modules/avvio/time-tree.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst archy = __webpack_require__(/*! archy */ \"../../../node_modules/archy/index.js\")\n\nfunction TimeTree () {\n  this.root = null\n  this.tableId = new Map()\n  this.tableLabel = new Map()\n}\n\nTimeTree.prototype.trackNode = function (node) {\n  this.tableId.set(node.id, node)\n  if (this.tableLabel.has(node.label)) {\n    this.tableLabel.get(node.label).push(node)\n  } else {\n    this.tableLabel.set(node.label, [node])\n  }\n}\n\nTimeTree.prototype.untrackNode = function (node) {\n  this.tableId.delete(node.id)\n\n  const labelNode = this.tableLabel.get(node.label)\n  if (labelNode.id) {\n    this.tableLabel.delete(node.label)\n    return\n  }\n  labelNode.pop()\n\n  if (labelNode.length === 0) {\n    this.tableLabel.delete(node.label)\n  }\n}\n\nTimeTree.prototype.getParent = function (parent) {\n  if (parent === null) {\n    return this.root\n  }\n\n  const parentNode = this.tableLabel.get(parent)\n  if (parentNode.id) {\n    return parentNode\n  }\n  return parentNode[parentNode.length - 1]\n}\n\nTimeTree.prototype.getNode = function (nodeId) {\n  return this.tableId.get(nodeId)\n}\n\nTimeTree.prototype.add = function (parent, child, start) {\n  const isRoot = parent === null\n  if (isRoot) {\n    this.root = {\n      id: 'root',\n      label: child,\n      start,\n      nodes: []\n    }\n    this.trackNode(this.root)\n    return this.root.id\n  }\n\n  const parentNode = this.getParent(parent)\n  const nodeId = `${child}-${Math.random()}`\n  const childNode = {\n    id: nodeId,\n    parent,\n    start,\n    label: child,\n    nodes: []\n  }\n  parentNode.nodes.push(childNode)\n  this.trackNode(childNode)\n  return nodeId\n}\n\nTimeTree.prototype.start = function (parent, child, start) {\n  return this.add(parent, child, start || Date.now())\n}\n\nTimeTree.prototype.stop = function (nodeId, stop) {\n  const node = this.getNode(nodeId)\n  if (node) {\n    node.stop = stop || Date.now()\n    node.diff = (node.stop - node.start) || 0\n    this.untrackNode(node)\n  }\n}\n\nTimeTree.prototype.toJSON = function () {\n  return Object.assign({}, this.root)\n}\n\nTimeTree.prototype.prittyPrint = function () {\n  const decorateText = (node) => {\n    node.label = `${node.label} ${node.diff} ms`\n    if (node.nodes.length > 0) {\n      node.nodes = node.nodes.map(_ => decorateText(_))\n    }\n    return node\n  }\n  const out = decorateText(this.toJSON())\n  return archy(out)\n}\n\nmodule.exports = TimeTree\n\n\n//# sourceURL=webpack://qui/../../../node_modules/avvio/time-tree.js?");

/***/ }),

/***/ "../../../node_modules/balanced-match/index.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/balanced-match/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/balanced-match/index.js?");

/***/ }),

/***/ "../../../node_modules/brace-expansion/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/brace-expansion/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"../../../node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"../../../node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack://qui/../../../node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "../../../node_modules/concat-map/index.js":
/*!*************************************************!*\
  !*** ../../../node_modules/concat-map/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/concat-map/index.js?");

/***/ }),

/***/ "../../../node_modules/content-disposition/index.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/content-disposition/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * content-disposition\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = contentDisposition\nmodule.exports.parse = parse\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar basename = (__webpack_require__(/*! path */ \"path\").basename)\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"../../../node_modules/content-disposition/node_modules/safe-buffer/index.js\").Buffer)\n\n/**\n * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including \"%\")\n * @private\n */\n\nvar ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match percent encoding escape.\n * @private\n */\n\nvar HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/\nvar HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g\n\n/**\n * RegExp to match non-latin1 characters.\n * @private\n */\n\nvar NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n * @private\n */\n\nvar QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n * @private\n */\n\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp for various RFC 2616 grammar\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * HT            = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n * @private\n */\n\nvar PARAM_REGEXP = /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/\n\n/**\n * RegExp for various RFC 5987 grammar\n *\n * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n * mime-charset  = 1*mime-charsetc\n * mime-charsetc = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n *               / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n *               / \"{\" / \"}\" / \"~\"\n * language      = ( 2*3ALPHA [ extlang ] )\n *               / 4ALPHA\n *               / 5*8ALPHA\n * extlang       = *3( \"-\" 3ALPHA )\n * value-chars   = *( pct-encoded / attr-char )\n * pct-encoded   = \"%\" HEXDIG HEXDIG\n * attr-char     = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n *               / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n * @private\n */\n\nvar EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/\n\n/**\n * RegExp for various RFC 6266 grammar\n *\n * disposition-type = \"inline\" | \"attachment\" | disp-ext-type\n * disp-ext-type    = token\n * disposition-parm = filename-parm | disp-ext-parm\n * filename-parm    = \"filename\" \"=\" value\n *                  | \"filename*\" \"=\" ext-value\n * disp-ext-parm    = token \"=\" value\n *                  | ext-token \"=\" ext-value\n * ext-token        = <the characters in token, followed by \"*\">\n * @private\n */\n\nvar DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/ // eslint-disable-line no-control-regex\n\n/**\n * Create an attachment Content-Disposition header.\n *\n * @param {string} [filename]\n * @param {object} [options]\n * @param {string} [options.type=attachment]\n * @param {string|boolean} [options.fallback=true]\n * @return {string}\n * @public\n */\n\nfunction contentDisposition (filename, options) {\n  var opts = options || {}\n\n  // get type\n  var type = opts.type || 'attachment'\n\n  // get parameters\n  var params = createparams(filename, opts.fallback)\n\n  // format into string\n  return format(new ContentDisposition(type, params))\n}\n\n/**\n * Create parameters object from filename and fallback.\n *\n * @param {string} [filename]\n * @param {string|boolean} [fallback=true]\n * @return {object}\n * @private\n */\n\nfunction createparams (filename, fallback) {\n  if (filename === undefined) {\n    return\n  }\n\n  var params = {}\n\n  if (typeof filename !== 'string') {\n    throw new TypeError('filename must be a string')\n  }\n\n  // fallback defaults to true\n  if (fallback === undefined) {\n    fallback = true\n  }\n\n  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {\n    throw new TypeError('fallback must be a string or boolean')\n  }\n\n  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {\n    throw new TypeError('fallback must be ISO-8859-1 string')\n  }\n\n  // restrict to file base name\n  var name = basename(filename)\n\n  // determine if name is suitable for quoted string\n  var isQuotedString = TEXT_REGEXP.test(name)\n\n  // generate fallback name\n  var fallbackName = typeof fallback !== 'string'\n    ? fallback && getlatin1(name)\n    : basename(fallback)\n  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name\n\n  // set extended filename parameter\n  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {\n    params['filename*'] = name\n  }\n\n  // set filename parameter\n  if (isQuotedString || hasFallback) {\n    params.filename = hasFallback\n      ? fallbackName\n      : name\n  }\n\n  return params\n}\n\n/**\n * Format object to Content-Disposition header.\n *\n * @param {object} obj\n * @param {string} obj.type\n * @param {object} [obj.parameters]\n * @return {string}\n * @private\n */\n\nfunction format (obj) {\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  // start with normalized type\n  var string = String(type).toLowerCase()\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      var val = param.substr(-1) === '*'\n        ? ustring(parameters[param])\n        : qstring(parameters[param])\n\n      string += '; ' + param + '=' + val\n    }\n  }\n\n  return string\n}\n\n/**\n * Decode a RFC 5987 field value (gracefully).\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction decodefield (str) {\n  var match = EXT_VALUE_REGEXP.exec(str)\n\n  if (!match) {\n    throw new TypeError('invalid extended field value')\n  }\n\n  var charset = match[1].toLowerCase()\n  var encoded = match[2]\n  var value\n\n  // to binary string\n  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)\n\n  switch (charset) {\n    case 'iso-8859-1':\n      value = getlatin1(binary)\n      break\n    case 'utf-8':\n      value = Buffer.from(binary, 'binary').toString('utf8')\n      break\n    default:\n      throw new TypeError('unsupported charset in extended field')\n  }\n\n  return value\n}\n\n/**\n * Get ISO-8859-1 version of string.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction getlatin1 (val) {\n  // simple Unicode -> ISO-8859-1 transformation\n  return String(val).replace(NON_LATIN1_REGEXP, '?')\n}\n\n/**\n * Parse Content-Disposition header string.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string || typeof string !== 'string') {\n    throw new TypeError('argument string is required')\n  }\n\n  var match = DISPOSITION_TYPE_REGEXP.exec(string)\n\n  if (!match) {\n    throw new TypeError('invalid type format')\n  }\n\n  // normalize type\n  var index = match[0].length\n  var type = match[1].toLowerCase()\n\n  var key\n  var names = []\n  var params = {}\n  var value\n\n  // calculate index to start at\n  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'\n    ? index - 1\n    : index\n\n  // match parameters\n  while ((match = PARAM_REGEXP.exec(string))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (names.indexOf(key) !== -1) {\n      throw new TypeError('invalid duplicate parameter')\n    }\n\n    names.push(key)\n\n    if (key.indexOf('*') + 1 === key.length) {\n      // decode extended value\n      key = key.slice(0, -1)\n      value = decodefield(value)\n\n      // overwrite existing value\n      params[key] = value\n      continue\n    }\n\n    if (typeof params[key] === 'string') {\n      continue\n    }\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(QESC_REGEXP, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return new ContentDisposition(type, params)\n}\n\n/**\n * Percent decode a single character.\n *\n * @param {string} str\n * @param {string} hex\n * @return {string}\n * @private\n */\n\nfunction pdecode (str, hex) {\n  return String.fromCharCode(parseInt(hex, 16))\n}\n\n/**\n * Percent encode a single character.\n *\n * @param {string} char\n * @return {string}\n * @private\n */\n\nfunction pencode (char) {\n  return '%' + String(char)\n    .charCodeAt(0)\n    .toString(16)\n    .toUpperCase()\n}\n\n/**\n * Quote a string for HTTP.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Encode a Unicode string for HTTP (RFC 5987).\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction ustring (val) {\n  var str = String(val)\n\n  // percent encode as UTF-8\n  var encoded = encodeURIComponent(str)\n    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)\n\n  return 'UTF-8\\'\\'' + encoded\n}\n\n/**\n * Class for parsed Content-Disposition header for v8 optimization\n *\n * @public\n * @param {string} type\n * @param {object} parameters\n * @constructor\n */\n\nfunction ContentDisposition (type, parameters) {\n  this.type = type\n  this.parameters = parameters\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/content-disposition/index.js?");

/***/ }),

/***/ "../../../node_modules/content-disposition/node_modules/safe-buffer/index.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/content-disposition/node_modules/safe-buffer/index.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/content-disposition/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "../../../node_modules/cookie/index.js":
/*!*********************************************!*\
  !*** ../../../node_modules/cookie/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('=');\n\n    // skip things that don't look like key=value\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim()\n    var val = pair.substr(++eq_idx, pair.length).trim();\n\n    // quoted values\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    }\n\n    // only assign once\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/cookie/index.js?");

/***/ }),

/***/ "../../../node_modules/debug/src/browser.js":
/*!**************************************************!*\
  !*** ../../../node_modules/debug/src/browser.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../../../node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/debug/src/browser.js?");

/***/ }),

/***/ "../../../node_modules/debug/src/common.js":
/*!*************************************************!*\
  !*** ../../../node_modules/debug/src/common.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"../../../node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/debug/src/common.js?");

/***/ }),

/***/ "../../../node_modules/debug/src/index.js":
/*!************************************************!*\
  !*** ../../../node_modules/debug/src/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"../../../node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"../../../node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/debug/src/index.js?");

/***/ }),

/***/ "../../../node_modules/debug/src/node.js":
/*!***********************************************!*\
  !*** ../../../node_modules/debug/src/node.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"../../../node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../../../node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/debug/src/node.js?");

/***/ }),

/***/ "../../../node_modules/deepmerge/dist/cjs.js":
/*!***************************************************!*\
  !*** ../../../node_modules/deepmerge/dist/cjs.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/deepmerge/dist/cjs.js?");

/***/ }),

/***/ "../../../node_modules/depd/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/depd/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * depd\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar callSiteToString = (__webpack_require__(/*! ./lib/compat */ \"../../../node_modules/depd/lib/compat/index.js\").callSiteToString)\nvar eventListenerCount = (__webpack_require__(/*! ./lib/compat */ \"../../../node_modules/depd/lib/compat/index.js\").eventListenerCount)\nvar relative = (__webpack_require__(/*! path */ \"path\").relative)\n\n/**\n * Module exports.\n */\n\nmodule.exports = depd\n\n/**\n * Get the path to base files on.\n */\n\nvar basePath = process.cwd()\n\n/**\n * Determine if namespace is contained in the string.\n */\n\nfunction containsNamespace (str, namespace) {\n  var vals = str.split(/[ ,]+/)\n  var ns = String(namespace).toLowerCase()\n\n  for (var i = 0; i < vals.length; i++) {\n    var val = vals[i]\n\n    // namespace contained\n    if (val && (val === '*' || val.toLowerCase() === ns)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Convert a data descriptor to accessor descriptor.\n */\n\nfunction convertDataDescriptorToAccessor (obj, prop, message) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n  var value = descriptor.value\n\n  descriptor.get = function getter () { return value }\n\n  if (descriptor.writable) {\n    descriptor.set = function setter (val) { return (value = val) }\n  }\n\n  delete descriptor.value\n  delete descriptor.writable\n\n  Object.defineProperty(obj, prop, descriptor)\n\n  return descriptor\n}\n\n/**\n * Create arguments string to keep arity.\n */\n\nfunction createArgumentsString (arity) {\n  var str = ''\n\n  for (var i = 0; i < arity; i++) {\n    str += ', arg' + i\n  }\n\n  return str.substr(2)\n}\n\n/**\n * Create stack string from stack.\n */\n\nfunction createStackString (stack) {\n  var str = this.name + ': ' + this.namespace\n\n  if (this.message) {\n    str += ' deprecated ' + this.message\n  }\n\n  for (var i = 0; i < stack.length; i++) {\n    str += '\\n    at ' + callSiteToString(stack[i])\n  }\n\n  return str\n}\n\n/**\n * Create deprecate for namespace in caller.\n */\n\nfunction depd (namespace) {\n  if (!namespace) {\n    throw new TypeError('argument namespace is required')\n  }\n\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n  var file = site[0]\n\n  function deprecate (message) {\n    // call to self as log\n    log.call(deprecate, message)\n  }\n\n  deprecate._file = file\n  deprecate._ignored = isignored(namespace)\n  deprecate._namespace = namespace\n  deprecate._traced = istraced(namespace)\n  deprecate._warned = Object.create(null)\n\n  deprecate.function = wrapfunction\n  deprecate.property = wrapproperty\n\n  return deprecate\n}\n\n/**\n * Determine if namespace is ignored.\n */\n\nfunction isignored (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.noDeprecation) {\n    // --no-deprecation support\n    return true\n  }\n\n  var str = process.env.NO_DEPRECATION || ''\n\n  // namespace ignored\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Determine if namespace is traced.\n */\n\nfunction istraced (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.traceDeprecation) {\n    // --trace-deprecation support\n    return true\n  }\n\n  var str = process.env.TRACE_DEPRECATION || ''\n\n  // namespace traced\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Display deprecation message.\n */\n\nfunction log (message, site) {\n  var haslisteners = eventListenerCount(process, 'deprecation') !== 0\n\n  // abort early if no destination\n  if (!haslisteners && this._ignored) {\n    return\n  }\n\n  var caller\n  var callFile\n  var callSite\n  var depSite\n  var i = 0\n  var seen = false\n  var stack = getStack()\n  var file = this._file\n\n  if (site) {\n    // provided site\n    depSite = site\n    callSite = callSiteLocation(stack[1])\n    callSite.name = depSite.name\n    file = callSite[0]\n  } else {\n    // get call site\n    i = 2\n    depSite = callSiteLocation(stack[i])\n    callSite = depSite\n  }\n\n  // get caller of deprecated thing in relation to file\n  for (; i < stack.length; i++) {\n    caller = callSiteLocation(stack[i])\n    callFile = caller[0]\n\n    if (callFile === file) {\n      seen = true\n    } else if (callFile === this._file) {\n      file = this._file\n    } else if (seen) {\n      break\n    }\n  }\n\n  var key = caller\n    ? depSite.join(':') + '__' + caller.join(':')\n    : undefined\n\n  if (key !== undefined && key in this._warned) {\n    // already warned\n    return\n  }\n\n  this._warned[key] = true\n\n  // generate automatic message from call site\n  var msg = message\n  if (!msg) {\n    msg = callSite === depSite || !callSite.name\n      ? defaultMessage(depSite)\n      : defaultMessage(callSite)\n  }\n\n  // emit deprecation if listeners exist\n  if (haslisteners) {\n    var err = DeprecationError(this._namespace, msg, stack.slice(i))\n    process.emit('deprecation', err)\n    return\n  }\n\n  // format and write message\n  var format = process.stderr.isTTY\n    ? formatColor\n    : formatPlain\n  var output = format.call(this, msg, caller, stack.slice(i))\n  process.stderr.write(output + '\\n', 'utf8')\n}\n\n/**\n * Get call site location as array.\n */\n\nfunction callSiteLocation (callSite) {\n  var file = callSite.getFileName() || '<anonymous>'\n  var line = callSite.getLineNumber()\n  var colm = callSite.getColumnNumber()\n\n  if (callSite.isEval()) {\n    file = callSite.getEvalOrigin() + ', ' + file\n  }\n\n  var site = [file, line, colm]\n\n  site.callSite = callSite\n  site.name = callSite.getFunctionName()\n\n  return site\n}\n\n/**\n * Generate a default message from the site.\n */\n\nfunction defaultMessage (site) {\n  var callSite = site.callSite\n  var funcName = site.name\n\n  // make useful anonymous name\n  if (!funcName) {\n    funcName = '<anonymous@' + formatLocation(site) + '>'\n  }\n\n  var context = callSite.getThis()\n  var typeName = context && callSite.getTypeName()\n\n  // ignore useless type name\n  if (typeName === 'Object') {\n    typeName = undefined\n  }\n\n  // make useful type name\n  if (typeName === 'Function') {\n    typeName = context.name || typeName\n  }\n\n  return typeName && callSite.getMethodName()\n    ? typeName + '.' + funcName\n    : funcName\n}\n\n/**\n * Format deprecation message without color.\n */\n\nfunction formatPlain (msg, caller, stack) {\n  var timestamp = new Date().toUTCString()\n\n  var formatted = timestamp +\n    ' ' + this._namespace +\n    ' deprecated ' + msg\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    at ' + callSiteToString(stack[i])\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' at ' + formatLocation(caller)\n  }\n\n  return formatted\n}\n\n/**\n * Format deprecation message with color.\n */\n\nfunction formatColor (msg, caller, stack) {\n  var formatted = '\\x1b[36;1m' + this._namespace + '\\x1b[22;39m' + // bold cyan\n    ' \\x1b[33;1mdeprecated\\x1b[22;39m' + // bold yellow\n    ' \\x1b[0m' + msg + '\\x1b[39m' // reset\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    \\x1b[36mat ' + callSiteToString(stack[i]) + '\\x1b[39m' // cyan\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' \\x1b[36m' + formatLocation(caller) + '\\x1b[39m' // cyan\n  }\n\n  return formatted\n}\n\n/**\n * Format call site location.\n */\n\nfunction formatLocation (callSite) {\n  return relative(basePath, callSite[0]) +\n    ':' + callSite[1] +\n    ':' + callSite[2]\n}\n\n/**\n * Get the stack as array of call sites.\n */\n\nfunction getStack () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = Math.max(10, limit)\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice this function off the top\n  var stack = obj.stack.slice(1)\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack\n}\n\n/**\n * Capture call site stack from v8.\n */\n\nfunction prepareObjectStackTrace (obj, stack) {\n  return stack\n}\n\n/**\n * Return a wrapped function in a deprecation message.\n */\n\nfunction wrapfunction (fn, message) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  var args = createArgumentsString(fn.length)\n  var deprecate = this // eslint-disable-line no-unused-vars\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  site.name = fn.name\n\n   // eslint-disable-next-line no-eval\n  var deprecatedfn = eval('(function (' + args + ') {\\n' +\n    '\"use strict\"\\n' +\n    'log.call(deprecate, message, site)\\n' +\n    'return fn.apply(this, arguments)\\n' +\n    '})')\n\n  return deprecatedfn\n}\n\n/**\n * Wrap property in a deprecation message.\n */\n\nfunction wrapproperty (obj, prop, message) {\n  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    throw new TypeError('argument obj must be object')\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n\n  if (!descriptor) {\n    throw new TypeError('must call property on owner object')\n  }\n\n  if (!descriptor.configurable) {\n    throw new TypeError('property must be configurable')\n  }\n\n  var deprecate = this\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  // set site name\n  site.name = prop\n\n  // convert data descriptor\n  if ('value' in descriptor) {\n    descriptor = convertDataDescriptorToAccessor(obj, prop, message)\n  }\n\n  var get = descriptor.get\n  var set = descriptor.set\n\n  // wrap getter\n  if (typeof get === 'function') {\n    descriptor.get = function getter () {\n      log.call(deprecate, message, site)\n      return get.apply(this, arguments)\n    }\n  }\n\n  // wrap setter\n  if (typeof set === 'function') {\n    descriptor.set = function setter () {\n      log.call(deprecate, message, site)\n      return set.apply(this, arguments)\n    }\n  }\n\n  Object.defineProperty(obj, prop, descriptor)\n}\n\n/**\n * Create DeprecationError for deprecation\n */\n\nfunction DeprecationError (namespace, message, stack) {\n  var error = new Error()\n  var stackString\n\n  Object.defineProperty(error, 'constructor', {\n    value: DeprecationError\n  })\n\n  Object.defineProperty(error, 'message', {\n    configurable: true,\n    enumerable: false,\n    value: message,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'name', {\n    enumerable: false,\n    configurable: true,\n    value: 'DeprecationError',\n    writable: true\n  })\n\n  Object.defineProperty(error, 'namespace', {\n    configurable: true,\n    enumerable: false,\n    value: namespace,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'stack', {\n    configurable: true,\n    enumerable: false,\n    get: function () {\n      if (stackString !== undefined) {\n        return stackString\n      }\n\n      // prepare stack trace\n      return (stackString = createStackString.call(this, stack))\n    },\n    set: function setter (val) {\n      stackString = val\n    }\n  })\n\n  return error\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/depd/index.js?");

/***/ }),

/***/ "../../../node_modules/depd/lib/compat/callsite-tostring.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/depd/lib/compat/callsite-tostring.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * depd\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n */\n\nmodule.exports = callSiteToString\n\n/**\n * Format a CallSite file location to a string.\n */\n\nfunction callSiteFileLocation (callSite) {\n  var fileName\n  var fileLocation = ''\n\n  if (callSite.isNative()) {\n    fileLocation = 'native'\n  } else if (callSite.isEval()) {\n    fileName = callSite.getScriptNameOrSourceURL()\n    if (!fileName) {\n      fileLocation = callSite.getEvalOrigin()\n    }\n  } else {\n    fileName = callSite.getFileName()\n  }\n\n  if (fileName) {\n    fileLocation += fileName\n\n    var lineNumber = callSite.getLineNumber()\n    if (lineNumber != null) {\n      fileLocation += ':' + lineNumber\n\n      var columnNumber = callSite.getColumnNumber()\n      if (columnNumber) {\n        fileLocation += ':' + columnNumber\n      }\n    }\n  }\n\n  return fileLocation || 'unknown source'\n}\n\n/**\n * Format a CallSite to a string.\n */\n\nfunction callSiteToString (callSite) {\n  var addSuffix = true\n  var fileLocation = callSiteFileLocation(callSite)\n  var functionName = callSite.getFunctionName()\n  var isConstructor = callSite.isConstructor()\n  var isMethodCall = !(callSite.isToplevel() || isConstructor)\n  var line = ''\n\n  if (isMethodCall) {\n    var methodName = callSite.getMethodName()\n    var typeName = getConstructorName(callSite)\n\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) !== 0) {\n        line += typeName + '.'\n      }\n\n      line += functionName\n\n      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {\n        line += ' [as ' + methodName + ']'\n      }\n    } else {\n      line += typeName + '.' + (methodName || '<anonymous>')\n    }\n  } else if (isConstructor) {\n    line += 'new ' + (functionName || '<anonymous>')\n  } else if (functionName) {\n    line += functionName\n  } else {\n    addSuffix = false\n    line += fileLocation\n  }\n\n  if (addSuffix) {\n    line += ' (' + fileLocation + ')'\n  }\n\n  return line\n}\n\n/**\n * Get constructor name of reviver.\n */\n\nfunction getConstructorName (obj) {\n  var receiver = obj.receiver\n  return (receiver.constructor && receiver.constructor.name) || null\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/depd/lib/compat/callsite-tostring.js?");

/***/ }),

/***/ "../../../node_modules/depd/lib/compat/event-listener-count.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/depd/lib/compat/event-listener-count.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * depd\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = eventListenerCount\n\n/**\n * Get the count of listeners on an event emitter of a specific type.\n */\n\nfunction eventListenerCount (emitter, type) {\n  return emitter.listeners(type).length\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/depd/lib/compat/event-listener-count.js?");

/***/ }),

/***/ "../../../node_modules/depd/lib/compat/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/depd/lib/compat/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * depd\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\n/**\n * Module exports.\n * @public\n */\n\nlazyProperty(module.exports, 'callSiteToString', function callSiteToString () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  function prepareObjectStackTrace (obj, stack) {\n    return stack\n  }\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = 2\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice the stack\n  var stack = obj.stack.slice()\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack[0].toString ? toString : __webpack_require__(/*! ./callsite-tostring */ \"../../../node_modules/depd/lib/compat/callsite-tostring.js\")\n})\n\nlazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {\n  return EventEmitter.listenerCount || __webpack_require__(/*! ./event-listener-count */ \"../../../node_modules/depd/lib/compat/event-listener-count.js\")\n})\n\n/**\n * Define a lazy property.\n */\n\nfunction lazyProperty (obj, prop, getter) {\n  function get () {\n    var val = getter()\n\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      enumerable: true,\n      value: val\n    })\n\n    return val\n  }\n\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: true,\n    get: get\n  })\n}\n\n/**\n * Call toString() on the obj\n */\n\nfunction toString (obj) {\n  return obj.toString()\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/depd/lib/compat/index.js?");

/***/ }),

/***/ "../../../node_modules/destroy/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/destroy/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * destroy\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar ReadStream = (__webpack_require__(/*! fs */ \"fs\").ReadStream)\nvar Stream = __webpack_require__(/*! stream */ \"stream\")\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = destroy\n\n/**\n * Destroy a stream.\n *\n * @param {object} stream\n * @public\n */\n\nfunction destroy(stream) {\n  if (stream instanceof ReadStream) {\n    return destroyReadStream(stream)\n  }\n\n  if (!(stream instanceof Stream)) {\n    return stream\n  }\n\n  if (typeof stream.destroy === 'function') {\n    stream.destroy()\n  }\n\n  return stream\n}\n\n/**\n * Destroy a ReadStream.\n *\n * @param {object} stream\n * @private\n */\n\nfunction destroyReadStream(stream) {\n  stream.destroy()\n\n  if (typeof stream.close === 'function') {\n    // node.js core bug work-around\n    stream.on('open', onOpenClose)\n  }\n\n  return stream\n}\n\n/**\n * On open handler to close stream.\n * @private\n */\n\nfunction onOpenClose() {\n  if (typeof this.fd === 'number') {\n    // actually close down the fd\n    this.close()\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/destroy/index.js?");

/***/ }),

/***/ "../../../node_modules/ee-first/index.js":
/*!***********************************************!*\
  !*** ../../../node_modules/ee-first/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * ee-first\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = first\n\n/**\n * Get the first event in a set of event emitters and event pairs.\n *\n * @param {array} stuff\n * @param {function} done\n * @public\n */\n\nfunction first(stuff, done) {\n  if (!Array.isArray(stuff))\n    throw new TypeError('arg must be an array of [ee, events...] arrays')\n\n  var cleanups = []\n\n  for (var i = 0; i < stuff.length; i++) {\n    var arr = stuff[i]\n\n    if (!Array.isArray(arr) || arr.length < 2)\n      throw new TypeError('each array member must be [ee, events...]')\n\n    var ee = arr[0]\n\n    for (var j = 1; j < arr.length; j++) {\n      var event = arr[j]\n      var fn = listener(event, callback)\n\n      // listen to the event\n      ee.on(event, fn)\n      // push this listener to the list of cleanups\n      cleanups.push({\n        ee: ee,\n        event: event,\n        fn: fn,\n      })\n    }\n  }\n\n  function callback() {\n    cleanup()\n    done.apply(null, arguments)\n  }\n\n  function cleanup() {\n    var x\n    for (var i = 0; i < cleanups.length; i++) {\n      x = cleanups[i]\n      x.ee.removeListener(x.event, x.fn)\n    }\n  }\n\n  function thunk(fn) {\n    done = fn\n  }\n\n  thunk.cancel = cleanup\n\n  return thunk\n}\n\n/**\n * Create the event listener.\n * @private\n */\n\nfunction listener(event, done) {\n  return function onevent(arg1) {\n    var args = new Array(arguments.length)\n    var ee = this\n    var err = event === 'error'\n      ? arg1\n      : null\n\n    // copy args to prevent arguments escaping scope\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    done(err, ee, event, args)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ee-first/index.js?");

/***/ }),

/***/ "../../../node_modules/encodeurl/index.js":
/*!************************************************!*\
  !*** ../../../node_modules/encodeurl/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * encodeurl\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = encodeUrl\n\n/**\n * RegExp to match non-URL code points, *after* encoding (i.e. not including \"%\")\n * and including invalid escape sequences.\n * @private\n */\n\nvar ENCODE_CHARS_REGEXP = /(?:[^\\x21\\x25\\x26-\\x3B\\x3D\\x3F-\\x5B\\x5D\\x5F\\x61-\\x7A\\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g\n\n/**\n * RegExp to match unmatched surrogate pair.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]([^\\uDC00-\\uDFFF]|$)/g\n\n/**\n * String to replace unmatched surrogate pair with.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\\uFFFD$2'\n\n/**\n * Encode a URL to a percent-encoded form, excluding already-encoded sequences.\n *\n * This function will take an already-encoded URL and encode all the non-URL\n * code points. This function will not encode the \"%\" character unless it is\n * not part of a valid sequence (`%20` will be left as-is, but `%foo` will\n * be encoded as `%25foo`).\n *\n * This encode is meant to be \"safe\" and does not throw errors. It will try as\n * hard as it can to properly encode the given URL, including replacing any raw,\n * unpaired surrogate pairs with the Unicode replacement character prior to\n * encoding.\n *\n * @param {string} url\n * @return {string}\n * @public\n */\n\nfunction encodeUrl (url) {\n  return String(url)\n    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)\n    .replace(ENCODE_CHARS_REGEXP, encodeURI)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/encodeurl/index.js?");

/***/ }),

/***/ "../../../node_modules/encoding-negotiator/index.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/encoding-negotiator/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction negotiate (header, supportedEncodings) {\n  if (!header) {\n    return undefined\n  }\n  const supportedEncodingMap = createMap(supportedEncodings)\n  const acceptedEncodings = parse(header)\n    .sort((a, b) => comparator(a, b, supportedEncodingMap))\n    .filter(isNonZeroQuality)\n  return determinePreffered(acceptedEncodings, supportedEncodingMap)\n}\n\nfunction determinePreffered (acceptedEncodings, supportedEncodings) {\n  for (const encoding of acceptedEncodings) {\n    const selected = supportedEncodings[encoding.name]\n    if (selected) {\n      return selected.encoding\n    }\n  }\n  return null\n}\n\nfunction createMap (supported) {\n  const supportedEncodings = {}\n  let priority = 0\n  if (supported.length > 0) {\n    supportedEncodings['*'] = { encoding: supported[0], priority }\n    priority++\n  }\n  for (const encoding of supported) {\n    supportedEncodings[encoding] = { encoding, priority }\n    priority++\n  }\n  return supportedEncodings\n}\n\nfunction parse (header) {\n  const split = header.split(',')\n  return split.map(parseEncoding)\n}\n\nfunction isNonZeroQuality (encoding) {\n  return encoding.quality !== 0\n}\n\nfunction parseEncoding (encoding) {\n  const [name, second] = encoding.trim().split(';')\n  const quality = getQuality(second)\n  return {\n    name,\n    quality\n  }\n}\n\nfunction getQuality (second) {\n  if (!second) {\n    return 1\n  }\n  const [, quality] = second.trim().split('=')\n  return parseFloat(quality)\n}\n\nfunction comparator (a, b, supportedEncodingMap) {\n  if (a.quality === b.quality) {\n    if (supportedEncodingMap[a.name] &&\n      supportedEncodingMap[b.name] &&\n      supportedEncodingMap[a.name].priority < supportedEncodingMap[b.name].priority) {\n      return -1\n    } else {\n      return 1\n    }\n  }\n  return b.quality - a.quality\n}\n\nmodule.exports = {\n  negotiate\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/encoding-negotiator/index.js?");

/***/ }),

/***/ "../../../node_modules/end-of-stream/index.js":
/*!****************************************************!*\
  !*** ../../../node_modules/end-of-stream/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var once = __webpack_require__(/*! once */ \"../../../node_modules/once/once.js\");\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/end-of-stream/index.js?");

/***/ }),

/***/ "../../../node_modules/escape-html/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/escape-html/index.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/escape-html/index.js?");

/***/ }),

/***/ "../../../node_modules/etag/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/etag/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * etag\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = etag\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar Stats = (__webpack_require__(/*! fs */ \"fs\").Stats)\n\n/**\n * Module variables.\n * @private\n */\n\nvar toString = Object.prototype.toString\n\n/**\n * Generate an entity tag.\n *\n * @param {Buffer|string} entity\n * @return {string}\n * @private\n */\n\nfunction entitytag (entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"'\n  }\n\n  // compute hash of entity\n  var hash = crypto\n    .createHash('sha1')\n    .update(entity, 'utf8')\n    .digest('base64')\n    .substring(0, 27)\n\n  // compute length of entity\n  var len = typeof entity === 'string'\n    ? Buffer.byteLength(entity, 'utf8')\n    : entity.length\n\n  return '\"' + len.toString(16) + '-' + hash + '\"'\n}\n\n/**\n * Create a simple ETag.\n *\n * @param {string|Buffer|Stats} entity\n * @param {object} [options]\n * @param {boolean} [options.weak]\n * @return {String}\n * @public\n */\n\nfunction etag (entity, options) {\n  if (entity == null) {\n    throw new TypeError('argument entity is required')\n  }\n\n  // support fs.Stats object\n  var isStats = isstats(entity)\n  var weak = options && typeof options.weak === 'boolean'\n    ? options.weak\n    : isStats\n\n  // validate argument\n  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {\n    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')\n  }\n\n  // generate entity tag\n  var tag = isStats\n    ? stattag(entity)\n    : entitytag(entity)\n\n  return weak\n    ? 'W/' + tag\n    : tag\n}\n\n/**\n * Determine if object is a Stats object.\n *\n * @param {object} obj\n * @return {boolean}\n * @api private\n */\n\nfunction isstats (obj) {\n  // genuine fs.Stats\n  if (typeof Stats === 'function' && obj instanceof Stats) {\n    return true\n  }\n\n  // quack quack\n  return obj && typeof obj === 'object' &&\n    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&\n    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&\n    'ino' in obj && typeof obj.ino === 'number' &&\n    'size' in obj && typeof obj.size === 'number'\n}\n\n/**\n * Generate a tag for a stat.\n *\n * @param {object} stat\n * @return {string}\n * @private\n */\n\nfunction stattag (stat) {\n  var mtime = stat.mtime.getTime().toString(16)\n  var size = stat.size.toString(16)\n\n  return '\"' + size + '-' + mtime + '\"'\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/etag/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-decode-uri-component/index.js":
/*!****************************************************************!*\
  !*** ../../../node_modules/fast-decode-uri-component/index.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-decode-uri-component/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-deep-equal/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fast-deep-equal/index.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-deep-equal/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-json-stable-stringify/index.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/fast-json-stable-stringify/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-json-stable-stringify/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-json-stringify/index.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/fast-json-stringify/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst Ajv = __webpack_require__(/*! ajv */ \"../../../node_modules/ajv/lib/ajv.js\")\nconst merge = __webpack_require__(/*! deepmerge */ \"../../../node_modules/deepmerge/dist/cjs.js\")\nconst clone = __webpack_require__(/*! rfdc */ \"../../../node_modules/rfdc/index.js\")({ proto: true })\nconst fjsCloned = Symbol('fast-json-stringify.cloned')\n\nconst validate = __webpack_require__(/*! ./schema-validator */ \"../../../node_modules/fast-json-stringify/schema-validator.js\")\nlet stringSimilarity = null\n\nlet isLong\ntry {\n  isLong = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'long'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())\n} catch (e) {\n  isLong = null\n}\n\nconst addComma = `\n  if (addComma) {\n    json += ','\n  } else {\n    addComma = true\n  }\n`\n\nfunction isValidSchema (schema, name) {\n  if (!validate(schema)) {\n    if (name) {\n      name = `\"${name}\" `\n    } else {\n      name = ''\n    }\n    const first = validate.errors[0]\n    const err = new Error(`${name}schema is invalid: data${first.dataPath} ${first.message}`)\n    err.errors = isValidSchema.errors\n    throw err\n  }\n}\n\nfunction mergeLocation (source, dest) {\n  return {\n    schema: dest.schema || source.schema,\n    root: dest.root || source.root,\n    externalSchema: dest.externalSchema || source.externalSchema\n  }\n}\n\nconst arrayItemsReferenceSerializersMap = new Map()\nconst objectReferenceSerializersMap = new Map()\n\nfunction build (schema, options) {\n  arrayItemsReferenceSerializersMap.clear()\n  objectReferenceSerializersMap.clear()\n  options = options || {}\n  isValidSchema(schema)\n  if (options.schema) {\n    // eslint-disable-next-line\n    for (var key of Object.keys(options.schema)) {\n      isValidSchema(options.schema[key], key)\n    }\n  }\n\n  let intParseFunctionName = 'trunc'\n  if (options.rounding) {\n    if (['floor', 'ceil', 'round'].includes(options.rounding)) {\n      intParseFunctionName = options.rounding\n    } else {\n      throw new Error(`Unsupported integer rounding method ${options.rounding}`)\n    }\n  }\n\n  /* eslint no-new-func: \"off\" */\n  let code = `\n    'use strict'\n  `\n\n  code += `\n    ${asFunctions}\n\n    var isLong = ${isLong ? isLong.toString() : false}\n\n    function parseInteger(int) { return Math.${intParseFunctionName}(int) }\n    `\n\n  let location = {\n    schema,\n    root: schema,\n    externalSchema: options.schema\n  }\n\n  if (schema.$ref) {\n    location = refFinder(schema.$ref, location)\n    schema = location.schema\n  }\n\n  if (schema.type === undefined) {\n    schema.type = inferTypeByKeyword(schema)\n  }\n\n  let main\n\n  switch (schema.type) {\n    case 'object':\n      main = '$main'\n      code = buildObject(location, code, main)\n      break\n    case 'string':\n      main = schema.nullable ? '$asStringNullable' : getStringSerializer(schema.format)\n      break\n    case 'integer':\n      main = schema.nullable ? '$asIntegerNullable' : '$asInteger'\n      break\n    case 'number':\n      main = schema.nullable ? '$asNumberNullable' : '$asNumber'\n      break\n    case 'boolean':\n      main = schema.nullable ? '$asBooleanNullable' : '$asBoolean'\n      break\n    case 'null':\n      main = '$asNull'\n      break\n    case 'array':\n      main = '$main'\n      code = buildArray(location, code, main)\n      schema = location.schema\n      break\n    case undefined:\n      main = '$asAny'\n      break\n    default:\n      throw new Error(`${schema.type} unsupported`)\n  }\n\n  code += `\n    ;\n     return ${main}\n  `\n\n  const dependencies = [new Ajv(options.ajv)]\n  const dependenciesName = ['ajv']\n  dependenciesName.push(code)\n\n  if (options.debugMode) {\n    dependenciesName.toString = function () {\n      return dependenciesName.join('\\n')\n    }\n    return dependenciesName\n  }\n\n  arrayItemsReferenceSerializersMap.clear()\n  objectReferenceSerializersMap.clear()\n\n  return (Function.apply(null, dependenciesName).apply(null, dependencies))\n}\n\nconst objectKeywords = [\n  'maxProperties',\n  'minProperties',\n  'required',\n  'properties',\n  'patternProperties',\n  'additionalProperties',\n  'dependencies'\n]\n\nconst arrayKeywords = [\n  'items',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'contains'\n]\n\nconst stringKeywords = [\n  'maxLength',\n  'minLength',\n  'pattern'\n]\n\nconst numberKeywords = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum'\n]\n\n/**\n * Infer type based on keyword in order to generate optimized code\n * https://json-schema.org/latest/json-schema-validation.html#rfc.section.6\n */\nfunction inferTypeByKeyword (schema) {\n  // eslint-disable-next-line\n  for (var keyword of objectKeywords) {\n    if (keyword in schema) return 'object'\n  }\n  // eslint-disable-next-line\n  for (var keyword of arrayKeywords) {\n    if (keyword in schema) return 'array'\n  }\n  // eslint-disable-next-line\n  for (var keyword of stringKeywords) {\n    if (keyword in schema) return 'string'\n  }\n  // eslint-disable-next-line\n  for (var keyword of numberKeywords) {\n    if (keyword in schema) return 'number'\n  }\n  return schema.type\n}\n\nconst stringSerializerMap = {\n  'date-time': '$asDatetime',\n  date: '$asDate',\n  time: '$asTime'\n}\n\nfunction getStringSerializer (format) {\n  return stringSerializerMap[format] ||\n  '$asString'\n}\n\nfunction getTestSerializer (format) {\n  return stringSerializerMap[format]\n}\n\nconst asFunctions = `\nfunction $pad2Zeros (num) {\n  const s = '00' + num\n  return s[s.length - 2] + s[s.length - 1]\n}\n\nfunction $asAny (i) {\n  return JSON.stringify(i)\n}\n\nfunction $asNull () {\n  return 'null'\n}\n\nfunction $asInteger (i) {\n  if (isLong && isLong(i)) {\n    return i.toString()\n  } else if (typeof i === 'bigint') {\n    return i.toString()\n  } else if (Number.isInteger(i)) {\n    return $asNumber(i)\n  } else {\n    /* eslint no-undef: \"off\" */\n    return $asNumber(parseInteger(i))\n  }\n}\n\nfunction $asIntegerNullable (i) {\n  return i === null ? null : $asInteger(i)\n}\n\nfunction $asNumber (i) {\n  const num = Number(i)\n  if (isNaN(num)) {\n    return 'null'\n  } else {\n    return '' + num\n  }\n}\n\nfunction $asNumberNullable (i) {\n  return i === null ? null : $asNumber(i)\n}\n\nfunction $asBoolean (bool) {\n  return bool && 'true' || 'false' // eslint-disable-line\n}\n\nfunction $asBooleanNullable (bool) {\n  return bool === null ? null : $asBoolean(bool)\n}\n\nfunction $asDatetime (date, skipQuotes) {\n  const quotes = skipQuotes === true ? '' : '\"'\n  if (date instanceof Date) {\n    return quotes + date.toISOString() + quotes\n  } else if (date && typeof date.toISOString === 'function') {\n    return quotes + date.toISOString() + quotes\n  } else {\n    return $asString(date, skipQuotes)\n  }\n}\n\nfunction $asDate (date, skipQuotes) {\n  const quotes = skipQuotes === true ? '' : '\"'\n  if (date instanceof Date) {\n    return quotes + new Date(date.getTime() - (date.getTimezoneOffset() * 60000 )).toISOString().slice(0, 10) + quotes\n  } else if (date && typeof date.format === 'function') {\n    return quotes + date.format('YYYY-MM-DD') + quotes\n  } else {\n    return $asString(date, skipQuotes)\n  }\n}\n\nfunction $asTime (date, skipQuotes) {\n  const quotes = skipQuotes === true ? '' : '\"'\n  if (date instanceof Date) {\n    const hour = new Intl.DateTimeFormat('en', { hour: 'numeric', hour12: false }).format(date)\n    const minute = new Intl.DateTimeFormat('en', { minute: 'numeric' }).format(date)\n    const second = new Intl.DateTimeFormat('en', { second: 'numeric' }).format(date)\n    return quotes + $pad2Zeros(hour) + ':' + $pad2Zeros(minute) + ':' + $pad2Zeros(second) + quotes\n  } else if (date && typeof date.format === 'function') {\n    return quotes + date.format('HH:mm:ss') + quotes\n  } else {\n    return $asString(date, skipQuotes)\n  }\n}\n\nfunction $asString (str, skipQuotes) {\n  const quotes = skipQuotes === true ? '' : '\"'\n  if (str instanceof Date) {\n    return quotes + str.toISOString() + quotes\n  } else if (str === null) {\n    return quotes + quotes\n  } else if (str instanceof RegExp) {\n    str = str.source\n  } else if (typeof str !== 'string') {\n    str = str.toString()\n  }\n  // If we skipQuotes it means that we are using it as test\n  // no need to test the string length for the render\n  if (skipQuotes) {\n    return str\n  }\n\n  if (str.length < 42) {\n    return $asStringSmall(str)\n  } else {\n    return JSON.stringify(str)\n  }\n}\n\nfunction $asStringNullable (str) {\n  return str === null ? null : $asString(str)\n}\n\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// every string that contain surrogate needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction $asStringSmall (str) {\n  const l = str.length\n  let result = ''\n  let last = 0\n  let found = false\n  let surrogateFound = false\n  let point = 255\n  // eslint-disable-next-line\n  for (var i = 0; i < l && point >= 32; i++) {\n    point = str.charCodeAt(i)\n    if (point >= 0xD800 && point <= 0xDFFF) {\n      // The current character is a surrogate.\n      surrogateFound = true\n    }\n    if (point === 34 || point === 92) {\n      result += str.slice(last, i) + '\\\\\\\\'\n      last = i\n      found = true\n    }\n  }\n\n  if (!found) {\n    result = str\n  } else {\n    result += str.slice(last)\n  }\n  return ((point < 32) || (surrogateFound === true)) ? JSON.stringify(str) : '\"' + result + '\"'\n}\n`\n\nfunction addPatternProperties (location) {\n  const schema = location.schema\n  const pp = schema.patternProperties\n  let code = `\n      var properties = ${JSON.stringify(schema.properties)} || {}\n      var keys = Object.keys(obj)\n      for (var i = 0; i < keys.length; i++) {\n        if (properties[keys[i]]) continue\n  `\n  Object.keys(pp).forEach((regex, index) => {\n    let ppLocation = mergeLocation(location, { schema: pp[regex] })\n    if (pp[regex].$ref) {\n      ppLocation = refFinder(pp[regex].$ref, location)\n      pp[regex] = ppLocation.schema\n    }\n    const type = pp[regex].type\n    const format = pp[regex].format\n    const stringSerializer = getStringSerializer(format)\n    try {\n      RegExp(regex)\n    } catch (err) {\n      throw new Error(`${err.message}. Found at ${regex} matching ${JSON.stringify(pp[regex])}`)\n    }\n\n    const ifPpKeyExists = `if (/${regex.replace(/\\\\*\\//g, '\\\\/')}/.test(keys[i])) {`\n\n    if (type === 'object') {\n      code += `${buildObject(ppLocation, '', 'buildObjectPP' + index)}\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + buildObjectPP${index}(obj[keys[i]])\n      `\n    } else if (type === 'array') {\n      code += `${buildArray(ppLocation, '', 'buildArrayPP' + index)}\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + buildArrayPP${index}(obj[keys[i]])\n      `\n    } else if (type === 'null') {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) +':null'\n      `\n    } else if (type === 'string') {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + ${stringSerializer}(obj[keys[i]])\n      `\n    } else if (type === 'integer') {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])\n      `\n    } else if (type === 'number') {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + $asNumber(obj[keys[i]])\n      `\n    } else if (type === 'boolean') {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])\n      `\n    } else if (type === undefined) {\n      code += `\n          ${ifPpKeyExists}\n          ${addComma}\n          json += $asString(keys[i]) + ':' + $asAny(obj[keys[i]])\n      `\n    } else {\n      code += `\n        ${ifPpKeyExists}\n        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ' + ${JSON.stringify(type)})\n      `\n    }\n\n    code += `\n          continue\n        }\n    `\n  })\n  if (schema.additionalProperties) {\n    code += additionalProperty(location)\n  }\n\n  code += `\n      }\n  `\n  return code\n}\n\nfunction additionalProperty (location) {\n  let ap = location.schema.additionalProperties\n  let code = ''\n  if (ap === true) {\n    return `\n        if (obj[keys[i]] !== undefined && typeof obj[keys[i]] !== 'function' && typeof obj[keys[i]] !== 'symbol') {\n          ${addComma}\n          json += $asString(keys[i]) + ':' + JSON.stringify(obj[keys[i]])\n        }\n    `\n  }\n  let apLocation = mergeLocation(location, { schema: ap })\n  if (ap.$ref) {\n    apLocation = refFinder(ap.$ref, location)\n    ap = apLocation.schema\n  }\n\n  const type = ap.type\n  const format = ap.format\n  const stringSerializer = getStringSerializer(format)\n  if (type === 'object') {\n    code += `${buildObject(apLocation, '', 'buildObjectAP')}\n        ${addComma}\n        json += $asString(keys[i]) + ':' + buildObjectAP(obj[keys[i]])\n    `\n  } else if (type === 'array') {\n    code += `${buildArray(apLocation, '', 'buildArrayAP')}\n        ${addComma}\n        json += $asString(keys[i]) + ':' + buildArrayAP(obj[keys[i]])\n    `\n  } else if (type === 'null') {\n    code += `\n        ${addComma}\n        json += $asString(keys[i]) +':null'\n    `\n  } else if (type === 'string') {\n    code += `\n        ${addComma}\n        json += $asString(keys[i]) + ':' + ${stringSerializer}(obj[keys[i]])\n    `\n  } else if (type === 'integer') {\n    code += `\n        var t = Number(obj[keys[i]])\n    `\n    if (isLong) {\n      code += `\n          if (isLong(obj[keys[i]]) || !isNaN(t)) {\n            ${addComma}\n            json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])\n          }\n      `\n    } else {\n      code += `\n          if (!isNaN(t)) {\n            ${addComma}\n            json += $asString(keys[i]) + ':' + t\n          }\n      `\n    }\n  } else if (type === 'number') {\n    code += `\n        var t = Number(obj[keys[i]])\n        if (!isNaN(t)) {\n          ${addComma}\n          json += $asString(keys[i]) + ':' + t\n        }\n    `\n  } else if (type === 'boolean') {\n    code += `\n        ${addComma}\n        json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])\n    `\n  } else if (type === undefined) {\n    code += `\n        ${addComma}\n        json += $asString(keys[i]) + ':' + $asAny(obj[keys[i]])\n    `\n  } else {\n    code += `\n        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ' + ${JSON.stringify(type)})\n    `\n  }\n  return code\n}\n\nfunction addAdditionalProperties (location) {\n  return `\n      var properties = ${JSON.stringify(location.schema.properties)} || {}\n      var keys = Object.keys(obj)\n      for (var i = 0; i < keys.length; i++) {\n        if (properties[keys[i]]) continue\n        ${additionalProperty(location)}\n      }\n  `\n}\n\nfunction idFinder (schema, searchedId) {\n  let objSchema\n  const explore = (schema, searchedId) => {\n    Object.keys(schema || {}).forEach((key, i, a) => {\n      if (key === '$id' && schema[key] === searchedId) {\n        objSchema = schema\n      } else if (objSchema === undefined && typeof schema[key] === 'object') {\n        explore(schema[key], searchedId)\n      }\n    })\n  }\n  explore(schema, searchedId)\n  return objSchema\n}\n\nfunction refFinder (ref, location) {\n  const externalSchema = location.externalSchema\n  let root = location.root\n  let schema = location.schema\n\n  if (externalSchema && externalSchema[ref]) {\n    return {\n      schema: externalSchema[ref],\n      root: externalSchema[ref],\n      externalSchema: externalSchema\n    }\n  }\n\n  // Split file from walk\n  ref = ref.split('#')\n\n  // If external file\n  if (ref[0]) {\n    schema = externalSchema[ref[0]]\n    root = externalSchema[ref[0]]\n\n    if (schema === undefined) {\n      findBadKey(externalSchema, [ref[0]])\n    }\n\n    if (schema.$ref) {\n      return refFinder(schema.$ref, {\n        schema: schema,\n        root: root,\n        externalSchema: externalSchema\n      })\n    }\n  }\n\n  let code = 'return schema'\n  // If it has a path\n  if (ref[1]) {\n    // ref[1] could contain a JSON pointer - ex: /definitions/num\n    // or plain name fragment id without suffix # - ex: customId\n    const walk = ref[1].split('/')\n    if (walk.length === 1) {\n      const targetId = `#${ref[1]}`\n      let dereferenced = idFinder(schema, targetId)\n      if (dereferenced === undefined && !ref[0]) {\n        // eslint-disable-next-line\n        for (var key of Object.keys(externalSchema)) {\n          dereferenced = idFinder(externalSchema[key], targetId)\n          if (dereferenced !== undefined) {\n            root = externalSchema[key]\n            break\n          }\n        }\n      }\n\n      return {\n        schema: dereferenced,\n        root: root,\n        externalSchema: externalSchema\n      }\n    } else {\n      // eslint-disable-next-line\n      for (var i = 1; i < walk.length; i++) {\n        code += `[${JSON.stringify(walk[i])}]`\n      }\n    }\n  }\n  let result\n  try {\n    result = (new Function('schema', code))(root)\n  } catch (err) {}\n\n  if (result === undefined && ref[1]) {\n    const walk = ref[1].split('/')\n    findBadKey(schema, walk.slice(1))\n  }\n\n  if (result.$ref) {\n    return refFinder(result.$ref, {\n      schema: schema,\n      root: root,\n      externalSchema: externalSchema\n    })\n  }\n\n  return {\n    schema: result,\n    root: root,\n    externalSchema: externalSchema\n  }\n\n  function findBadKey (obj, keys) {\n    if (keys.length === 0) return null\n    const key = keys.shift()\n    if (obj[key] === undefined) {\n      stringSimilarity = stringSimilarity || __webpack_require__(/*! string-similarity */ \"../../../node_modules/string-similarity/src/index.js\")\n      const { bestMatch } = stringSimilarity.findBestMatch(key, Object.keys(obj))\n      if (bestMatch.rating >= 0.5) {\n        throw new Error(`Cannot find reference ${JSON.stringify(key)}, did you mean ${JSON.stringify(bestMatch.target)}?`)\n      } else {\n        throw new Error(`Cannot find reference ${JSON.stringify(key)}`)\n      }\n    }\n    return findBadKey(obj[key], keys)\n  }\n}\n\nfunction buildCode (location, code, laterCode, name) {\n  if (location.schema.$ref) {\n    location = refFinder(location.schema.$ref, location)\n  }\n\n  const schema = location.schema\n  let required = schema.required\n\n  Object.keys(schema.properties || {}).forEach((key, i, a) => {\n    let propertyLocation = mergeLocation(location, { schema: schema.properties[key] })\n    if (schema.properties[key].$ref) {\n      propertyLocation = refFinder(schema.properties[key].$ref, location)\n      schema.properties[key] = propertyLocation.schema\n    }\n\n    // Using obj['key'] !== undefined instead of obj.hasOwnProperty(prop) for perf reasons,\n    // see https://github.com/mcollina/fast-json-stringify/pull/3 for discussion.\n\n    const type = schema.properties[key].type\n    const nullable = schema.properties[key].nullable\n    const sanitized = JSON.stringify(key)\n    const asString = JSON.stringify(sanitized)\n\n    if (nullable) {\n      code += `\n        if (obj[${sanitized}] === null) {\n          ${addComma}\n          json += ${asString} + ':null'\n          var rendered = true\n        } else {\n      `\n    }\n\n    if (type === 'number') {\n      code += `\n          var t = Number(obj[${sanitized}])\n          if (!isNaN(t)) {\n            ${addComma}\n            json += ${asString} + ':' + t\n      `\n    } else if (type === 'integer') {\n      code += `\n          var rendered = false\n      `\n      if (isLong) {\n        code += `\n            if (isLong(obj[${sanitized}])) {\n              ${addComma}\n              json += ${asString} + ':' + obj[${sanitized}].toString()\n              rendered = true\n            } else {\n              var t = Number(obj[${sanitized}])\n              if (!isNaN(t)) {\n                ${addComma}\n                json += ${asString} + ':' + t\n                rendered = true\n              }\n            }\n        `\n      } else {\n        code += `\n            var t = $asInteger(obj[${sanitized}])\n            if (!isNaN(t)) {\n              ${addComma}\n              json += ${asString} + ':' + t\n              rendered = true\n            }\n        `\n      }\n      code += `\n          if (rendered) {\n      `\n    } else {\n      code += `\n        if (obj[${sanitized}] !== undefined) {\n          ${addComma}\n          json += ${asString} + ':'\n        `\n\n      const result = nested(laterCode, name, key, mergeLocation(propertyLocation, { schema: schema.properties[key] }), undefined, false)\n      code += result.code\n      laterCode = result.laterCode\n    }\n\n    const defaultValue = schema.properties[key].default\n    if (defaultValue !== undefined) {\n      required = filterRequired(required, key)\n      code += `\n      } else {\n        ${addComma}\n        json += ${asString} + ':' + ${JSON.stringify(JSON.stringify(defaultValue))}\n      `\n    } else if (required && required.indexOf(key) !== -1) {\n      required = filterRequired(required, key)\n      code += `\n      } else {\n        throw new Error('${sanitized} is required!')\n      `\n    }\n\n    code += `\n      }\n    `\n\n    if (nullable) {\n      code += `\n        }\n      `\n    }\n  })\n\n  if (required && required.length > 0) {\n    code += 'var required = ['\n    // eslint-disable-next-line\n    for (var i = 0; i < required.length; i++) {\n      if (i > 0) {\n        code += ','\n      }\n      code += `${JSON.stringify(required[i])}`\n    }\n    code += `]\n      for (var i = 0; i < required.length; i++) {\n        if (obj[required[i]] === undefined) throw new Error('\"' + required[i] + '\" is required!')\n      }\n    `\n  }\n\n  if (schema.allOf) {\n    const builtCode = buildCodeWithAllOfs(location, code, laterCode, name)\n    code = builtCode.code\n    laterCode = builtCode.laterCode\n  }\n\n  return { code: code, laterCode: laterCode }\n}\n\nfunction filterRequired (required, key) {\n  if (!required) {\n    return required\n  }\n  return required.filter(k => k !== key)\n}\n\nfunction buildCodeWithAllOfs (location, code, laterCode, name) {\n  if (location.schema.allOf) {\n    location.schema.allOf.forEach((ss) => {\n      const builtCode = buildCodeWithAllOfs(mergeLocation(location, { schema: ss }), code, laterCode, name)\n      code = builtCode.code\n      laterCode = builtCode.laterCode\n    })\n  } else {\n    const builtCode = buildCode(location, code, laterCode, name)\n\n    code = builtCode.code\n    laterCode = builtCode.laterCode\n  }\n\n  return { code: code, laterCode: laterCode }\n}\n\nfunction buildInnerObject (location, name) {\n  const schema = location.schema\n  const result = buildCodeWithAllOfs(location, '', '', name)\n  if (schema.patternProperties) {\n    result.code += addPatternProperties(location)\n  } else if (schema.additionalProperties && !schema.patternProperties) {\n    result.code += addAdditionalProperties(location)\n  }\n  return result\n}\n\nfunction addIfThenElse (location, name) {\n  let code = ''\n  let r\n  let laterCode = ''\n  let innerR\n\n  const schema = location.schema\n  const copy = merge({}, schema)\n  const i = copy.if\n  const then = copy.then\n  const e = copy.else ? copy.else : { additionalProperties: true }\n  delete copy.if\n  delete copy.then\n  delete copy.else\n  let merged = merge(copy, then)\n  let mergedLocation = mergeLocation(location, { schema: merged })\n\n  code += `\n    valid = ajv.validate(${JSON.stringify(i)}, obj)\n    if (valid) {\n  `\n  if (merged.if && merged.then) {\n    innerR = addIfThenElse(mergedLocation, name + 'Then')\n    code += innerR.code\n    laterCode = innerR.laterCode\n  }\n\n  r = buildInnerObject(mergedLocation, name + 'Then')\n  code += r.code\n  laterCode += r.laterCode\n\n  code += `\n    }\n  `\n  merged = merge(copy, e)\n  mergedLocation = mergeLocation(mergedLocation, { schema: merged })\n\n  code += `\n      else {\n    `\n\n  if (merged.if && merged.then) {\n    innerR = addIfThenElse(mergedLocation, name + 'Else')\n    code += innerR.code\n    laterCode += innerR.laterCode\n  }\n\n  r = buildInnerObject(mergedLocation, name + 'Else')\n  code += r.code\n  laterCode += r.laterCode\n\n  code += `\n      }\n    `\n  return { code: code, laterCode: laterCode }\n}\n\nfunction toJSON (variableName) {\n  return `(${variableName} && typeof ${variableName}.toJSON === 'function')\n    ? ${variableName}.toJSON()\n    : ${variableName}\n  `\n}\n\nfunction buildObject (location, code, name) {\n  const schema = location.schema\n\n  code += `\n    function ${name} (input) {\n  `\n  if (schema.nullable) {\n    code += `\n      if(input === null) {\n        return 'null';\n      }\n  `\n  }\n\n  if (objectReferenceSerializersMap.has(schema)) {\n    code += `\n      return ${objectReferenceSerializersMap.get(schema)}(input)\n    }\n    `\n    return code\n  }\n  objectReferenceSerializersMap.set(schema, name)\n\n  code += `\n      var obj = ${toJSON('input')}\n      var json = '{'\n      var addComma = false\n  `\n\n  let r\n  if (schema.if && schema.then) {\n    code += `\n      var valid\n    `\n    r = addIfThenElse(location, name)\n  } else {\n    r = buildInnerObject(location, name)\n  }\n\n  // Removes the comma if is the last element of the string (in case there are not properties)\n  code += `${r.code}\n      json += '}'\n      return json\n    }\n    ${r.laterCode}\n  `\n\n  return code\n}\n\nfunction buildArray (location, code, name, key = null) {\n  let schema = location.schema\n  code += `\n    function ${name} (obj) {\n  `\n  if (schema.nullable) {\n    code += `\n      if(obj === null) {\n        return 'null';\n      }\n    `\n  }\n  const laterCode = ''\n\n  // default to any items type\n  if (!schema.items) {\n    schema.items = {}\n  }\n\n  if (schema.items.$ref) {\n    if (!schema[fjsCloned]) {\n      location.schema = clone(location.schema)\n      schema = location.schema\n      schema[fjsCloned] = true\n    }\n\n    location = refFinder(schema.items.$ref, location)\n    schema.items = location.schema\n\n    if (arrayItemsReferenceSerializersMap.has(schema.items)) {\n      code += `\n      return ${arrayItemsReferenceSerializersMap.get(schema.items)}(obj)\n      }\n      `\n      return code\n    }\n    arrayItemsReferenceSerializersMap.set(schema.items, name)\n  }\n\n  let result = { code: '', laterCode: '' }\n  const accessor = '[i]'\n  if (Array.isArray(schema.items)) {\n    result = schema.items.reduce((res, item, i) => {\n      const tmpRes = nested(laterCode, name, accessor, mergeLocation(location, { schema: item }), i, true)\n      const condition = `i === ${i} && ${buildArrayTypeCondition(item.type, accessor)}`\n      return {\n        code: `${res.code}\n        ${i > 0 ? 'else' : ''} if (${condition}) {\n          ${tmpRes.code}\n        }`,\n        laterCode: `${res.laterCode}\n        ${tmpRes.laterCode}`\n      }\n    }, result)\n\n    if (schema.additionalItems) {\n      const tmpRes = nested(laterCode, name, accessor, mergeLocation(location, { schema: schema.items }), undefined, true)\n      result.code += `\n      else if (i >= ${schema.items.length}) {\n        ${tmpRes.code}\n      }\n      `\n    }\n\n    result.code += `\n    else {\n      throw new Error(\\`Item at $\\{i} does not match schema definition.\\`)\n    }\n    `\n  } else {\n    result = nested(laterCode, name, accessor, mergeLocation(location, { schema: schema.items }), undefined, true)\n  }\n\n  if (key) {\n    code += `\n    if(!Array.isArray(obj)) {\n      throw new TypeError(\\`Property '${key}' should be of type array, received '$\\{obj}' instead.\\`)\n    }\n    `\n  }\n\n  code += `\n    var l = obj.length\n    var jsonOutput= ''\n    for (var i = 0; i < l; i++) {\n      var json = ''\n      ${result.code}\n      jsonOutput += json\n\n      if (json.length > 0 && i < l - 1) {\n        jsonOutput += ','\n      }\n    }\n    return \\`[\\${jsonOutput}]\\`\n  }\n  ${result.laterCode}\n  `\n\n  return code\n}\n\nfunction buildArrayTypeCondition (type, accessor) {\n  let condition\n  switch (type) {\n    case 'null':\n      condition = `obj${accessor} === null`\n      break\n    case 'string':\n      condition = `typeof obj${accessor} === 'string'`\n      break\n    case 'integer':\n      condition = `Number.isInteger(obj${accessor})`\n      break\n    case 'number':\n      condition = `Number.isFinite(obj${accessor})`\n      break\n    case 'boolean':\n      condition = `typeof obj${accessor} === 'boolean'`\n      break\n    case 'object':\n      condition = `obj${accessor} && typeof obj${accessor} === 'object' && obj${accessor}.constructor === Object`\n      break\n    case 'array':\n      condition = `Array.isArray(obj${accessor})`\n      break\n    default:\n      if (Array.isArray(type)) {\n        const conditions = type.map((subType) => {\n          return buildArrayTypeCondition(subType, accessor)\n        })\n        condition = `(${conditions.join(' || ')})`\n      } else {\n        throw new Error(`${type} unsupported`)\n      }\n  }\n  return condition\n}\n\nfunction dereferenceOfRefs (location, type) {\n  if (!location.schema[fjsCloned]) {\n    const schemaClone = clone(location.schema)\n    schemaClone[fjsCloned] = true\n    location.schema = schemaClone\n  }\n\n  const schema = location.schema\n  const locations = []\n\n  schema[type].forEach((s, index) => {\n    // follow the refs\n    let sLocation = mergeLocation(location, { schema: s })\n    while (s.$ref) {\n      sLocation = refFinder(s.$ref, sLocation)\n      schema[type][index] = sLocation.schema\n      s = schema[type][index]\n    }\n    locations[index] = sLocation\n  })\n\n  return locations\n}\n\nlet strNameCounter = 0\nfunction asFuncName (str) {\n  // only allow chars that can work\n  let rep = str.replace(/[^a-zA-Z0-9$_]/g, '')\n\n  if (rep.length === 0) {\n    return 'anan' + strNameCounter++\n  } else if (rep !== str) {\n    rep += strNameCounter++\n  }\n\n  return rep\n}\n\nfunction nested (laterCode, name, key, location, subKey, isArray) {\n  let code = ''\n  let funcName\n\n  subKey = subKey || ''\n\n  let schema = location.schema\n\n  if (schema.$ref) {\n    schema = refFinder(schema.$ref, location)\n  }\n\n  if (schema.type === undefined) {\n    const inferredType = inferTypeByKeyword(schema)\n    if (inferredType) {\n      schema.type = inferredType\n    }\n  }\n\n  const type = schema.type\n  const nullable = schema.nullable === true\n\n  const accessor = isArray ? key : `[${JSON.stringify(key)}]`\n\n  switch (type) {\n    case 'null':\n      code += `\n        json += $asNull()\n      `\n      break\n    case 'string': {\n      const stringSerializer = getStringSerializer(schema.format)\n      code += nullable ? `json += obj${accessor} === null ? null : ${stringSerializer}(obj${accessor})` : `json += ${stringSerializer}(obj${accessor})`\n      break\n    }\n    case 'integer':\n      code += nullable ? `json += obj${accessor} === null ? null : $asInteger(obj${accessor})` : `json += $asInteger(obj${accessor})`\n      break\n    case 'number':\n      code += nullable ? `json += obj${accessor} === null ? null : $asNumber(obj${accessor})` : `json += $asNumber(obj${accessor})`\n      break\n    case 'boolean':\n      code += nullable ? `json += obj${accessor} === null ? null : $asBoolean(obj${accessor})` : `json += $asBoolean(obj${accessor})`\n      break\n    case 'object':\n      funcName = asFuncName(name + key + subKey)\n      laterCode = buildObject(location, laterCode, funcName)\n      code += `\n        json += ${funcName}(obj${accessor})\n      `\n      break\n    case 'array':\n      funcName = asFuncName('$arr' + name + key + subKey) // eslint-disable-line\n      laterCode = buildArray(location, laterCode, funcName, key)\n      code += `\n        json += ${funcName}(obj${accessor})\n      `\n      break\n    case undefined:\n      if ('anyOf' in schema) {\n        // beware: dereferenceOfRefs has side effects and changes schema.anyOf\n        const anyOfLocations = dereferenceOfRefs(location, 'anyOf')\n        anyOfLocations.forEach((location, index) => {\n          const nestedResult = nested(laterCode, name, key, location, subKey !== '' ? subKey : 'i' + index, isArray)\n          // We need a test serializer as the String serializer will not work with\n          // date/time ajv validations\n          // see: https://github.com/fastify/fast-json-stringify/issues/325\n          const testSerializer = getTestSerializer(location.schema.format)\n          const testValue = testSerializer !== undefined ? `${testSerializer}(obj${accessor}, true)` : `obj${accessor}`\n\n          // Since we are only passing the relevant schema to ajv.validate, it needs to be full dereferenced\n          // otherwise any $ref pointing to an external schema would result in an error.\n          // Full dereference of the schema happens as side effect of two functions:\n          // 1. `dereferenceOfRefs` loops through the `schema.anyOf`` array and replaces any top level reference\n          // with the actual schema\n          // 2. `nested`, through `buildCode`, replaces any reference in object properties with the actual schema\n          // (see https://github.com/fastify/fast-json-stringify/blob/6da3b3e8ac24b1ca5578223adedb4083b7adf8db/index.js#L631)\n          code += `\n            ${index === 0 ? 'if' : 'else if'}(ajv.validate(${JSON.stringify(location.schema)}, ${testValue}))\n              ${nestedResult.code}\n          `\n          laterCode = nestedResult.laterCode\n        })\n        code += `\n          else json+= null\n        `\n      } else if ('oneOf' in schema) {\n        // beware: dereferenceOfRefs has side effects and changes schema.oneOf\n        const oneOfLocations = dereferenceOfRefs(location, 'oneOf')\n        oneOfLocations.forEach((location, index) => {\n          const nestedResult = nested(laterCode, name, key, location, subKey !== '' ? subKey : 'i' + index, isArray)\n          const testSerializer = getTestSerializer(location.schema.format)\n          const testValue = testSerializer !== undefined ? `${testSerializer}(obj${accessor}, true)` : `obj${accessor}`\n          // see comment on anyOf about dereferencing the schema before calling ajv.validate\n          code += `\n            ${index === 0 ? 'if' : 'else if'}(ajv.validate(${JSON.stringify(location.schema)}, ${testValue}))\n              ${nestedResult.code}\n          `\n          laterCode = nestedResult.laterCode\n        })\n\n        if (!isArray) {\n          code += `\n            else json+= null\n          `\n        }\n      } else if (isEmpty(schema)) {\n        code += `\n          json += JSON.stringify(obj${accessor})\n        `\n      } else if ('const' in schema) {\n        code += `\n          if(ajv.validate(${JSON.stringify(schema)}, obj${accessor}))\n            json += '${JSON.stringify(schema.const)}'\n          else\n            throw new Error(\\`Item $\\{JSON.stringify(obj${accessor})} does not match schema definition.\\`)\n        `\n      } else if (schema.type === undefined) {\n        code += `\n          json += JSON.stringify(obj${accessor})\n        `\n      } else {\n        throw new Error(`${schema.type} unsupported`)\n      }\n      break\n    default:\n      if (Array.isArray(type)) {\n        const nullIndex = type.indexOf('null')\n        const sortedTypes = nullIndex !== -1 ? [type[nullIndex]].concat(type.slice(0, nullIndex)).concat(type.slice(nullIndex + 1)) : type\n        sortedTypes.forEach((type, index) => {\n          const statement = index === 0 ? 'if' : 'else if'\n          const tempSchema = Object.assign({}, schema, { type })\n          const nestedResult = nested(laterCode, name, key, mergeLocation(location, { schema: tempSchema }), subKey, isArray)\n          switch (type) {\n            case 'string': {\n              code += `\n                ${statement}(obj${accessor} === null || typeof obj${accessor} === \"${type}\" || obj${accessor} instanceof Date || typeof obj${accessor}.toISOString === \"function\" || obj${accessor} instanceof RegExp || (typeof obj${accessor} === \"object\" && Object.hasOwnProperty.call(obj${accessor}, \"toString\")))\n                  ${nestedResult.code}\n              `\n              break\n            }\n            case 'null': {\n              code += `\n                ${statement}(obj${accessor} == null)\n                  ${nestedResult.code}\n              `\n              break\n            }\n            case 'array': {\n              code += `\n                ${statement}(Array.isArray(obj${accessor}))\n                  ${nestedResult.code}\n              `\n              break\n            }\n            case 'integer': {\n              code += `\n                ${statement}(Number.isInteger(obj${accessor}) || obj${accessor} === null)\n                  ${nestedResult.code}\n              `\n              break\n            }\n            case 'number': {\n              code += `\n                ${statement}(isNaN(obj${accessor}) === false)\n                  ${nestedResult.code}\n              `\n              break\n            }\n            default: {\n              code += `\n                ${statement}(typeof obj${accessor} === \"${type}\")\n                  ${nestedResult.code}\n              `\n              break\n            }\n          }\n          laterCode = nestedResult.laterCode\n        })\n        code += `\n          else json+= null\n        `\n      } else {\n        throw new Error(`${type} unsupported`)\n      }\n  }\n\n  return {\n    code,\n    laterCode\n  }\n}\n\nfunction isEmpty (schema) {\n  // eslint-disable-next-line\n  for (var key in schema) {\n    if (schema.hasOwnProperty(key) && schema[key] !== undefined) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = build\n\nmodule.exports.restore = function (debugModeStr, options = {}) {\n  const dependencies = [debugModeStr]\n  const args = []\n  if (debugModeStr.startsWith('ajv')) {\n    dependencies.unshift('ajv')\n    args.push(new Ajv(options.ajv))\n  }\n\n  // eslint-disable-next-line\n  return (Function.apply(null, ['ajv', debugModeStr])\n    .apply(null, args))\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-json-stringify/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-json-stringify/schema-validator.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/fast-json-stringify/schema-validator.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file is autogenerated by build-schema-validator.js, do not edit\n\nfunction nop () { return true }\n\n'use strict';\nvar formats = __webpack_require__(/*! ajv/lib/compile/formats */ \"../../../node_modules/ajv/lib/compile/formats.js\")();\nvar equal = __webpack_require__(/*! ajv/lib/compile/equal */ \"../../../node_modules/ajv/lib/compile/equal.js\");\nvar validate = (function() {\n  var refVal = [];\n  var refVal1 = {\n    \"type\": \"integer\",\n    \"minimum\": 0\n  };\n  refVal[1] = refVal1;\n  var refVal2 = (function() {\n    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {\n      'use strict';\n      var vErrors = null;\n      var errors = 0;\n      var errs_1 = errors;\n      var errs_2 = errors;\n      if ((typeof data !== \"number\" || (data % 1) || data !== data)) {\n        validate.errors = [{\n          keyword: 'type',\n          dataPath: (dataPath || '') + \"\",\n          schemaPath: '#/definitions/nonNegativeInteger/type',\n          params: {\n            type: 'integer'\n          },\n          message: 'should be integer'\n        }];\n        return false;\n      }\n      if (typeof data === \"number\") {\n        if (data < 0 || data !== data) {\n          validate.errors = [{\n            keyword: 'minimum',\n            dataPath: (dataPath || '') + \"\",\n            schemaPath: '#/definitions/nonNegativeInteger/minimum',\n            params: {\n              comparison: '>=',\n              limit: 0,\n              exclusive: false\n            },\n            message: 'should be >= 0'\n          }];\n          return false;\n        }\n      }\n      var valid2 = errors === errs_2;\n      var valid1 = errors === errs_1;\n      validate.errors = vErrors;\n      return errors === 0;\n    };\n  })();\n  refVal2.schema = {\n    \"allOf\": [{\n      \"$ref\": \"#/definitions/nonNegativeInteger\"\n    }, {\n      \"default\": 0\n    }]\n  };\n  refVal2.errors = null;\n  refVal[2] = refVal2;\n  var refVal3 = (function() {\n    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {\n      'use strict';\n      var vErrors = null;\n      var errors = 0;\n      if (rootData === undefined) rootData = data;\n      if (Array.isArray(data)) {\n        if (data.length < 1) {\n          validate.errors = [{\n            keyword: 'minItems',\n            dataPath: (dataPath || '') + \"\",\n            schemaPath: '#/minItems',\n            params: {\n              limit: 1\n            },\n            message: 'should NOT have fewer than 1 items'\n          }];\n          return false;\n        } else {\n          var errs__0 = errors;\n          var valid0;\n          for (var i0 = 0; i0 < data.length; i0++) {\n            var errs_1 = errors;\n            if (!nop(data[i0], (dataPath || '') + '[' + i0 + ']', data, i0, rootData)) {\n              if (vErrors === null) vErrors = nop.errors;\n              else vErrors = vErrors.concat(nop.errors);\n              errors = vErrors.length;\n            }\n            var valid1 = errors === errs_1;\n            if (!valid1) break;\n          }\n        }\n      } else {\n        validate.errors = [{\n          keyword: 'type',\n          dataPath: (dataPath || '') + \"\",\n          schemaPath: '#/type',\n          params: {\n            type: 'array'\n          },\n          message: 'should be array'\n        }];\n        return false;\n      }\n      validate.errors = vErrors;\n      return errors === 0;\n    };\n  })();\n  refVal3.schema = {\n    \"type\": \"array\",\n    \"minItems\": 1,\n    \"items\": {\n      \"$ref\": \"#\"\n    }\n  };\n  refVal3.errors = null;\n  refVal[3] = refVal3;\n  var refVal4 = {\n    \"type\": \"array\",\n    \"items\": {\n      \"type\": \"string\"\n    },\n    \"uniqueItems\": true,\n    \"default\": []\n  };\n  refVal[4] = refVal4;\n  var refVal5 = {\n    \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n  };\n  refVal[5] = refVal5;\n  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {\n    'use strict'; /*# sourceURL=http://json-schema.org/draft-07/schema# */\n    var vErrors = null;\n    var errors = 0;\n    if (rootData === undefined) rootData = data;\n    if ((!data || typeof data !== \"object\" || Array.isArray(data)) && typeof data !== \"boolean\") {\n      validate.errors = [{\n        keyword: 'type',\n        dataPath: (dataPath || '') + \"\",\n        schemaPath: '#/type',\n        params: {\n          type: 'object,boolean'\n        },\n        message: 'should be object,boolean'\n      }];\n      return false;\n    }\n    if ((data && typeof data === \"object\" && !Array.isArray(data))) {\n      var errs__0 = errors;\n      var valid1 = true;\n      var data1 = data.$id;\n      if (data1 === undefined) {\n        valid1 = true;\n      } else {\n        var errs_1 = errors;\n        if (errors === errs_1) {\n          if (typeof data1 === \"string\") {\n            if (!formats['uri-reference'].test(data1)) {\n              validate.errors = [{\n                keyword: 'format',\n                dataPath: (dataPath || '') + '.$id',\n                schemaPath: '#/properties/%24id/format',\n                params: {\n                  format: 'uri-reference'\n                },\n                message: 'should match format \"uri-reference\"'\n              }];\n              return false;\n            }\n          } else {\n            validate.errors = [{\n              keyword: 'type',\n              dataPath: (dataPath || '') + '.$id',\n              schemaPath: '#/properties/%24id/type',\n              params: {\n                type: 'string'\n              },\n              message: 'should be string'\n            }];\n            return false;\n          }\n        }\n        var valid1 = errors === errs_1;\n      }\n      if (valid1) {\n        var data1 = data.$schema;\n        if (data1 === undefined) {\n          valid1 = true;\n        } else {\n          var errs_1 = errors;\n          if (errors === errs_1) {\n            if (typeof data1 === \"string\") {\n              if (!formats.uri.test(data1)) {\n                validate.errors = [{\n                  keyword: 'format',\n                  dataPath: (dataPath || '') + '.$schema',\n                  schemaPath: '#/properties/%24schema/format',\n                  params: {\n                    format: 'uri'\n                  },\n                  message: 'should match format \"uri\"'\n                }];\n                return false;\n              }\n            } else {\n              validate.errors = [{\n                keyword: 'type',\n                dataPath: (dataPath || '') + '.$schema',\n                schemaPath: '#/properties/%24schema/type',\n                params: {\n                  type: 'string'\n                },\n                message: 'should be string'\n              }];\n              return false;\n            }\n          }\n          var valid1 = errors === errs_1;\n        }\n        if (valid1) {\n          var data1 = data.$ref;\n          if (data1 === undefined) {\n            valid1 = true;\n          } else {\n            var errs_1 = errors;\n            if (errors === errs_1) {\n              if (typeof data1 === \"string\") {\n                if (!formats['uri-reference'].test(data1)) {\n                  validate.errors = [{\n                    keyword: 'format',\n                    dataPath: (dataPath || '') + '.$ref',\n                    schemaPath: '#/properties/%24ref/format',\n                    params: {\n                      format: 'uri-reference'\n                    },\n                    message: 'should match format \"uri-reference\"'\n                  }];\n                  return false;\n                }\n              } else {\n                validate.errors = [{\n                  keyword: 'type',\n                  dataPath: (dataPath || '') + '.$ref',\n                  schemaPath: '#/properties/%24ref/type',\n                  params: {\n                    type: 'string'\n                  },\n                  message: 'should be string'\n                }];\n                return false;\n              }\n            }\n            var valid1 = errors === errs_1;\n          }\n          if (valid1) {\n            if (data.$comment === undefined) {\n              valid1 = true;\n            } else {\n              var errs_1 = errors;\n              if (typeof data.$comment !== \"string\") {\n                validate.errors = [{\n                  keyword: 'type',\n                  dataPath: (dataPath || '') + '.$comment',\n                  schemaPath: '#/properties/%24comment/type',\n                  params: {\n                    type: 'string'\n                  },\n                  message: 'should be string'\n                }];\n                return false;\n              }\n              var valid1 = errors === errs_1;\n            }\n            if (valid1) {\n              if (data.title === undefined) {\n                valid1 = true;\n              } else {\n                var errs_1 = errors;\n                if (typeof data.title !== \"string\") {\n                  validate.errors = [{\n                    keyword: 'type',\n                    dataPath: (dataPath || '') + '.title',\n                    schemaPath: '#/properties/title/type',\n                    params: {\n                      type: 'string'\n                    },\n                    message: 'should be string'\n                  }];\n                  return false;\n                }\n                var valid1 = errors === errs_1;\n              }\n              if (valid1) {\n                if (data.description === undefined) {\n                  valid1 = true;\n                } else {\n                  var errs_1 = errors;\n                  if (typeof data.description !== \"string\") {\n                    validate.errors = [{\n                      keyword: 'type',\n                      dataPath: (dataPath || '') + '.description',\n                      schemaPath: '#/properties/description/type',\n                      params: {\n                        type: 'string'\n                      },\n                      message: 'should be string'\n                    }];\n                    return false;\n                  }\n                  var valid1 = errors === errs_1;\n                }\n                if (valid1) {\n                  if (valid1) {\n                    if (data.readOnly === undefined) {\n                      valid1 = true;\n                    } else {\n                      var errs_1 = errors;\n                      if (typeof data.readOnly !== \"boolean\") {\n                        validate.errors = [{\n                          keyword: 'type',\n                          dataPath: (dataPath || '') + '.readOnly',\n                          schemaPath: '#/properties/readOnly/type',\n                          params: {\n                            type: 'boolean'\n                          },\n                          message: 'should be boolean'\n                        }];\n                        return false;\n                      }\n                      var valid1 = errors === errs_1;\n                    }\n                    if (valid1) {\n                      if (data.examples === undefined) {\n                        valid1 = true;\n                      } else {\n                        var errs_1 = errors;\n                        if (Array.isArray(data.examples)) {\n                          var errs__1 = errors;\n                          var valid1;\n                        } else {\n                          validate.errors = [{\n                            keyword: 'type',\n                            dataPath: (dataPath || '') + '.examples',\n                            schemaPath: '#/properties/examples/type',\n                            params: {\n                              type: 'array'\n                            },\n                            message: 'should be array'\n                          }];\n                          return false;\n                        }\n                        var valid1 = errors === errs_1;\n                      }\n                      if (valid1) {\n                        var data1 = data.multipleOf;\n                        if (data1 === undefined) {\n                          valid1 = true;\n                        } else {\n                          var errs_1 = errors;\n                          if (typeof data1 === \"number\") {\n                            if (data1 <= 0 || data1 !== data1) {\n                              validate.errors = [{\n                                keyword: 'exclusiveMinimum',\n                                dataPath: (dataPath || '') + '.multipleOf',\n                                schemaPath: '#/properties/multipleOf/exclusiveMinimum',\n                                params: {\n                                  comparison: '>',\n                                  limit: 0,\n                                  exclusive: true\n                                },\n                                message: 'should be > 0'\n                              }];\n                              return false;\n                            }\n                          } else {\n                            validate.errors = [{\n                              keyword: 'type',\n                              dataPath: (dataPath || '') + '.multipleOf',\n                              schemaPath: '#/properties/multipleOf/type',\n                              params: {\n                                type: 'number'\n                              },\n                              message: 'should be number'\n                            }];\n                            return false;\n                          }\n                          var valid1 = errors === errs_1;\n                        }\n                        if (valid1) {\n                          if (data.maximum === undefined) {\n                            valid1 = true;\n                          } else {\n                            var errs_1 = errors;\n                            if (typeof data.maximum !== \"number\") {\n                              validate.errors = [{\n                                keyword: 'type',\n                                dataPath: (dataPath || '') + '.maximum',\n                                schemaPath: '#/properties/maximum/type',\n                                params: {\n                                  type: 'number'\n                                },\n                                message: 'should be number'\n                              }];\n                              return false;\n                            }\n                            var valid1 = errors === errs_1;\n                          }\n                          if (valid1) {\n                            if (data.exclusiveMaximum === undefined) {\n                              valid1 = true;\n                            } else {\n                              var errs_1 = errors;\n                              if (typeof data.exclusiveMaximum !== \"number\") {\n                                validate.errors = [{\n                                  keyword: 'type',\n                                  dataPath: (dataPath || '') + '.exclusiveMaximum',\n                                  schemaPath: '#/properties/exclusiveMaximum/type',\n                                  params: {\n                                    type: 'number'\n                                  },\n                                  message: 'should be number'\n                                }];\n                                return false;\n                              }\n                              var valid1 = errors === errs_1;\n                            }\n                            if (valid1) {\n                              if (data.minimum === undefined) {\n                                valid1 = true;\n                              } else {\n                                var errs_1 = errors;\n                                if (typeof data.minimum !== \"number\") {\n                                  validate.errors = [{\n                                    keyword: 'type',\n                                    dataPath: (dataPath || '') + '.minimum',\n                                    schemaPath: '#/properties/minimum/type',\n                                    params: {\n                                      type: 'number'\n                                    },\n                                    message: 'should be number'\n                                  }];\n                                  return false;\n                                }\n                                var valid1 = errors === errs_1;\n                              }\n                              if (valid1) {\n                                if (data.exclusiveMinimum === undefined) {\n                                  valid1 = true;\n                                } else {\n                                  var errs_1 = errors;\n                                  if (typeof data.exclusiveMinimum !== \"number\") {\n                                    validate.errors = [{\n                                      keyword: 'type',\n                                      dataPath: (dataPath || '') + '.exclusiveMinimum',\n                                      schemaPath: '#/properties/exclusiveMinimum/type',\n                                      params: {\n                                        type: 'number'\n                                      },\n                                      message: 'should be number'\n                                    }];\n                                    return false;\n                                  }\n                                  var valid1 = errors === errs_1;\n                                }\n                                if (valid1) {\n                                  var data1 = data.maxLength;\n                                  if (data1 === undefined) {\n                                    valid1 = true;\n                                  } else {\n                                    var errs_1 = errors;\n                                    var errs_2 = errors;\n                                    if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                      validate.errors = [{\n                                        keyword: 'type',\n                                        dataPath: (dataPath || '') + '.maxLength',\n                                        schemaPath: '#/definitions/nonNegativeInteger/type',\n                                        params: {\n                                          type: 'integer'\n                                        },\n                                        message: 'should be integer'\n                                      }];\n                                      return false;\n                                    }\n                                    if (typeof data1 === \"number\") {\n                                      if (data1 < 0 || data1 !== data1) {\n                                        validate.errors = [{\n                                          keyword: 'minimum',\n                                          dataPath: (dataPath || '') + '.maxLength',\n                                          schemaPath: '#/definitions/nonNegativeInteger/minimum',\n                                          params: {\n                                            comparison: '>=',\n                                            limit: 0,\n                                            exclusive: false\n                                          },\n                                          message: 'should be >= 0'\n                                        }];\n                                        return false;\n                                      }\n                                    }\n                                    var valid2 = errors === errs_2;\n                                    var valid1 = errors === errs_1;\n                                  }\n                                  if (valid1) {\n                                    if (data.minLength === undefined) {\n                                      valid1 = true;\n                                    } else {\n                                      var errs_1 = errors;\n                                      if (!refVal2(data.minLength, (dataPath || '') + '.minLength', data, 'minLength', rootData)) {\n                                        if (vErrors === null) vErrors = refVal2.errors;\n                                        else vErrors = vErrors.concat(refVal2.errors);\n                                        errors = vErrors.length;\n                                      }\n                                      var valid1 = errors === errs_1;\n                                    }\n                                    if (valid1) {\n                                      var data1 = data.pattern;\n                                      if (data1 === undefined) {\n                                        valid1 = true;\n                                      } else {\n                                        var errs_1 = errors;\n                                        if (errors === errs_1) {\n                                          if (typeof data1 === \"string\") {\n                                            if (!formats.regex(data1)) {\n                                              validate.errors = [{\n                                                keyword: 'format',\n                                                dataPath: (dataPath || '') + '.pattern',\n                                                schemaPath: '#/properties/pattern/format',\n                                                params: {\n                                                  format: 'regex'\n                                                },\n                                                message: 'should match format \"regex\"'\n                                              }];\n                                              return false;\n                                            }\n                                          } else {\n                                            validate.errors = [{\n                                              keyword: 'type',\n                                              dataPath: (dataPath || '') + '.pattern',\n                                              schemaPath: '#/properties/pattern/type',\n                                              params: {\n                                                type: 'string'\n                                              },\n                                              message: 'should be string'\n                                            }];\n                                            return false;\n                                          }\n                                        }\n                                        var valid1 = errors === errs_1;\n                                      }\n                                      if (valid1) {\n                                        if (data.additionalItems === undefined) {\n                                          valid1 = true;\n                                        } else {\n                                          var errs_1 = errors;\n                                          if (!validate(data.additionalItems, (dataPath || '') + '.additionalItems', data, 'additionalItems', rootData)) {\n                                            if (vErrors === null) vErrors = validate.errors;\n                                            else vErrors = vErrors.concat(validate.errors);\n                                            errors = vErrors.length;\n                                          }\n                                          var valid1 = errors === errs_1;\n                                        }\n                                        if (valid1) {\n                                          var data1 = data.items;\n                                          if (data1 === undefined) {\n                                            valid1 = true;\n                                          } else {\n                                            var errs_1 = errors;\n                                            var errs__1 = errors;\n                                            var valid1 = false;\n                                            var errs_2 = errors;\n                                            if (!validate(data1, (dataPath || '') + '.items', data, 'items', rootData)) {\n                                              if (vErrors === null) vErrors = validate.errors;\n                                              else vErrors = vErrors.concat(validate.errors);\n                                              errors = vErrors.length;\n                                            }\n                                            var valid2 = errors === errs_2;\n                                            valid1 = valid1 || valid2;\n                                            if (!valid1) {\n                                              var errs_2 = errors;\n                                              if (!refVal3(data1, (dataPath || '') + '.items', data, 'items', rootData)) {\n                                                if (vErrors === null) vErrors = refVal3.errors;\n                                                else vErrors = vErrors.concat(refVal3.errors);\n                                                errors = vErrors.length;\n                                              }\n                                              var valid2 = errors === errs_2;\n                                              valid1 = valid1 || valid2;\n                                            }\n                                            if (!valid1) {\n                                              var err = {\n                                                keyword: 'anyOf',\n                                                dataPath: (dataPath || '') + '.items',\n                                                schemaPath: '#/properties/items/anyOf',\n                                                params: {},\n                                                message: 'should match some schema in anyOf'\n                                              };\n                                              if (vErrors === null) vErrors = [err];\n                                              else vErrors.push(err);\n                                              errors++;\n                                              validate.errors = vErrors;\n                                              return false;\n                                            } else {\n                                              errors = errs__1;\n                                              if (vErrors !== null) {\n                                                if (errs__1) vErrors.length = errs__1;\n                                                else vErrors = null;\n                                              }\n                                            }\n                                            var valid1 = errors === errs_1;\n                                          }\n                                          if (valid1) {\n                                            var data1 = data.maxItems;\n                                            if (data1 === undefined) {\n                                              valid1 = true;\n                                            } else {\n                                              var errs_1 = errors;\n                                              var errs_2 = errors;\n                                              if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                                validate.errors = [{\n                                                  keyword: 'type',\n                                                  dataPath: (dataPath || '') + '.maxItems',\n                                                  schemaPath: '#/definitions/nonNegativeInteger/type',\n                                                  params: {\n                                                    type: 'integer'\n                                                  },\n                                                  message: 'should be integer'\n                                                }];\n                                                return false;\n                                              }\n                                              if (typeof data1 === \"number\") {\n                                                if (data1 < 0 || data1 !== data1) {\n                                                  validate.errors = [{\n                                                    keyword: 'minimum',\n                                                    dataPath: (dataPath || '') + '.maxItems',\n                                                    schemaPath: '#/definitions/nonNegativeInteger/minimum',\n                                                    params: {\n                                                      comparison: '>=',\n                                                      limit: 0,\n                                                      exclusive: false\n                                                    },\n                                                    message: 'should be >= 0'\n                                                  }];\n                                                  return false;\n                                                }\n                                              }\n                                              var valid2 = errors === errs_2;\n                                              var valid1 = errors === errs_1;\n                                            }\n                                            if (valid1) {\n                                              if (data.minItems === undefined) {\n                                                valid1 = true;\n                                              } else {\n                                                var errs_1 = errors;\n                                                if (!refVal[2](data.minItems, (dataPath || '') + '.minItems', data, 'minItems', rootData)) {\n                                                  if (vErrors === null) vErrors = refVal[2].errors;\n                                                  else vErrors = vErrors.concat(refVal[2].errors);\n                                                  errors = vErrors.length;\n                                                }\n                                                var valid1 = errors === errs_1;\n                                              }\n                                              if (valid1) {\n                                                if (data.uniqueItems === undefined) {\n                                                  valid1 = true;\n                                                } else {\n                                                  var errs_1 = errors;\n                                                  if (typeof data.uniqueItems !== \"boolean\") {\n                                                    validate.errors = [{\n                                                      keyword: 'type',\n                                                      dataPath: (dataPath || '') + '.uniqueItems',\n                                                      schemaPath: '#/properties/uniqueItems/type',\n                                                      params: {\n                                                        type: 'boolean'\n                                                      },\n                                                      message: 'should be boolean'\n                                                    }];\n                                                    return false;\n                                                  }\n                                                  var valid1 = errors === errs_1;\n                                                }\n                                                if (valid1) {\n                                                  if (data.contains === undefined) {\n                                                    valid1 = true;\n                                                  } else {\n                                                    var errs_1 = errors;\n                                                    if (!validate(data.contains, (dataPath || '') + '.contains', data, 'contains', rootData)) {\n                                                      if (vErrors === null) vErrors = validate.errors;\n                                                      else vErrors = vErrors.concat(validate.errors);\n                                                      errors = vErrors.length;\n                                                    }\n                                                    var valid1 = errors === errs_1;\n                                                  }\n                                                  if (valid1) {\n                                                    var data1 = data.maxProperties;\n                                                    if (data1 === undefined) {\n                                                      valid1 = true;\n                                                    } else {\n                                                      var errs_1 = errors;\n                                                      var errs_2 = errors;\n                                                      if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                                        validate.errors = [{\n                                                          keyword: 'type',\n                                                          dataPath: (dataPath || '') + '.maxProperties',\n                                                          schemaPath: '#/definitions/nonNegativeInteger/type',\n                                                          params: {\n                                                            type: 'integer'\n                                                          },\n                                                          message: 'should be integer'\n                                                        }];\n                                                        return false;\n                                                      }\n                                                      if (typeof data1 === \"number\") {\n                                                        if (data1 < 0 || data1 !== data1) {\n                                                          validate.errors = [{\n                                                            keyword: 'minimum',\n                                                            dataPath: (dataPath || '') + '.maxProperties',\n                                                            schemaPath: '#/definitions/nonNegativeInteger/minimum',\n                                                            params: {\n                                                              comparison: '>=',\n                                                              limit: 0,\n                                                              exclusive: false\n                                                            },\n                                                            message: 'should be >= 0'\n                                                          }];\n                                                          return false;\n                                                        }\n                                                      }\n                                                      var valid2 = errors === errs_2;\n                                                      var valid1 = errors === errs_1;\n                                                    }\n                                                    if (valid1) {\n                                                      if (data.minProperties === undefined) {\n                                                        valid1 = true;\n                                                      } else {\n                                                        var errs_1 = errors;\n                                                        if (!refVal[2](data.minProperties, (dataPath || '') + '.minProperties', data, 'minProperties', rootData)) {\n                                                          if (vErrors === null) vErrors = refVal[2].errors;\n                                                          else vErrors = vErrors.concat(refVal[2].errors);\n                                                          errors = vErrors.length;\n                                                        }\n                                                        var valid1 = errors === errs_1;\n                                                      }\n                                                      if (valid1) {\n                                                        var data1 = data.required;\n                                                        if (data1 === undefined) {\n                                                          valid1 = true;\n                                                        } else {\n                                                          var errs_1 = errors;\n                                                          var errs_2 = errors;\n                                                          if (Array.isArray(data1)) {\n                                                            var errs__2 = errors;\n                                                            var valid2;\n                                                            for (var i2 = 0; i2 < data1.length; i2++) {\n                                                              var errs_3 = errors;\n                                                              if (typeof data1[i2] !== \"string\") {\n                                                                validate.errors = [{\n                                                                  keyword: 'type',\n                                                                  dataPath: (dataPath || '') + '.required[' + i2 + ']',\n                                                                  schemaPath: '#/definitions/stringArray/items/type',\n                                                                  params: {\n                                                                    type: 'string'\n                                                                  },\n                                                                  message: 'should be string'\n                                                                }];\n                                                                return false;\n                                                              }\n                                                              var valid3 = errors === errs_3;\n                                                              if (!valid3) break;\n                                                            }\n                                                            if (errs__2 == errors) {\n                                                              var i = data1.length,\n                                                                valid2 = true,\n                                                                j;\n                                                              if (i > 1) {\n                                                                var itemIndices = {},\n                                                                  item;\n                                                                for (; i--;) {\n                                                                  var item = data1[i];\n                                                                  if (typeof item !== \"string\") continue;\n                                                                  if (typeof itemIndices[item] == 'number') {\n                                                                    valid2 = false;\n                                                                    j = itemIndices[item];\n                                                                    break;\n                                                                  }\n                                                                  itemIndices[item] = i;\n                                                                }\n                                                              }\n                                                              if (!valid2) {\n                                                                validate.errors = [{\n                                                                  keyword: 'uniqueItems',\n                                                                  dataPath: (dataPath || '') + '.required',\n                                                                  schemaPath: '#/definitions/stringArray/uniqueItems',\n                                                                  params: {\n                                                                    i: i,\n                                                                    j: j\n                                                                  },\n                                                                  message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'\n                                                                }];\n                                                                return false;\n                                                              }\n                                                            }\n                                                          } else {\n                                                            validate.errors = [{\n                                                              keyword: 'type',\n                                                              dataPath: (dataPath || '') + '.required',\n                                                              schemaPath: '#/definitions/stringArray/type',\n                                                              params: {\n                                                                type: 'array'\n                                                              },\n                                                              message: 'should be array'\n                                                            }];\n                                                            return false;\n                                                          }\n                                                          var valid2 = errors === errs_2;\n                                                          var valid1 = errors === errs_1;\n                                                        }\n                                                        if (valid1) {\n                                                          if (data.additionalProperties === undefined) {\n                                                            valid1 = true;\n                                                          } else {\n                                                            var errs_1 = errors;\n                                                            if (!validate(data.additionalProperties, (dataPath || '') + '.additionalProperties', data, 'additionalProperties', rootData)) {\n                                                              if (vErrors === null) vErrors = validate.errors;\n                                                              else vErrors = vErrors.concat(validate.errors);\n                                                              errors = vErrors.length;\n                                                            }\n                                                            var valid1 = errors === errs_1;\n                                                          }\n                                                          if (valid1) {\n                                                            var data1 = data.definitions;\n                                                            if (data1 === undefined) {\n                                                              valid1 = true;\n                                                            } else {\n                                                              var errs_1 = errors;\n                                                              if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                                var errs__1 = errors;\n                                                                var valid2 = true;\n                                                                for (var key1 in data1) {\n                                                                  var errs_2 = errors;\n                                                                  if (!validate(data1[key1], (dataPath || '') + '.definitions[\\'' + key1 + '\\']', data1, key1, rootData)) {\n                                                                    if (vErrors === null) vErrors = validate.errors;\n                                                                    else vErrors = vErrors.concat(validate.errors);\n                                                                    errors = vErrors.length;\n                                                                  }\n                                                                  var valid2 = errors === errs_2;\n                                                                  if (!valid2) break;\n                                                                }\n                                                              } else {\n                                                                validate.errors = [{\n                                                                  keyword: 'type',\n                                                                  dataPath: (dataPath || '') + '.definitions',\n                                                                  schemaPath: '#/properties/definitions/type',\n                                                                  params: {\n                                                                    type: 'object'\n                                                                  },\n                                                                  message: 'should be object'\n                                                                }];\n                                                                return false;\n                                                              }\n                                                              var valid1 = errors === errs_1;\n                                                            }\n                                                            if (valid1) {\n                                                              var data1 = data.properties;\n                                                              if (data1 === undefined) {\n                                                                valid1 = true;\n                                                              } else {\n                                                                var errs_1 = errors;\n                                                                if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                                  var errs__1 = errors;\n                                                                  var valid2 = true;\n                                                                  for (var key1 in data1) {\n                                                                    var errs_2 = errors;\n                                                                    if (!validate(data1[key1], (dataPath || '') + '.properties[\\'' + key1 + '\\']', data1, key1, rootData)) {\n                                                                      if (vErrors === null) vErrors = validate.errors;\n                                                                      else vErrors = vErrors.concat(validate.errors);\n                                                                      errors = vErrors.length;\n                                                                    }\n                                                                    var valid2 = errors === errs_2;\n                                                                    if (!valid2) break;\n                                                                  }\n                                                                } else {\n                                                                  validate.errors = [{\n                                                                    keyword: 'type',\n                                                                    dataPath: (dataPath || '') + '.properties',\n                                                                    schemaPath: '#/properties/properties/type',\n                                                                    params: {\n                                                                      type: 'object'\n                                                                    },\n                                                                    message: 'should be object'\n                                                                  }];\n                                                                  return false;\n                                                                }\n                                                                var valid1 = errors === errs_1;\n                                                              }\n                                                              if (valid1) {\n                                                                var data1 = data.patternProperties;\n                                                                if (data1 === undefined) {\n                                                                  valid1 = true;\n                                                                } else {\n                                                                  var errs_1 = errors;\n                                                                  if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                                    var errs__1 = errors;\n                                                                    for (var key1 in data1) {\n                                                                      var startErrs1 = errors;\n                                                                      var data2 = key1;\n                                                                      var errs_2 = errors;\n                                                                      if (errors === errs_2) {\n                                                                        if (typeof data2 === \"string\") {\n                                                                          if (!formats.regex(data2)) {\n                                                                            var err = {\n                                                                              keyword: 'format',\n                                                                              dataPath: (dataPath || '') + '.patternProperties',\n                                                                              schemaPath: '#/properties/patternProperties/propertyNames/format',\n                                                                              params: {\n                                                                                format: 'regex'\n                                                                              },\n                                                                              message: 'should match format \"regex\"'\n                                                                            };\n                                                                            if (vErrors === null) vErrors = [err];\n                                                                            else vErrors.push(err);\n                                                                            errors++;\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                      var valid2 = errors === errs_2;\n                                                                      if (!valid2) {\n                                                                        for (var i1 = startErrs1; i1 < errors; i1++) {\n                                                                          vErrors[i1].propertyName = key1;\n                                                                        }\n                                                                        var err = {\n                                                                          keyword: 'propertyNames',\n                                                                          dataPath: (dataPath || '') + '.patternProperties',\n                                                                          schemaPath: '#/properties/patternProperties/propertyNames',\n                                                                          params: {\n                                                                            propertyName: '' + key1 + ''\n                                                                          },\n                                                                          message: 'property name \\'' + key1 + '\\' is invalid'\n                                                                        };\n                                                                        if (vErrors === null) vErrors = [err];\n                                                                        else vErrors.push(err);\n                                                                        errors++;\n                                                                        validate.errors = vErrors;\n                                                                        return false;\n                                                                        break;\n                                                                      }\n                                                                    }\n                                                                    if (errs__1 == errors) {\n                                                                      var errs__1 = errors;\n                                                                      var valid2 = true;\n                                                                      for (var key1 in data1) {\n                                                                        var errs_2 = errors;\n                                                                        if (!validate(data1[key1], (dataPath || '') + '.patternProperties[\\'' + key1 + '\\']', data1, key1, rootData)) {\n                                                                          if (vErrors === null) vErrors = validate.errors;\n                                                                          else vErrors = vErrors.concat(validate.errors);\n                                                                          errors = vErrors.length;\n                                                                        }\n                                                                        var valid2 = errors === errs_2;\n                                                                        if (!valid2) break;\n                                                                      }\n                                                                    }\n                                                                  } else {\n                                                                    validate.errors = [{\n                                                                      keyword: 'type',\n                                                                      dataPath: (dataPath || '') + '.patternProperties',\n                                                                      schemaPath: '#/properties/patternProperties/type',\n                                                                      params: {\n                                                                        type: 'object'\n                                                                      },\n                                                                      message: 'should be object'\n                                                                    }];\n                                                                    return false;\n                                                                  }\n                                                                  var valid1 = errors === errs_1;\n                                                                }\n                                                                if (valid1) {\n                                                                  var data1 = data.dependencies;\n                                                                  if (data1 === undefined) {\n                                                                    valid1 = true;\n                                                                  } else {\n                                                                    var errs_1 = errors;\n                                                                    if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                                      var errs__1 = errors;\n                                                                      var valid2 = true;\n                                                                      for (var key1 in data1) {\n                                                                        var data2 = data1[key1];\n                                                                        var errs_2 = errors;\n                                                                        var errs__2 = errors;\n                                                                        var valid2 = false;\n                                                                        var errs_3 = errors;\n                                                                        if (!validate(data2, (dataPath || '') + '.dependencies[\\'' + key1 + '\\']', data1, key1, rootData)) {\n                                                                          if (vErrors === null) vErrors = validate.errors;\n                                                                          else vErrors = vErrors.concat(validate.errors);\n                                                                          errors = vErrors.length;\n                                                                        }\n                                                                        var valid3 = errors === errs_3;\n                                                                        valid2 = valid2 || valid3;\n                                                                        if (!valid2) {\n                                                                          var errs_3 = errors;\n                                                                          var errs_4 = errors;\n                                                                          if (Array.isArray(data2)) {\n                                                                            var errs__4 = errors;\n                                                                            var valid4;\n                                                                            for (var i4 = 0; i4 < data2.length; i4++) {\n                                                                              var errs_5 = errors;\n                                                                              if (typeof data2[i4] !== \"string\") {\n                                                                                var err = {\n                                                                                  keyword: 'type',\n                                                                                  dataPath: (dataPath || '') + '.dependencies[\\'' + key1 + '\\'][' + i4 + ']',\n                                                                                  schemaPath: '#/definitions/stringArray/items/type',\n                                                                                  params: {\n                                                                                    type: 'string'\n                                                                                  },\n                                                                                  message: 'should be string'\n                                                                                };\n                                                                                if (vErrors === null) vErrors = [err];\n                                                                                else vErrors.push(err);\n                                                                                errors++;\n                                                                              }\n                                                                              var valid5 = errors === errs_5;\n                                                                              if (!valid5) break;\n                                                                            }\n                                                                            if (errs__4 == errors) {\n                                                                              var i = data2.length,\n                                                                                valid4 = true,\n                                                                                j;\n                                                                              if (i > 1) {\n                                                                                var itemIndices = {},\n                                                                                  item;\n                                                                                for (; i--;) {\n                                                                                  var item = data2[i];\n                                                                                  if (typeof item !== \"string\") continue;\n                                                                                  if (typeof itemIndices[item] == 'number') {\n                                                                                    valid4 = false;\n                                                                                    j = itemIndices[item];\n                                                                                    break;\n                                                                                  }\n                                                                                  itemIndices[item] = i;\n                                                                                }\n                                                                              }\n                                                                              if (!valid4) {\n                                                                                var err = {\n                                                                                  keyword: 'uniqueItems',\n                                                                                  dataPath: (dataPath || '') + '.dependencies[\\'' + key1 + '\\']',\n                                                                                  schemaPath: '#/definitions/stringArray/uniqueItems',\n                                                                                  params: {\n                                                                                    i: i,\n                                                                                    j: j\n                                                                                  },\n                                                                                  message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'\n                                                                                };\n                                                                                if (vErrors === null) vErrors = [err];\n                                                                                else vErrors.push(err);\n                                                                                errors++;\n                                                                              }\n                                                                            }\n                                                                          } else {\n                                                                            var err = {\n                                                                              keyword: 'type',\n                                                                              dataPath: (dataPath || '') + '.dependencies[\\'' + key1 + '\\']',\n                                                                              schemaPath: '#/definitions/stringArray/type',\n                                                                              params: {\n                                                                                type: 'array'\n                                                                              },\n                                                                              message: 'should be array'\n                                                                            };\n                                                                            if (vErrors === null) vErrors = [err];\n                                                                            else vErrors.push(err);\n                                                                            errors++;\n                                                                          }\n                                                                          var valid4 = errors === errs_4;\n                                                                          var valid3 = errors === errs_3;\n                                                                          valid2 = valid2 || valid3;\n                                                                        }\n                                                                        if (!valid2) {\n                                                                          var err = {\n                                                                            keyword: 'anyOf',\n                                                                            dataPath: (dataPath || '') + '.dependencies[\\'' + key1 + '\\']',\n                                                                            schemaPath: '#/properties/dependencies/additionalProperties/anyOf',\n                                                                            params: {},\n                                                                            message: 'should match some schema in anyOf'\n                                                                          };\n                                                                          if (vErrors === null) vErrors = [err];\n                                                                          else vErrors.push(err);\n                                                                          errors++;\n                                                                          validate.errors = vErrors;\n                                                                          return false;\n                                                                        } else {\n                                                                          errors = errs__2;\n                                                                          if (vErrors !== null) {\n                                                                            if (errs__2) vErrors.length = errs__2;\n                                                                            else vErrors = null;\n                                                                          }\n                                                                        }\n                                                                        var valid2 = errors === errs_2;\n                                                                        if (!valid2) break;\n                                                                      }\n                                                                    } else {\n                                                                      validate.errors = [{\n                                                                        keyword: 'type',\n                                                                        dataPath: (dataPath || '') + '.dependencies',\n                                                                        schemaPath: '#/properties/dependencies/type',\n                                                                        params: {\n                                                                          type: 'object'\n                                                                        },\n                                                                        message: 'should be object'\n                                                                      }];\n                                                                      return false;\n                                                                    }\n                                                                    var valid1 = errors === errs_1;\n                                                                  }\n                                                                  if (valid1) {\n                                                                    if (data.propertyNames === undefined) {\n                                                                      valid1 = true;\n                                                                    } else {\n                                                                      var errs_1 = errors;\n                                                                      if (!validate(data.propertyNames, (dataPath || '') + '.propertyNames', data, 'propertyNames', rootData)) {\n                                                                        if (vErrors === null) vErrors = validate.errors;\n                                                                        else vErrors = vErrors.concat(validate.errors);\n                                                                        errors = vErrors.length;\n                                                                      }\n                                                                      var valid1 = errors === errs_1;\n                                                                    }\n                                                                    if (valid1) {\n                                                                      if (valid1) {\n                                                                        var data1 = data.enum;\n                                                                        if (data1 === undefined) {\n                                                                          valid1 = true;\n                                                                        } else {\n                                                                          var errs_1 = errors;\n                                                                          if (Array.isArray(data1)) {\n                                                                            if (data1.length < 1) {\n                                                                              validate.errors = [{\n                                                                                keyword: 'minItems',\n                                                                                dataPath: (dataPath || '') + '.enum',\n                                                                                schemaPath: '#/properties/enum/minItems',\n                                                                                params: {\n                                                                                  limit: 1\n                                                                                },\n                                                                                message: 'should NOT have fewer than 1 items'\n                                                                              }];\n                                                                              return false;\n                                                                            } else {\n                                                                              var errs__1 = errors;\n                                                                              var valid1;\n                                                                              if (errs__1 == errors) {\n                                                                                var i = data1.length,\n                                                                                  valid1 = true,\n                                                                                  j;\n                                                                                if (i > 1) {\n                                                                                  outer: for (; i--;) {\n                                                                                    for (j = i; j--;) {\n                                                                                      if (equal(data1[i], data1[j])) {\n                                                                                        valid1 = false;\n                                                                                        break outer;\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                                if (!valid1) {\n                                                                                  validate.errors = [{\n                                                                                    keyword: 'uniqueItems',\n                                                                                    dataPath: (dataPath || '') + '.enum',\n                                                                                    schemaPath: '#/properties/enum/uniqueItems',\n                                                                                    params: {\n                                                                                      i: i,\n                                                                                      j: j\n                                                                                    },\n                                                                                    message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'\n                                                                                  }];\n                                                                                  return false;\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          } else {\n                                                                            validate.errors = [{\n                                                                              keyword: 'type',\n                                                                              dataPath: (dataPath || '') + '.enum',\n                                                                              schemaPath: '#/properties/enum/type',\n                                                                              params: {\n                                                                                type: 'array'\n                                                                              },\n                                                                              message: 'should be array'\n                                                                            }];\n                                                                            return false;\n                                                                          }\n                                                                          var valid1 = errors === errs_1;\n                                                                        }\n                                                                        if (valid1) {\n                                                                          var data1 = data.type;\n                                                                          if (data1 === undefined) {\n                                                                            valid1 = true;\n                                                                          } else {\n                                                                            var errs_1 = errors;\n                                                                            var errs__1 = errors;\n                                                                            var valid1 = false;\n                                                                            var errs_2 = errors;\n                                                                            var errs_3 = errors;\n                                                                            var schema3 = refVal5.enum;\n                                                                            var valid3;\n                                                                            valid3 = false;\n                                                                            for (var i3 = 0; i3 < schema3.length; i3++)\n                                                                              if (equal(data1, schema3[i3])) {\n                                                                                valid3 = true;\n                                                                                break;\n                                                                              } if (!valid3) {\n                                                                              var err = {\n                                                                                keyword: 'enum',\n                                                                                dataPath: (dataPath || '') + '.type',\n                                                                                schemaPath: '#/definitions/simpleTypes/enum',\n                                                                                params: {\n                                                                                  allowedValues: schema3\n                                                                                },\n                                                                                message: 'should be equal to one of the allowed values'\n                                                                              };\n                                                                              if (vErrors === null) vErrors = [err];\n                                                                              else vErrors.push(err);\n                                                                              errors++;\n                                                                            }\n                                                                            var valid3 = errors === errs_3;\n                                                                            var valid2 = errors === errs_2;\n                                                                            valid1 = valid1 || valid2;\n                                                                            if (!valid1) {\n                                                                              var errs_2 = errors;\n                                                                              if (Array.isArray(data1)) {\n                                                                                if (data1.length < 1) {\n                                                                                  var err = {\n                                                                                    keyword: 'minItems',\n                                                                                    dataPath: (dataPath || '') + '.type',\n                                                                                    schemaPath: '#/properties/type/anyOf/1/minItems',\n                                                                                    params: {\n                                                                                      limit: 1\n                                                                                    },\n                                                                                    message: 'should NOT have fewer than 1 items'\n                                                                                  };\n                                                                                  if (vErrors === null) vErrors = [err];\n                                                                                  else vErrors.push(err);\n                                                                                  errors++;\n                                                                                } else {\n                                                                                  var errs__2 = errors;\n                                                                                  var valid2;\n                                                                                  for (var i2 = 0; i2 < data1.length; i2++) {\n                                                                                    var errs_3 = errors;\n                                                                                    var errs_4 = errors;\n                                                                                    var schema4 = refVal[5].enum;\n                                                                                    var valid4;\n                                                                                    valid4 = false;\n                                                                                    for (var i4 = 0; i4 < schema4.length; i4++)\n                                                                                      if (equal(data1[i2], schema4[i4])) {\n                                                                                        valid4 = true;\n                                                                                        break;\n                                                                                      } if (!valid4) {\n                                                                                      var err = {\n                                                                                        keyword: 'enum',\n                                                                                        dataPath: (dataPath || '') + '.type[' + i2 + ']',\n                                                                                        schemaPath: '#/definitions/simpleTypes/enum',\n                                                                                        params: {\n                                                                                          allowedValues: schema4\n                                                                                        },\n                                                                                        message: 'should be equal to one of the allowed values'\n                                                                                      };\n                                                                                      if (vErrors === null) vErrors = [err];\n                                                                                      else vErrors.push(err);\n                                                                                      errors++;\n                                                                                    }\n                                                                                    var valid4 = errors === errs_4;\n                                                                                    var valid3 = errors === errs_3;\n                                                                                    if (!valid3) break;\n                                                                                  }\n                                                                                  if (errs__2 == errors) {\n                                                                                    var i = data1.length,\n                                                                                      valid2 = true,\n                                                                                      j;\n                                                                                    if (i > 1) {\n                                                                                      outer: for (; i--;) {\n                                                                                        for (j = i; j--;) {\n                                                                                          if (equal(data1[i], data1[j])) {\n                                                                                            valid2 = false;\n                                                                                            break outer;\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                    if (!valid2) {\n                                                                                      var err = {\n                                                                                        keyword: 'uniqueItems',\n                                                                                        dataPath: (dataPath || '') + '.type',\n                                                                                        schemaPath: '#/properties/type/anyOf/1/uniqueItems',\n                                                                                        params: {\n                                                                                          i: i,\n                                                                                          j: j\n                                                                                        },\n                                                                                        message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)'\n                                                                                      };\n                                                                                      if (vErrors === null) vErrors = [err];\n                                                                                      else vErrors.push(err);\n                                                                                      errors++;\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              } else {\n                                                                                var err = {\n                                                                                  keyword: 'type',\n                                                                                  dataPath: (dataPath || '') + '.type',\n                                                                                  schemaPath: '#/properties/type/anyOf/1/type',\n                                                                                  params: {\n                                                                                    type: 'array'\n                                                                                  },\n                                                                                  message: 'should be array'\n                                                                                };\n                                                                                if (vErrors === null) vErrors = [err];\n                                                                                else vErrors.push(err);\n                                                                                errors++;\n                                                                              }\n                                                                              var valid2 = errors === errs_2;\n                                                                              valid1 = valid1 || valid2;\n                                                                            }\n                                                                            if (!valid1) {\n                                                                              var err = {\n                                                                                keyword: 'anyOf',\n                                                                                dataPath: (dataPath || '') + '.type',\n                                                                                schemaPath: '#/properties/type/anyOf',\n                                                                                params: {},\n                                                                                message: 'should match some schema in anyOf'\n                                                                              };\n                                                                              if (vErrors === null) vErrors = [err];\n                                                                              else vErrors.push(err);\n                                                                              errors++;\n                                                                              validate.errors = vErrors;\n                                                                              return false;\n                                                                            } else {\n                                                                              errors = errs__1;\n                                                                              if (vErrors !== null) {\n                                                                                if (errs__1) vErrors.length = errs__1;\n                                                                                else vErrors = null;\n                                                                              }\n                                                                            }\n                                                                            var valid1 = errors === errs_1;\n                                                                          }\n                                                                          if (valid1) {\n                                                                            if (data.format === undefined) {\n                                                                              valid1 = true;\n                                                                            } else {\n                                                                              var errs_1 = errors;\n                                                                              if (typeof data.format !== \"string\") {\n                                                                                validate.errors = [{\n                                                                                  keyword: 'type',\n                                                                                  dataPath: (dataPath || '') + '.format',\n                                                                                  schemaPath: '#/properties/format/type',\n                                                                                  params: {\n                                                                                    type: 'string'\n                                                                                  },\n                                                                                  message: 'should be string'\n                                                                                }];\n                                                                                return false;\n                                                                              }\n                                                                              var valid1 = errors === errs_1;\n                                                                            }\n                                                                            if (valid1) {\n                                                                              if (data.contentMediaType === undefined) {\n                                                                                valid1 = true;\n                                                                              } else {\n                                                                                var errs_1 = errors;\n                                                                                if (typeof data.contentMediaType !== \"string\") {\n                                                                                  validate.errors = [{\n                                                                                    keyword: 'type',\n                                                                                    dataPath: (dataPath || '') + '.contentMediaType',\n                                                                                    schemaPath: '#/properties/contentMediaType/type',\n                                                                                    params: {\n                                                                                      type: 'string'\n                                                                                    },\n                                                                                    message: 'should be string'\n                                                                                  }];\n                                                                                  return false;\n                                                                                }\n                                                                                var valid1 = errors === errs_1;\n                                                                              }\n                                                                              if (valid1) {\n                                                                                if (data.contentEncoding === undefined) {\n                                                                                  valid1 = true;\n                                                                                } else {\n                                                                                  var errs_1 = errors;\n                                                                                  if (typeof data.contentEncoding !== \"string\") {\n                                                                                    validate.errors = [{\n                                                                                      keyword: 'type',\n                                                                                      dataPath: (dataPath || '') + '.contentEncoding',\n                                                                                      schemaPath: '#/properties/contentEncoding/type',\n                                                                                      params: {\n                                                                                        type: 'string'\n                                                                                      },\n                                                                                      message: 'should be string'\n                                                                                    }];\n                                                                                    return false;\n                                                                                  }\n                                                                                  var valid1 = errors === errs_1;\n                                                                                }\n                                                                                if (valid1) {\n                                                                                  if (data.if === undefined) {\n                                                                                    valid1 = true;\n                                                                                  } else {\n                                                                                    var errs_1 = errors;\n                                                                                    if (!validate(data.if, (dataPath || '') + '.if', data, 'if', rootData)) {\n                                                                                      if (vErrors === null) vErrors = validate.errors;\n                                                                                      else vErrors = vErrors.concat(validate.errors);\n                                                                                      errors = vErrors.length;\n                                                                                    }\n                                                                                    var valid1 = errors === errs_1;\n                                                                                  }\n                                                                                  if (valid1) {\n                                                                                    if (data.then === undefined) {\n                                                                                      valid1 = true;\n                                                                                    } else {\n                                                                                      var errs_1 = errors;\n                                                                                      if (!validate(data.then, (dataPath || '') + '.then', data, 'then', rootData)) {\n                                                                                        if (vErrors === null) vErrors = validate.errors;\n                                                                                        else vErrors = vErrors.concat(validate.errors);\n                                                                                        errors = vErrors.length;\n                                                                                      }\n                                                                                      var valid1 = errors === errs_1;\n                                                                                    }\n                                                                                    if (valid1) {\n                                                                                      if (data.else === undefined) {\n                                                                                        valid1 = true;\n                                                                                      } else {\n                                                                                        var errs_1 = errors;\n                                                                                        if (!validate(data.else, (dataPath || '') + '.else', data, 'else', rootData)) {\n                                                                                          if (vErrors === null) vErrors = validate.errors;\n                                                                                          else vErrors = vErrors.concat(validate.errors);\n                                                                                          errors = vErrors.length;\n                                                                                        }\n                                                                                        var valid1 = errors === errs_1;\n                                                                                      }\n                                                                                      if (valid1) {\n                                                                                        if (data.allOf === undefined) {\n                                                                                          valid1 = true;\n                                                                                        } else {\n                                                                                          var errs_1 = errors;\n                                                                                          if (!refVal[3](data.allOf, (dataPath || '') + '.allOf', data, 'allOf', rootData)) {\n                                                                                            if (vErrors === null) vErrors = refVal[3].errors;\n                                                                                            else vErrors = vErrors.concat(refVal[3].errors);\n                                                                                            errors = vErrors.length;\n                                                                                          }\n                                                                                          var valid1 = errors === errs_1;\n                                                                                        }\n                                                                                        if (valid1) {\n                                                                                          if (data.anyOf === undefined) {\n                                                                                            valid1 = true;\n                                                                                          } else {\n                                                                                            var errs_1 = errors;\n                                                                                            if (!refVal[3](data.anyOf, (dataPath || '') + '.anyOf', data, 'anyOf', rootData)) {\n                                                                                              if (vErrors === null) vErrors = refVal[3].errors;\n                                                                                              else vErrors = vErrors.concat(refVal[3].errors);\n                                                                                              errors = vErrors.length;\n                                                                                            }\n                                                                                            var valid1 = errors === errs_1;\n                                                                                          }\n                                                                                          if (valid1) {\n                                                                                            if (data.oneOf === undefined) {\n                                                                                              valid1 = true;\n                                                                                            } else {\n                                                                                              var errs_1 = errors;\n                                                                                              if (!refVal[3](data.oneOf, (dataPath || '') + '.oneOf', data, 'oneOf', rootData)) {\n                                                                                                if (vErrors === null) vErrors = refVal[3].errors;\n                                                                                                else vErrors = vErrors.concat(refVal[3].errors);\n                                                                                                errors = vErrors.length;\n                                                                                              }\n                                                                                              var valid1 = errors === errs_1;\n                                                                                            }\n                                                                                            if (valid1) {\n                                                                                              if (data.not === undefined) {\n                                                                                                valid1 = true;\n                                                                                              } else {\n                                                                                                var errs_1 = errors;\n                                                                                                if (!validate(data.not, (dataPath || '') + '.not', data, 'not', rootData)) {\n                                                                                                  if (vErrors === null) vErrors = validate.errors;\n                                                                                                  else vErrors = vErrors.concat(validate.errors);\n                                                                                                  errors = vErrors.length;\n                                                                                                }\n                                                                                                var valid1 = errors === errs_1;\n                                                                                              }\n                                                                                            }\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    validate.errors = vErrors;\n    return errors === 0;\n  };\n})();\nvalidate.schema = {\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\n        \"$ref\": \"#\"\n      }\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\n        \"$ref\": \"#/definitions/nonNegativeInteger\"\n      }, {\n        \"default\": 0\n      }]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\n      \"$ref\": \"#/definitions/nonNegativeInteger\"\n    },\n    \"minLength\": {\n      \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"\n    },\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\n      \"$ref\": \"#\"\n    },\n    \"items\": {\n      \"anyOf\": [{\n        \"$ref\": \"#\"\n      }, {\n        \"$ref\": \"#/definitions/schemaArray\"\n      }],\n      \"default\": true\n    },\n    \"maxItems\": {\n      \"$ref\": \"#/definitions/nonNegativeInteger\"\n    },\n    \"minItems\": {\n      \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"\n    },\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\n      \"$ref\": \"#\"\n    },\n    \"maxProperties\": {\n      \"$ref\": \"#/definitions/nonNegativeInteger\"\n    },\n    \"minProperties\": {\n      \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"\n    },\n    \"required\": {\n      \"$ref\": \"#/definitions/stringArray\"\n    },\n    \"additionalProperties\": {\n      \"$ref\": \"#\"\n    },\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#\"\n      },\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#\"\n      },\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#\"\n      },\n      \"propertyNames\": {\n        \"format\": \"regex\"\n      },\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\n          \"$ref\": \"#\"\n        }, {\n          \"$ref\": \"#/definitions/stringArray\"\n        }]\n      }\n    },\n    \"propertyNames\": {\n      \"$ref\": \"#\"\n    },\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [{\n        \"$ref\": \"#/definitions/simpleTypes\"\n      }, {\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/definitions/simpleTypes\"\n        },\n        \"minItems\": 1,\n        \"uniqueItems\": true\n      }]\n    },\n    \"format\": {\n      \"type\": \"string\"\n    },\n    \"contentMediaType\": {\n      \"type\": \"string\"\n    },\n    \"contentEncoding\": {\n      \"type\": \"string\"\n    },\n    \"if\": {\n      \"$ref\": \"#\"\n    },\n    \"then\": {\n      \"$ref\": \"#\"\n    },\n    \"else\": {\n      \"$ref\": \"#\"\n    },\n    \"allOf\": {\n      \"$ref\": \"#/definitions/schemaArray\"\n    },\n    \"anyOf\": {\n      \"$ref\": \"#/definitions/schemaArray\"\n    },\n    \"oneOf\": {\n      \"$ref\": \"#/definitions/schemaArray\"\n    },\n    \"not\": {\n      \"$ref\": \"#\"\n    }\n  },\n  \"default\": true\n};\nvalidate.errors = null;\nmodule.exports = validate;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-json-stringify/schema-validator.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fast-redact/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst validator = __webpack_require__(/*! ./lib/validator */ \"../../../node_modules/fast-redact/lib/validator.js\")\nconst parse = __webpack_require__(/*! ./lib/parse */ \"../../../node_modules/fast-redact/lib/parse.js\")\nconst redactor = __webpack_require__(/*! ./lib/redactor */ \"../../../node_modules/fast-redact/lib/redactor.js\")\nconst restorer = __webpack_require__(/*! ./lib/restorer */ \"../../../node_modules/fast-redact/lib/restorer.js\")\nconst { groupRedact, nestedRedact } = __webpack_require__(/*! ./lib/modifiers */ \"../../../node_modules/fast-redact/lib/modifiers.js\")\nconst state = __webpack_require__(/*! ./lib/state */ \"../../../node_modules/fast-redact/lib/state.js\")\nconst rx = __webpack_require__(/*! ./lib/rx */ \"../../../node_modules/fast-redact/lib/rx.js\")\nconst validate = validator()\nconst noop = (o) => o\nnoop.restore = noop\n\nconst DEFAULT_CENSOR = '[REDACTED]'\nfastRedact.rx = rx\nfastRedact.validator = validator\n\nmodule.exports = fastRedact\n\nfunction fastRedact (opts = {}) {\n  const paths = Array.from(new Set(opts.paths || []))\n  const serialize = 'serialize' in opts ? (\n    opts.serialize === false ? opts.serialize\n      : (typeof opts.serialize === 'function' ? opts.serialize : JSON.stringify)\n  ) : JSON.stringify\n  const remove = opts.remove\n  if (remove === true && serialize !== JSON.stringify) {\n    throw Error('fast-redact – remove option may only be set when serializer is JSON.stringify')\n  }\n  const censor = remove === true\n    ? undefined\n    : 'censor' in opts ? opts.censor : DEFAULT_CENSOR\n\n  const isCensorFct = typeof censor === 'function'\n  const censorFctTakesPath = isCensorFct && censor.length > 1\n\n  if (paths.length === 0) return serialize || noop\n\n  validate({ paths, serialize, censor })\n\n  const { wildcards, wcLen, secret } = parse({ paths, censor })\n\n  const compileRestore = restorer({ secret, wcLen })\n  const strict = 'strict' in opts ? opts.strict : true\n\n  return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({\n    secret,\n    censor,\n    compileRestore,\n    serialize,\n    groupRedact,\n    nestedRedact,\n    wildcards,\n    wcLen\n  }))\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/index.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/modifiers.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/modifiers.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  groupRedact,\n  groupRestore,\n  nestedRedact,\n  nestedRestore\n}\n\nfunction groupRestore ({ keys, values, target }) {\n  if (target == null) return\n  const length = keys.length\n  for (var i = 0; i < length; i++) {\n    const k = keys[i]\n    target[k] = values[i]\n  }\n}\n\nfunction groupRedact (o, path, censor, isCensorFct, censorFctTakesPath) {\n  const target = get(o, path)\n  if (target == null) return { keys: null, values: null, target: null, flat: true }\n  const keys = Object.keys(target)\n  const keysLength = keys.length\n  const pathLength = path.length\n  const pathWithKey = censorFctTakesPath ? [...path] : undefined\n  const values = new Array(keysLength)\n\n  for (var i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    values[i] = target[key]\n\n    if (censorFctTakesPath) {\n      pathWithKey[pathLength] = key\n      target[key] = censor(target[key], pathWithKey)\n    } else if (isCensorFct) {\n      target[key] = censor(target[key])\n    } else {\n      target[key] = censor\n    }\n  }\n  return { keys, values, target, flat: true }\n}\n\nfunction nestedRestore (arr) {\n  const length = arr.length\n  for (var i = 0; i < length; i++) {\n    const { key, target, value } = arr[i]\n    if (has(target, key)) {\n      target[key] = value\n    }\n    /* istanbul ignore else */\n    if (typeof target === 'object') {\n      const targetKeys = Object.keys(target)\n      for (var j = 0; j < targetKeys.length; j++) {\n        const tKey = targetKeys[j]\n        const subTarget = target[tKey]\n        if (has(subTarget, key)) {\n          subTarget[key] = value\n        }\n      }\n    }\n  }\n}\n\nfunction nestedRedact (store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {\n  const target = get(o, path)\n  if (target == null) return\n  const keys = Object.keys(target)\n  const keysLength = keys.length\n  for (var i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    const { value, parent, exists } =\n      specialSet(target, key, path, ns, censor, isCensorFct, censorFctTakesPath)\n\n    if (exists === true && parent !== null) {\n      store.push({ key: ns[ns.length - 1], target: parent, value })\n    }\n  }\n  return store\n}\n\nfunction has (obj, prop) {\n  return obj !== undefined && obj !== null\n    ? ('hasOwn' in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop))\n    : false\n}\n\nfunction specialSet (o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {\n  const afterPathLen = afterPath.length\n  const lastPathIndex = afterPathLen - 1\n  const originalKey = k\n  var i = -1\n  var n\n  var nv\n  var ov\n  var oov = null\n  var exists = true\n  var wc = null\n  ov = n = o[k]\n  if (typeof n !== 'object') return { value: null, parent: null, exists }\n  while (n != null && ++i < afterPathLen) {\n    k = afterPath[i]\n    oov = ov\n    if (k !== '*' && !wc && !(typeof n === 'object' && k in n)) {\n      exists = false\n      break\n    }\n    if (k === '*') {\n      wc = k\n      if (i !== lastPathIndex) {\n        continue\n      }\n    }\n    if (wc) {\n      const wcKeys = Object.keys(n)\n      for (var j = 0; j < wcKeys.length; j++) {\n        const wck = wcKeys[j]\n        const wcov = n[wck]\n        const kIsWc = k === '*'\n        if (kIsWc || (typeof wcov === 'object' && k in wcov)) {\n          if (kIsWc) {\n            ov = wcov\n          } else {\n            ov = wcov[k]\n          }\n          nv = (i !== lastPathIndex)\n            ? ov\n            : (isCensorFct\n              ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))\n              : censor)\n          if (kIsWc) {\n            n[wck] = nv\n          } else {\n            wcov[k] = (nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov) ? wcov[k] : nv\n          }\n        }\n      }\n      wc = null\n    } else {\n      ov = n[k]\n      nv = (i !== lastPathIndex)\n        ? ov\n        : (isCensorFct\n          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))\n          : censor)\n      n[k] = (has(n, k) && nv === ov) || (nv === undefined && censor !== undefined) ? n[k] : nv\n      n = n[k]\n    }\n    if (typeof n !== 'object') break\n  }\n  return { value: ov, parent: oov, exists }\n}\n\nfunction get (o, p) {\n  var i = -1\n  var l = p.length\n  var n = o\n  while (n != null && ++i < l) {\n    n = n[p[i]]\n  }\n  return n\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/modifiers.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/parse.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst rx = __webpack_require__(/*! ./rx */ \"../../../node_modules/fast-redact/lib/rx.js\")\n\nmodule.exports = parse\n\nfunction parse ({ paths }) {\n  const wildcards = []\n  var wcLen = 0\n  const secret = paths.reduce(function (o, strPath, ix) {\n    var path = strPath.match(rx).map((p) => p.replace(/'|\"|`/g, ''))\n    const leadingBracket = strPath[0] === '['\n    path = path.map((p) => {\n      if (p[0] === '[') return p.substr(1, p.length - 2)\n      else return p\n    })\n    const star = path.indexOf('*')\n    if (star > -1) {\n      const before = path.slice(0, star)\n      const beforeStr = before.join('.')\n      const after = path.slice(star + 1, path.length)\n      const nested = after.length > 0\n      wcLen++\n      wildcards.push({\n        before,\n        beforeStr,\n        after,\n        nested\n      })\n    } else {\n      o[strPath] = {\n        path: path,\n        val: undefined,\n        precensored: false,\n        circle: '',\n        escPath: JSON.stringify(strPath),\n        leadingBracket: leadingBracket\n      }\n    }\n    return o\n  }, {})\n\n  return { wildcards, wcLen, secret }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/parse.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/redactor.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/redactor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst rx = __webpack_require__(/*! ./rx */ \"../../../node_modules/fast-redact/lib/rx.js\")\n\nmodule.exports = redactor\n\nfunction redactor ({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {\n  /* eslint-disable-next-line */\n  const redact = Function('o', `\n    if (typeof o !== 'object' || o == null) {\n      ${strictImpl(strict, serialize)}\n    }\n    const { censor, secret } = this\n    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}\n    this.compileRestore()\n    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}\n    ${resultTmpl(serialize)}\n  `).bind(state)\n\n  if (serialize === false) {\n    redact.restore = (o) => state.restore(o)\n  }\n\n  return redact\n}\n\nfunction redactTmpl (secret, isCensorFct, censorFctTakesPath) {\n  return Object.keys(secret).map((path) => {\n    const { escPath, leadingBracket, path: arrPath } = secret[path]\n    const skip = leadingBracket ? 1 : 0\n    const delim = leadingBracket ? '' : '.'\n    const hops = []\n    var match\n    while ((match = rx.exec(path)) !== null) {\n      const [ , ix ] = match\n      const { index, input } = match\n      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)))\n    }\n    var existence = hops.map((p) => `o${delim}${p}`).join(' && ')\n    if (existence.length === 0) existence += `o${delim}${path} != null`\n    else existence += ` && o${delim}${path} != null`\n\n    const circularDetection = `\n      switch (true) {\n        ${hops.reverse().map((p) => `\n          case o${delim}${p} === censor:\n            secret[${escPath}].circle = ${JSON.stringify(p)}\n            break\n        `).join('\\n')}\n      }\n    `\n\n    const censorArgs = censorFctTakesPath\n      ? `val, ${JSON.stringify(arrPath)}`\n      : `val`\n\n    return `\n      if (${existence}) {\n        const val = o${delim}${path}\n        if (val === censor) {\n          secret[${escPath}].precensored = true\n        } else {\n          secret[${escPath}].val = val\n          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : 'censor'}\n          ${circularDetection}\n        }\n      }\n    `\n  }).join('\\n')\n}\n\nfunction dynamicRedactTmpl (hasWildcards, isCensorFct, censorFctTakesPath) {\n  return hasWildcards === true ? `\n    {\n      const { wildcards, wcLen, groupRedact, nestedRedact } = this\n      for (var i = 0; i < wcLen; i++) {\n        const { before, beforeStr, after, nested } = wildcards[i]\n        if (nested === true) {\n          secret[beforeStr] = secret[beforeStr] || []\n          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})\n        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})\n      }\n    }\n  ` : ''\n}\n\nfunction resultTmpl (serialize) {\n  return serialize === false ? `return o` : `\n    var s = this.serialize(o)\n    this.restore(o)\n    return s\n  `\n}\n\nfunction strictImpl (strict, serialize) {\n  return strict === true\n    ? `throw Error('fast-redact: primitives cannot be redacted')`\n    : serialize === false ? `return o` : `return this.serialize(o)`\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/redactor.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/restorer.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/restorer.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { groupRestore, nestedRestore } = __webpack_require__(/*! ./modifiers */ \"../../../node_modules/fast-redact/lib/modifiers.js\")\n\nmodule.exports = restorer\n\nfunction restorer ({ secret, wcLen }) {\n  return function compileRestore () {\n    if (this.restore) return\n    const paths = Object.keys(secret)\n    const resetters = resetTmpl(secret, paths)\n    const hasWildcards = wcLen > 0\n    const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret }\n    /* eslint-disable-next-line */\n    this.restore = Function(\n      'o',\n      restoreTmpl(resetters, paths, hasWildcards)\n    ).bind(state)\n  }\n}\n\n/**\n * Mutates the original object to be censored by restoring its original values\n * prior to censoring.\n *\n * @param {object} secret Compiled object describing which target fields should\n * be censored and the field states.\n * @param {string[]} paths The list of paths to censor as provided at\n * initialization time.\n *\n * @returns {string} String of JavaScript to be used by `Function()`. The\n * string compiles to the function that does the work in the description.\n */\nfunction resetTmpl (secret, paths) {\n  return paths.map((path) => {\n    const { circle, escPath, leadingBracket } = secret[path]\n    const delim = leadingBracket ? '' : '.'\n    const reset = circle\n      ? `o.${circle} = secret[${escPath}].val`\n      : `o${delim}${path} = secret[${escPath}].val`\n    const clear = `secret[${escPath}].val = undefined`\n    return `\n      if (secret[${escPath}].val !== undefined) {\n        try { ${reset} } catch (e) {}\n        ${clear}\n      }\n    `\n  }).join('')\n}\n\n/**\n * Creates the body of the restore function\n *\n * Restoration of the redacted object happens\n * backwards, in reverse order of redactions,\n * so that repeated redactions on the same object\n * property can be eventually rolled back to the\n * original value.\n *\n * This way dynamic redactions are restored first,\n * starting from the last one working backwards and\n * followed by the static ones.\n *\n * @returns {string} the body of the restore function\n */\nfunction restoreTmpl (resetters, paths, hasWildcards) {\n  const dynamicReset = hasWildcards === true ? `\n    const keys = Object.keys(secret)\n    const len = keys.length\n    for (var i = len - 1; i >= ${paths.length}; i--) {\n      const k = keys[i]\n      const o = secret[k]\n      if (o.flat === true) this.groupRestore(o)\n      else this.nestedRestore(o)\n      secret[k] = null\n    }\n  ` : ''\n\n  return `\n    const secret = this.secret\n    ${dynamicReset}\n    ${resetters}\n    return o\n  `\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/restorer.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/rx.js":
/*!***************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/rx.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = /[^.[\\]]+|\\[((?:.)*?)\\]/g\n\n/*\nRegular expression explanation:\n\nAlt 1: /[^.[\\]]+/ - Match one or more characters that are *not* a dot (.)\n                    opening square bracket ([) or closing square bracket (])\n\nAlt 2: /\\[((?:.)*?)\\]/ - If the char IS dot or square bracket, then create a capture\n                         group (which will be capture group $1) that matches anything\n                         within square brackets. Expansion is lazy so it will\n                         stop matching as soon as the first closing bracket is met `]`\n                         (rather than continuing to match until the final closing bracket).\n*/\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/rx.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/state.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/state.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = state\n\nfunction state (o) {\n  const {\n    secret,\n    censor,\n    compileRestore,\n    serialize,\n    groupRedact,\n    nestedRedact,\n    wildcards,\n    wcLen\n  } = o\n  const builder = [{ secret, censor, compileRestore }]\n  if (serialize !== false) builder.push({ serialize })\n  if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen })\n  return Object.assign(...builder)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/state.js?");

/***/ }),

/***/ "../../../node_modules/fast-redact/lib/validator.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/fast-redact/lib/validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createContext, runInContext } = __webpack_require__(/*! vm */ \"vm\")\n\nmodule.exports = validator\n\nfunction validator (opts = {}) {\n  const {\n    ERR_PATHS_MUST_BE_STRINGS = () => 'fast-redact - Paths must be (non-empty) strings',\n    ERR_INVALID_PATH = (s) => `fast-redact – Invalid path (${s})`\n  } = opts\n\n  return function validate ({ paths }) {\n    paths.forEach((s) => {\n      if (typeof s !== 'string') {\n        throw Error(ERR_PATHS_MUST_BE_STRINGS())\n      }\n      try {\n        if (/〇/.test(s)) throw Error()\n        const proxy = new Proxy({}, { get: () => proxy, set: () => { throw Error() } })\n        const expr = (s[0] === '[' ? '' : '.') + s.replace(/^\\*/, '〇').replace(/\\.\\*/g, '.〇').replace(/\\[\\*\\]/g, '[〇]')\n        if (/\\n|\\r|;/.test(expr)) throw Error()\n        if (/\\/\\*/.test(expr)) throw Error()\n        runInContext(`\n          (function () {\n            'use strict'\n            o${expr}\n            if ([o${expr}].length !== 1) throw Error()\n          })()\n        `, createContext({ o: proxy, 〇: null }), {\n          codeGeneration: { strings: false, wasm: false }\n        })\n      } catch (e) {\n        throw Error(ERR_INVALID_PATH(s))\n      }\n    })\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-redact/lib/validator.js?");

/***/ }),

/***/ "../../../node_modules/fast-safe-stringify/index.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/fast-safe-stringify/index.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fast-safe-stringify/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-cors/index.js":
/*!***************************************************!*\
  !*** ../../../node_modules/fastify-cors/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fp = __webpack_require__(/*! fastify-plugin */ \"../../../node_modules/fastify-plugin/plugin.js\")\nconst vary = __webpack_require__(/*! ./vary */ \"../../../node_modules/fastify-cors/vary.js\")\n\nconst defaultOptions = {\n  origin: '*',\n  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n  preflightContinue: false,\n  optionsSuccessStatus: 204,\n  credentials: false,\n  exposedHeaders: null,\n  allowedHeaders: null,\n  maxAge: null,\n  preflight: true,\n  strictPreflight: true\n}\n\nfunction fastifyCors (fastify, opts, next) {\n  fastify.decorateRequest('corsPreflightEnabled', false)\n\n  let hideOptionsRoute = true\n  if (typeof opts === 'function') {\n    handleCorsOptionsDelegator(opts, fastify)\n  } else {\n    if (opts.hideOptionsRoute !== undefined) hideOptionsRoute = opts.hideOptionsRoute\n    const corsOptions = Object.assign({}, defaultOptions, opts)\n    fastify.addHook('onRequest', (req, reply, next) => {\n      onRequest(fastify, corsOptions, req, reply, next)\n    })\n  }\n\n  // The preflight reply must occur in the hook. This allows fastify-cors to reply to\n  // preflight requests BEFORE possible authentication plugins. If the preflight reply\n  // occurred in this handler, other plugins may deny the request since the browser will\n  // remove most headers (such as the Authentication header).\n  //\n  // This route simply enables fastify to accept preflight requests.\n  fastify.options('*', { schema: { hide: hideOptionsRoute } }, (req, reply) => {\n    if (!req.corsPreflightEnabled) {\n      // Do not handle preflight requests if the origin option disabled CORS\n      reply.callNotFound()\n      return\n    }\n\n    reply.send()\n  })\n\n  next()\n}\n\nfunction handleCorsOptionsDelegator (optionsResolver, fastify) {\n  fastify.addHook('onRequest', (req, reply, next) => {\n    if (optionsResolver.length === 2) {\n      handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next)\n      return\n    } else {\n      // handle delegator based on Promise\n      const ret = optionsResolver(req)\n      if (ret && typeof ret.then === 'function') {\n        ret.then(options => Object.assign({}, defaultOptions, options))\n          .then(corsOptions => onRequest(fastify, corsOptions, req, reply, next)).catch(next)\n        return\n      }\n    }\n    next(new Error('Invalid CORS origin option'))\n  })\n}\n\nfunction handleCorsOptionsCallbackDelegator (optionsResolver, fastify, req, reply, next) {\n  optionsResolver(req, (err, options) => {\n    if (err) {\n      next(err)\n    } else {\n      const corsOptions = Object.assign({}, defaultOptions, options)\n      onRequest(fastify, corsOptions, req, reply, next)\n    }\n  })\n}\n\nfunction onRequest (fastify, options, req, reply, next) {\n  // Always set Vary header\n  // https://github.com/rs/cors/issues/10\n  vary(reply, 'Origin')\n  const resolveOriginOption = typeof options.origin === 'function' ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin)\n\n  resolveOriginOption(req, (error, resolvedOriginOption) => {\n    if (error !== null) {\n      return next(error)\n    }\n\n    // Disable CORS and preflight if false\n    if (resolvedOriginOption === false) {\n      return next()\n    }\n\n    // Falsy values are invalid\n    if (!resolvedOriginOption) {\n      return next(new Error('Invalid CORS origin option'))\n    }\n\n    addCorsHeaders(req, reply, resolvedOriginOption, options)\n\n    if (req.raw.method === 'OPTIONS' && options.preflight === true) {\n      // Strict mode enforces the required headers for preflight\n      if (options.strictPreflight === true && (!req.headers.origin || !req.headers['access-control-request-method'])) {\n        reply.status(400).type('text/plain').send('Invalid Preflight Request')\n        return\n      }\n\n      req.corsPreflightEnabled = true\n\n      addPreflightHeaders(req, reply, options)\n\n      if (!options.preflightContinue) {\n        // Do not call the hook callback and terminate the request\n        // Safari (and potentially other browsers) need content-length 0,\n        // for 204 or they just hang waiting for a body\n        reply\n          .code(options.optionsSuccessStatus)\n          .header('Content-Length', '0')\n          .send()\n        return\n      }\n    }\n\n    return next()\n  })\n}\n\nfunction addCorsHeaders (req, reply, originOption, corsOptions) {\n  const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption)\n  // In the case of origin not allowed the header is not\n  // written in the response.\n  // https://github.com/fastify/fastify-cors/issues/127\n  if (origin) {\n    reply.header('Access-Control-Allow-Origin', origin)\n  }\n\n  if (corsOptions.credentials) {\n    reply.header('Access-Control-Allow-Credentials', 'true')\n  }\n\n  if (corsOptions.exposedHeaders !== null) {\n    reply.header(\n      'Access-Control-Expose-Headers',\n      Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(', ') : corsOptions.exposedHeaders\n    )\n  }\n}\n\nfunction addPreflightHeaders (req, reply, corsOptions) {\n  reply.header(\n    'Access-Control-Allow-Methods',\n    Array.isArray(corsOptions.methods) ? corsOptions.methods.join(', ') : corsOptions.methods\n  )\n\n  if (corsOptions.allowedHeaders === null) {\n    vary(reply, 'Access-Control-Request-Headers')\n    const reqAllowedHeaders = req.headers['access-control-request-headers']\n    if (reqAllowedHeaders !== undefined) {\n      reply.header('Access-Control-Allow-Headers', reqAllowedHeaders)\n    }\n  } else {\n    reply.header(\n      'Access-Control-Allow-Headers',\n      Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(', ') : corsOptions.allowedHeaders\n    )\n  }\n\n  if (corsOptions.maxAge !== null) {\n    reply.header('Access-Control-Max-Age', String(corsOptions.maxAge))\n  }\n}\n\nfunction resolveOriginWrapper (fastify, origin) {\n  return function (req, cb) {\n    const result = origin.call(fastify, req.headers.origin, cb)\n\n    // Allow for promises\n    if (result && typeof result.then === 'function') {\n      result.then(res => cb(null, res), cb)\n    }\n  }\n}\n\nfunction getAccessControlAllowOriginHeader (reqOrigin, originOption) {\n  if (originOption === '*') {\n    // allow any origin\n    return '*'\n  }\n\n  if (typeof originOption === 'string') {\n    // fixed origin\n    return originOption\n  }\n\n  // reflect origin\n  return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false\n}\n\nfunction isRequestOriginAllowed (reqOrigin, allowedOrigin) {\n  if (Array.isArray(allowedOrigin)) {\n    for (let i = 0; i < allowedOrigin.length; ++i) {\n      if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {\n        return true\n      }\n    }\n    return false\n  } else if (typeof allowedOrigin === 'string') {\n    return reqOrigin === allowedOrigin\n  } else if (allowedOrigin instanceof RegExp) {\n    return allowedOrigin.test(reqOrigin)\n  } else {\n    return !!allowedOrigin\n  }\n}\n\nmodule.exports = fp(fastifyCors, {\n  fastify: '3.x',\n  name: 'fastify-cors'\n})\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-cors/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-cors/vary.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fastify-cors/vary.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst append = (__webpack_require__(/*! vary */ \"../../../node_modules/vary/index.js\").append)\n\n// https://github.com/fastify/fastify-sensible/blob/master/lib/vary.js\nmodule.exports = function vary (reply, field) {\n  let value = reply.getHeader('Vary') || ''\n  const header = Array.isArray(value)\n    ? value.join(', ')\n    : String(value)\n\n  // set new header\n  if ((value = append(header, field))) {\n    reply.header('Vary', value)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-cors/vary.js?");

/***/ }),

/***/ "../../../node_modules/fastify-error/index.js":
/*!****************************************************!*\
  !*** ../../../node_modules/fastify-error/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { inherits, format } = __webpack_require__(/*! util */ \"util\")\n\nfunction createError (code, message, statusCode = 500, Base = Error) {\n  if (!code) throw new Error('Fastify error code must not be empty')\n  if (!message) throw new Error('Fastify error message must not be empty')\n\n  code = code.toUpperCase()\n\n  function FastifyError (a, b, c) {\n    if (!(this instanceof FastifyError)) {\n      return new FastifyError(a, b, c)\n    }\n    Error.captureStackTrace(this, FastifyError)\n    this.name = 'FastifyError'\n    this.code = code\n\n    // more performant than spread (...) operator\n    if (a && b && c) {\n      this.message = format(message, a, b, c)\n    } else if (a && b) {\n      this.message = format(message, a, b)\n    } else if (a) {\n      this.message = format(message, a)\n    } else {\n      this.message = message\n    }\n\n    this.statusCode = statusCode || undefined\n  }\n  FastifyError.prototype[Symbol.toStringTag] = 'Error'\n\n  FastifyError.prototype.toString = function () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n\n  inherits(FastifyError, Base)\n\n  return FastifyError\n}\n\nmodule.exports = createError\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-error/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/index.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst From = __webpack_require__(/*! fastify-reply-from */ \"../../../node_modules/fastify-reply-from/index.js\")\nconst WebSocket = __webpack_require__(/*! ws */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/index.js\")\nconst { convertUrlToWebSocket } = __webpack_require__(/*! ./utils */ \"../../../node_modules/fastify-http-proxy/utils.js\")\n\nconst httpMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS']\nconst urlPattern = /^https?:\\/\\//\n\nfunction liftErrorCode (code) {\n  if (typeof code !== 'number') {\n    // Sometimes \"close\" event emits with a non-numeric value\n    return 1011\n  } else if (code === 1004 || code === 1005 || code === 1006) {\n    // ws module forbid those error codes usage, lift to \"application level\" (4xxx)\n    return 4000 + (code % 1000)\n  } else {\n    return code\n  }\n}\n\nfunction closeWebSocket (socket, code, reason) {\n  if (socket.readyState === WebSocket.OPEN) {\n    socket.close(liftErrorCode(code), reason)\n  }\n}\n\nfunction waitConnection (socket, write) {\n  if (socket.readyState === WebSocket.CONNECTING) {\n    socket.once('open', write)\n  } else {\n    write()\n  }\n}\n\nfunction isExternalUrl (url = '') {\n  return urlPattern.test(url)\n};\n\nfunction proxyWebSockets (source, target) {\n  function close (code, reason) {\n    closeWebSocket(source, code, reason)\n    closeWebSocket(target, code, reason)\n  }\n\n  source.on('message', data => waitConnection(target, () => target.send(data)))\n  source.on('ping', data => waitConnection(target, () => target.ping(data)))\n  source.on('pong', data => waitConnection(target, () => target.pong(data)))\n  source.on('close', close)\n  source.on('error', error => close(1011, error.message))\n  source.on('unexpected-response', () => close(1011, 'unexpected response'))\n\n  // source WebSocket is already connected because it is created by ws server\n  target.on('message', data => source.send(data))\n  target.on('ping', data => source.ping(data))\n  target.on('pong', data => source.pong(data))\n  target.on('close', close)\n  target.on('error', error => close(1011, error.message))\n  target.on('unexpected-response', () => close(1011, 'unexpected response'))\n}\n\nfunction setupWebSocketProxy (fastify, options, rewritePrefix) {\n  const server = new WebSocket.Server({\n    server: fastify.server,\n    ...options.wsServerOptions\n  })\n\n  fastify.addHook('onClose', (instance, done) => server.close(done))\n\n  // To be able to close the HTTP server,\n  // all WebSocket clients need to be disconnected.\n  // Fastify is missing a pre-close event, or the ability to\n  // add a hook before the server.close call. We need to resort\n  // to monkeypatching for now.\n  const oldClose = fastify.server.close\n  fastify.server.close = function (done) {\n    for (const client of server.clients) {\n      client.close()\n    }\n    oldClose.call(this, done)\n  }\n\n  server.on('error', (err) => {\n    fastify.log.error(err)\n  })\n\n  server.on('connection', (source, request) => {\n    if (fastify.prefix && !request.url.startsWith(fastify.prefix)) {\n      fastify.log.debug({ url: request.url }, 'not matching prefix')\n      source.close()\n      return\n    }\n\n    const url = createWebSocketUrl(request)\n\n    const target = new WebSocket(url, options.wsClientOptions)\n\n    fastify.log.debug({ url: url.href }, 'proxy websocket')\n    proxyWebSockets(source, target)\n  })\n\n  function createWebSocketUrl (request) {\n    const source = new URL(request.url, 'ws://127.0.0.1')\n\n    const target = new URL(\n      source.pathname.replace(fastify.prefix, rewritePrefix),\n      convertUrlToWebSocket(options.upstream)\n    )\n\n    target.search = source.search\n\n    return target\n  }\n}\n\nfunction generateRewritePrefix (prefix, opts) {\n  if (!prefix) {\n    return ''\n  }\n\n  let rewritePrefix = opts.rewritePrefix || (opts.upstream ? new URL(opts.upstream).pathname : '/')\n\n  if (!prefix.endsWith('/') && rewritePrefix.endsWith('/')) {\n    rewritePrefix = rewritePrefix.slice(0, -1)\n  }\n\n  return rewritePrefix\n}\n\nasync function httpProxy (fastify, opts) {\n  if (!opts.upstream && !(opts.upstream === '' && opts.replyOptions && typeof opts.replyOptions.getUpstream === 'function')) {\n    throw new Error('upstream must be specified')\n  }\n\n  const preHandler = opts.preHandler || opts.beforeHandler\n  const rewritePrefix = generateRewritePrefix(fastify.prefix, opts)\n\n  const fromOpts = Object.assign({}, opts)\n  fromOpts.base = opts.upstream\n  fromOpts.prefix = undefined\n\n  const oldRewriteHeaders = (opts.replyOptions || {}).rewriteHeaders\n  const replyOpts = Object.assign({}, opts.replyOptions, {\n    rewriteHeaders\n  })\n  fromOpts.rewriteHeaders = rewriteHeaders\n\n  fastify.register(From, fromOpts)\n\n  if (opts.proxyPayloads !== false) {\n    fastify.addContentTypeParser('application/json', bodyParser)\n    fastify.addContentTypeParser('*', bodyParser)\n  }\n\n  function rewriteHeaders (headers) {\n    const location = headers.location\n    if (location && !isExternalUrl(location)) {\n      headers.location = location.replace(rewritePrefix, fastify.prefix)\n    }\n    if (oldRewriteHeaders) {\n      headers = oldRewriteHeaders(headers)\n    }\n    return headers\n  }\n\n  function bodyParser (req, payload, done) {\n    done(null, payload)\n  }\n\n  fastify.route({\n    url: '/',\n    method: opts.httpMethods || httpMethods,\n    preHandler,\n    config: opts.config || {},\n    constraints: opts.constraints || {},\n    handler\n  })\n  fastify.route({\n    url: '/*',\n    method: opts.httpMethods || httpMethods,\n    preHandler,\n    config: opts.config || {},\n    constraints: opts.constraints || {},\n    handler\n  })\n\n  function handler (request, reply) {\n    const queryParamIndex = request.raw.url.indexOf('?')\n    let dest = request.raw.url.slice(0, queryParamIndex !== -1 ? queryParamIndex : undefined)\n    dest = dest.replace(this.prefix, rewritePrefix)\n    reply.from(dest || '/', replyOpts)\n  }\n\n  if (opts.websocket) {\n    setupWebSocketProxy(fastify, opts, rewritePrefix)\n  }\n}\n\nhttpProxy[Symbol.for('plugin-meta')] = {\n  fastify: '^3.0.0',\n  name: 'fastify-http-proxy'\n}\n\nmodule.exports = httpProxy\nmodule.exports[\"default\"] = httpProxy\nmodule.exports.fastifyHttpProxy = httpProxy\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/index.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/event-target.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/event-target.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/extension.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/extension.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/limiter.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/limiter.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/receiver.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/receiver.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              'Max payload size exceeded',\n              false,\n              1009,\n              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n            )\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(\n          RangeError,\n          'invalid payload length 1',\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/sender.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/sender.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n\n\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/stream.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/stream.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/subprotocol.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/subprotocol.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/subprotocol.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntry {\n  const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8(buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    },\n    tokenChars\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n  };\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket-server.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket-server.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key']\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../../../node_modules/fastify-http-proxy/node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req.aborted) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "../../../node_modules/fastify-http-proxy/utils.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fastify-http-proxy/utils.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction convertUrlToWebSocket (urlString) {\n  return urlString.replace(/^(http)(s)?:\\/\\//, 'ws$2://')\n}\n\nmodule.exports = {\n  convertUrlToWebSocket\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-http-proxy/utils.js?");

/***/ }),

/***/ "../../../node_modules/fastify-plugin/plugin.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fastify-plugin/plugin.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst extractPluginName = __webpack_require__(/*! ./stackParser */ \"../../../node_modules/fastify-plugin/stackParser.js\")\n\nlet count = 0\n\nfunction plugin (fn, options = {}) {\n  let autoName = false\n\n  if (typeof fn.default !== 'undefined') {\n    // Support for 'export default' behaviour in transpiled ECMAScript module\n    fn = fn.default\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError(\n      `fastify-plugin expects a function, instead got a '${typeof fn}'`\n    )\n  }\n\n  fn[Symbol.for('skip-override')] = true\n\n  const pluginName = (options && options.name) || checkName(fn)\n\n  if (typeof options === 'string') {\n    options = {\n      fastify: options\n    }\n  }\n\n  if (\n    typeof options !== 'object' ||\n    Array.isArray(options) ||\n    options === null\n  ) {\n    throw new TypeError('The options object should be an object')\n  }\n\n  if (options.fastify !== undefined && typeof options.fastify !== 'string') {\n    throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`)\n  }\n\n  if (!options.name) {\n    autoName = true\n    options.name = pluginName + '-auto-' + count++\n  }\n\n  fn[Symbol.for('fastify.display-name')] = options.name\n  fn[Symbol.for('plugin-meta')] = options\n\n  // Faux modules support\n  if (!fn.default) {\n    fn.default = fn\n  }\n\n  // TypeScript support for named imports\n  // See https://github.com/fastify/fastify/issues/2404 for more details\n  // The type definitions would have to be update to match this.\n  const camelCase = toCamelCase(options.name)\n  if (!autoName && !fn[camelCase]) {\n    fn[camelCase] = fn\n  }\n\n  return fn\n}\n\nfunction checkName (fn) {\n  if (fn.name.length > 0) return fn.name\n\n  try {\n    throw new Error('anonymous function')\n  } catch (e) {\n    return extractPluginName(e.stack)\n  }\n}\n\nfunction toCamelCase (name) {\n  const newName = name.replace(/-(.)/g, function (match, g1) {\n    return g1.toUpperCase()\n  })\n  return newName\n}\n\nplugin.default = plugin\nmodule.exports = plugin\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-plugin/plugin.js?");

/***/ }),

/***/ "../../../node_modules/fastify-plugin/stackParser.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/fastify-plugin/stackParser.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst fpStackTracePattern = /at\\s{1}(?:.*\\.)?plugin\\s{1}.*\\n\\s*(.*)/\nconst fileNamePattern = /(\\w*(\\.\\w*)*)\\..*/\n\nmodule.exports = function extractPluginName (stack) {\n  const m = stack.match(fpStackTracePattern)\n\n  // get last section of path and match for filename\n  return m ? m[1].split(/[/\\\\]/).slice(-1)[0].match(fileNamePattern)[1] : 'anonymous'\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-plugin/stackParser.js?");

/***/ }),

/***/ "../../../node_modules/fastify-reply-from/index.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fastify-reply-from/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fp = __webpack_require__(/*! fastify-plugin */ \"../../../node_modules/fastify-plugin/plugin.js\")\nconst lru = __webpack_require__(/*! tiny-lru */ \"../../../node_modules/tiny-lru/lib/tiny-lru.cjs.js\")\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\")\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst createError = __webpack_require__(/*! http-errors */ \"../../../node_modules/http-errors/index.js\")\nconst buildRequest = __webpack_require__(/*! ./lib/request */ \"../../../node_modules/fastify-reply-from/lib/request.js\")\nconst {\n  filterPseudoHeaders,\n  copyHeaders,\n  stripHttp1ConnectionHeaders,\n  buildURL\n} = __webpack_require__(/*! ./lib/utils */ \"../../../node_modules/fastify-reply-from/lib/utils.js\")\n\nconst { TimeoutError } = buildRequest\n\nmodule.exports = fp(function from (fastify, opts, next) {\n  const contentTypesToEncode = new Set([\n    'application/json',\n    ...(opts.contentTypesToEncode || [])\n  ])\n\n  const retryMethods = new Set(opts.retryMethods || [\n    'GET', 'HEAD', 'OPTIONS', 'TRACE'\n  ])\n\n  const cache = opts.disableCache ? undefined : lru(opts.cacheURLs || 100)\n  const base = opts.base\n  const { request, close, retryOnError } = buildRequest({\n    http: opts.http,\n    http2: opts.http2,\n    base,\n    undici: opts.undici\n  })\n\n  fastify.decorateReply('from', function (source, opts) {\n    opts = opts || {}\n    const req = this.request.raw\n    const onResponse = opts.onResponse\n    const rewriteHeaders = opts.rewriteHeaders || headersNoOp\n    const rewriteRequestHeaders = opts.rewriteRequestHeaders || requestHeadersNoOp\n    const getUpstream = opts.getUpstream || upstreamNoOp\n    const onError = opts.onError || onErrorDefault\n    const retriesCount = opts.retriesCount || 0\n    const maxRetriesOn503 = opts.maxRetriesOn503 || 10\n\n    if (!source) {\n      source = req.url\n    }\n\n    // we leverage caching to avoid parsing the destination URL\n    const dest = getUpstream(req, base)\n    let url\n    if (cache) {\n      url = cache.get(source) || buildURL(source, dest)\n      cache.set(source, url)\n    } else {\n      url = buildURL(source, dest)\n    }\n\n    const sourceHttp2 = req.httpVersionMajor === 2\n    const headers = sourceHttp2 ? filterPseudoHeaders(req.headers) : req.headers\n    headers.host = url.host\n    const qs = getQueryString(url.search, req.url, opts)\n    let body = ''\n\n    if (opts.body) {\n      if (typeof opts.body.pipe === 'function') {\n        throw new Error('sending a new body as a stream is not supported yet')\n      }\n\n      if (opts.contentType) {\n        body = opts.body\n      } else {\n        body = JSON.stringify(opts.body)\n        opts.contentType = 'application/json'\n      }\n\n      headers['content-length'] = Buffer.byteLength(body)\n      headers['content-type'] = opts.contentType\n    } else if (this.request.body) {\n      if (this.request.body instanceof Stream) {\n        body = this.request.body\n      } else {\n        // Per RFC 7231 §3.1.1.5 if this header is not present we MAY assume application/octet-stream\n        const contentType = req.headers['content-type'] || 'application/octet-stream'\n        // detect if body should be encoded as JSON\n        // supporting extended content-type header formats:\n        // - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type\n        const lowerCaseContentType = contentType.toLowerCase()\n        const plainContentType = lowerCaseContentType.indexOf(';') > -1\n          ? lowerCaseContentType.slice(0, lowerCaseContentType.indexOf(';'))\n          : lowerCaseContentType\n        const shouldEncodeJSON = contentTypesToEncode.has(plainContentType)\n        // transparently support JSON encoding\n        body = shouldEncodeJSON ? JSON.stringify(this.request.body) : this.request.body\n        // update origin request headers after encoding\n        headers['content-length'] = Buffer.byteLength(body)\n        headers['content-type'] = contentType\n      }\n    }\n\n    // according to https://tools.ietf.org/html/rfc2616#section-4.3\n    // fastify ignore message body when it's a GET or HEAD request\n    // when proxy this request, we should reset the content-length to make it a valid http request\n    // discussion: https://github.com/fastify/fastify/issues/953\n    if (req.method === 'GET' || req.method === 'HEAD') {\n      // body will be populated here only if opts.body is passed.\n      // if we are doing that with a GET or HEAD request is a programmer error\n      // and as such we can throw immediately.\n      if (body) {\n        throw new Error(`Rewriting the body when doing a ${req.method} is not allowed`)\n      }\n    }\n\n    this.request.log.info({ source }, 'fetching from remote server')\n\n    const requestHeaders = rewriteRequestHeaders(req, headers)\n    const contentLength = requestHeaders['content-length']\n    let requestImpl\n    if (retryMethods.has(req.method) && !contentLength) {\n      requestImpl = createRequestRetry(request, this, retriesCount, retryOnError, maxRetriesOn503)\n    } else {\n      requestImpl = request\n    }\n\n    requestImpl({ method: req.method, url, qs, headers: requestHeaders, body }, (err, res) => {\n      if (err) {\n        this.request.log.warn(err, 'response errored')\n        if (!this.sent) {\n          if (err.code === 'ERR_HTTP2_STREAM_CANCEL' || err.code === 'ENOTFOUND') {\n            onError(this, { error: new createError.ServiceUnavailable() })\n          } else if (err instanceof TimeoutError || err.code === 'UND_ERR_HEADERS_TIMEOUT') {\n            onError(this, { error: new createError.GatewayTimeout() })\n          } else {\n            onError(this, { error: createError(500, err) })\n          }\n        }\n        return\n      }\n      this.request.log.info('response received')\n      if (sourceHttp2) {\n        copyHeaders(\n          rewriteHeaders(stripHttp1ConnectionHeaders(res.headers)),\n          this\n        )\n      } else {\n        copyHeaders(rewriteHeaders(res.headers), this)\n      }\n      this.code(res.statusCode)\n      if (onResponse) {\n        onResponse(this.request.raw, this, res.stream)\n      } else {\n        this.send(res.stream)\n      }\n    })\n    return this\n  })\n\n  fastify.addHook('onReady', (done) => {\n    if (isFastifyMultipartRegistered(fastify)) {\n      fastify.log.warn('fastify-reply-from might not behave as expected when used with fastify-multipart')\n    }\n    done()\n  })\n\n  fastify.onClose((fastify, next) => {\n    close()\n    // let the event loop do a full run so that it can\n    // actually destroy those sockets\n    setImmediate(next)\n  })\n\n  next()\n}, '>=3')\n\nfunction getQueryString (search, reqUrl, opts) {\n  if (opts.queryString) {\n    return '?' + querystring.stringify(opts.queryString)\n  }\n\n  if (search.length > 0) {\n    return search\n  }\n\n  const queryIndex = reqUrl.indexOf('?')\n\n  if (queryIndex > 0) {\n    return reqUrl.slice(queryIndex)\n  }\n\n  return ''\n}\n\nfunction headersNoOp (headers) {\n  return headers\n}\n\nfunction requestHeadersNoOp (originalReq, headers) {\n  return headers\n}\n\nfunction upstreamNoOp (req, base) {\n  return base\n}\n\nfunction onErrorDefault (reply, { error }) {\n  reply.send(error)\n}\n\nfunction isFastifyMultipartRegistered (fastify) {\n  return fastify.hasContentTypeParser('multipart') && fastify.hasRequestDecorator('multipart')\n}\n\nfunction createRequestRetry (requestImpl, reply, retriesCount, retryOnError, maxRetriesOn503) {\n  function requestRetry (req, cb) {\n    let retries = 0\n\n    function run () {\n      requestImpl(req, function (err, res) {\n        // Magic number, so why not 42? We might want to make this configurable.\n        let retryAfter = 42 * Math.random() * (retries + 1)\n\n        if (res && res.headers['retry-after']) {\n          retryAfter = res.headers['retry-after']\n        }\n        if (!reply.sent) {\n          // always retry on 503 errors\n          if (res && res.statusCode === 503 && req.method === 'GET') {\n            if (retriesCount === 0 && retries < maxRetriesOn503) {\n              // we should stop at some point\n              return retry(retryAfter)\n            }\n          } else if (retriesCount > retries && err && err.code === retryOnError) {\n            return retry(retryAfter)\n          }\n        }\n        cb(err, res)\n      })\n    }\n\n    function retry (after) {\n      retries += 1\n      setTimeout(run, after)\n    }\n\n    run()\n  }\n\n  return requestRetry\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-reply-from/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-reply-from/lib/request.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/fastify-reply-from/lib/request.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst semver = __webpack_require__(/*! semver */ \"../../../node_modules/semver/index.js\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst https = __webpack_require__(/*! https */ \"https\")\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\")\nconst eos = __webpack_require__(/*! end-of-stream */ \"../../../node_modules/end-of-stream/index.js\")\nconst pump = __webpack_require__(/*! pump */ \"../../../node_modules/pump/index.js\")\nconst undici = __webpack_require__(/*! undici */ \"../../../node_modules/undici/index.js\")\nconst { stripHttp1ConnectionHeaders } = __webpack_require__(/*! ./utils */ \"../../../node_modules/fastify-reply-from/lib/utils.js\")\nconst http2 = __webpack_require__(/*! http2 */ \"http2\")\n\nclass TimeoutError extends Error {}\n\nfunction shouldUseUndici (opts) {\n  if (opts.undici === false || opts.http || opts.http2) {\n    return false\n  }\n  return true\n}\n\nfunction isUndiciInstance (obj) {\n  return obj instanceof undici.Pool ||\n    obj instanceof undici.Client ||\n    obj instanceof undici.Dispatcher\n}\n\nfunction buildRequest (opts) {\n  const isHttp2 = !!opts.http2\n  const hasUndiciOptions = shouldUseUndici(opts)\n  const requests = {\n    'http:': http,\n    'https:': https,\n    'unix+http:': { base: http, request: unixRequest },\n    'unix+https:': { base: https, request: unixRequest }\n  }\n  const http2Opts = getHttp2Opts(opts)\n  const httpOpts = getHttpOpts(opts)\n  const baseUrl = opts.base && new URL(opts.base).origin\n  const undiciOpts = opts.undici || {}\n  let http2Client\n  let undiciAgent\n  let undiciInstance\n  let agents\n\n  if (isHttp2) {\n    if (semver.lt(process.version, '9.0.0')) {\n      throw new Error('Http2 support requires Node version >= 9.0.0')\n    }\n    if (!opts.base) throw new Error('Option base is required when http2 is true')\n    if (opts.base.startsWith('unix+')) {\n      throw new Error('Unix socket destination is not supported when http2 is true')\n    }\n  } else {\n    agents = httpOpts.agents || {\n      'http:': new http.Agent(httpOpts.agentOptions),\n      'https:': new https.Agent(httpOpts.agentOptions)\n    }\n  }\n\n  if (isHttp2) {\n    return { request: handleHttp2Req, close, retryOnError: 'ECONNRESET' }\n  } else if (hasUndiciOptions) {\n    if (opts.base && opts.base.startsWith('unix+')) {\n      const undiciOpts = getUndiciOptions(opts.undici)\n      undiciOpts.socketPath = decodeURIComponent(new URL(opts.base).host)\n      const protocol = opts.base.startsWith('unix+https') ? 'https' : 'http'\n      undiciInstance = new undici.Pool(protocol + '://localhost', undiciOpts)\n    } else if (isUndiciInstance(opts.undici)) {\n      undiciInstance = opts.undici\n    } else {\n      undiciAgent = new undici.Agent(getUndiciOptions(opts.undici))\n    }\n    return { request: handleUndici, close, retryOnError: 'UND_ERR_SOCKET' }\n  } else {\n    return { request: handleHttp1Req, close, retryOnError: 'ECONNRESET' }\n  }\n\n  function close () {\n    if (hasUndiciOptions) {\n      undiciAgent && undiciAgent.destroy()\n      undiciInstance && undiciInstance.destroy()\n    } else if (!isHttp2) {\n      agents['http:'].destroy()\n      agents['https:'].destroy()\n    } else if (http2Client) {\n      http2Client.destroy()\n    }\n  }\n\n  function handleHttp1Req (opts, done) {\n    const req = requests[opts.url.protocol].request({\n      method: opts.method,\n      port: opts.url.port,\n      path: opts.url.pathname + opts.qs,\n      hostname: opts.url.hostname,\n      headers: opts.headers,\n      agent: agents[opts.url.protocol.replace(/^unix:/, '')],\n      ...httpOpts.requestOptions\n    })\n    req.on('error', done)\n    req.on('response', res => {\n      done(null, { statusCode: res.statusCode, headers: res.headers, stream: res })\n    })\n    req.once('timeout', () => {\n      const err = new TimeoutError('HTTP request timed out')\n      req.abort()\n      done(err)\n    })\n\n    end(req, opts.body, done)\n  }\n\n  function handleUndici (opts, done) {\n    const req = {\n      origin: baseUrl || opts.url.origin,\n      path: opts.url.pathname + opts.qs,\n      method: opts.method,\n      headers: Object.assign({}, opts.headers),\n      body: opts.body,\n      headersTimeout: undiciOpts.headersTimeout,\n      bodyTimeout: undiciOpts.bodyTimeout\n    }\n\n    let pool\n\n    if (undiciInstance) {\n      pool = undiciInstance\n    } else if (!baseUrl && opts.url.protocol.startsWith('unix')) {\n      done(new Error('unix socket not supported with undici yet'))\n      return\n    } else {\n      pool = undiciAgent\n    }\n\n    // remove forbidden headers\n    req.headers.connection = undefined\n    req.headers['transfer-encoding'] = undefined\n\n    pool.request(req, function (err, res) {\n      if (err) {\n        done(err)\n        return\n      }\n\n      // using delete, otherwise it will render as an empty string\n      delete res.headers['transfer-encoding']\n\n      done(null, { statusCode: res.statusCode, headers: res.headers, stream: res.body })\n    })\n  }\n\n  function handleHttp2Req (opts, done) {\n    let cancelRequest\n    let sessionTimedOut = false\n\n    if (!http2Client || http2Client.destroyed) {\n      http2Client = http2.connect(baseUrl, http2Opts.sessionOptions)\n      http2Client.once('error', done)\n      // we might enqueue a large number of requests in this connection\n      // before it's connected\n      http2Client.setMaxListeners(0)\n      http2Client.setTimeout(http2Opts.sessionTimeout, function () {\n        if (cancelRequest) {\n          cancelRequest()\n          cancelRequest = undefined\n          sessionTimedOut = true\n        }\n        http2Client.destroy()\n      })\n      http2Client.once('connect', () => {\n        // reset the max listener to 10 on connect\n        http2Client.setMaxListeners(10)\n        http2Client.removeListener('error', done)\n      })\n    }\n    const req = http2Client.request({\n      ':method': opts.method,\n      ':path': opts.url.pathname + opts.qs,\n      ...stripHttp1ConnectionHeaders(opts.headers)\n    }, http2Opts.requestOptions)\n    const isGet = opts.method === 'GET' || opts.method === 'get'\n    if (!isGet) {\n      end(req, opts.body, done)\n    }\n    req.setTimeout(http2Opts.requestTimeout, () => {\n      const err = new TimeoutError('HTTP/2 request timed out')\n      req.close(http2.constants.NGHTTP2_CANCEL)\n      done(err)\n    })\n    req.once('close', () => {\n      if (sessionTimedOut) {\n        const err = new TimeoutError('HTTP/2 session timed out')\n        done(err)\n      }\n    })\n    cancelRequest = eos(req, err => {\n      if (err) done(err)\n    })\n    req.on('response', headers => {\n      const statusCode = headers[':status']\n      done(null, { statusCode, headers, stream: req })\n    })\n  }\n}\n\nmodule.exports = buildRequest\nmodule.exports.TimeoutError = TimeoutError\n\nfunction unixRequest (opts) {\n  delete opts.port\n  opts.socketPath = querystring.unescape(opts.hostname)\n  delete opts.hostname\n  return this.base.request(opts)\n}\n\nfunction end (req, body, cb) {\n  if (!body || typeof body === 'string' || body instanceof Uint8Array) {\n    req.end(body)\n  } else if (body.pipe) {\n    pump(body, req, err => {\n      if (err) cb(err)\n    })\n  } else {\n    cb(new Error(`type unsupported for body: ${body.constructor}`))\n  }\n}\n\nfunction getHttp2Opts (opts) {\n  if (!opts.http2) {\n    return {}\n  }\n\n  let http2Opts = opts.http2\n  if (typeof http2Opts === 'boolean') {\n    http2Opts = {}\n  }\n  http2Opts.sessionOptions = http2Opts.sessionOptions || {}\n\n  if (!http2Opts.sessionTimeout) {\n    http2Opts.sessionTimeout = opts.sessionTimeout || 6000\n  }\n  if (!http2Opts.requestTimeout) {\n    http2Opts.requestTimeout = 10000\n  }\n  http2Opts.sessionOptions.rejectUnauthorized = http2Opts.sessionOptions.rejectUnauthorized || false\n\n  return http2Opts\n}\n\nfunction getHttpOpts (opts) {\n  const httpOpts = typeof opts.http === 'object' ? opts.http : {}\n  httpOpts.requestOptions = httpOpts.requestOptions || {}\n\n  if (!httpOpts.requestOptions.timeout) {\n    httpOpts.requestOptions.timeout = 10000\n  }\n\n  httpOpts.requestOptions.rejectUnauthorized = httpOpts.requestOptions.rejectUnauthorized || false\n\n  httpOpts.agentOptions = getAgentOptions(opts)\n\n  return httpOpts\n}\n\nfunction getAgentOptions (opts) {\n  return {\n    keepAlive: true,\n    keepAliveMsecs: 60 * 1000, // 1 minute\n    maxSockets: 2048,\n    maxFreeSockets: 2048,\n    ...(opts.http && opts.http.agentOptions)\n  }\n}\n\nfunction getUndiciOptions (opts = {}) {\n  const res = {\n    pipelining: 1,\n    connections: 128,\n    tls: {},\n    ...(opts)\n  }\n\n  res.tls.rejectUnauthorized = res.tls.rejectUnauthorized || false\n\n  return res\n}\n\nmodule.exports.getUndiciOptions = getUndiciOptions\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-reply-from/lib/request.js?");

/***/ }),

/***/ "../../../node_modules/fastify-reply-from/lib/utils.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/fastify-reply-from/lib/utils.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("function filterPseudoHeaders (headers) {\n  const dest = {}\n  const headersKeys = Object.keys(headers)\n  let header\n  let i\n  for (i = 0; i < headersKeys.length; i++) {\n    header = headersKeys[i]\n    if (header.charCodeAt(0) !== 58) { // fast path for indexOf(':') === 0\n      dest[header.toLowerCase()] = headers[header]\n    }\n  }\n  return dest\n}\n\nfunction copyHeaders (headers, reply) {\n  const headersKeys = Object.keys(headers)\n\n  let header\n  let i\n\n  for (i = 0; i < headersKeys.length; i++) {\n    header = headersKeys[i]\n    if (header.charCodeAt(0) !== 58) { // fast path for indexOf(':') === 0\n      reply.header(header, headers[header])\n    }\n  }\n}\n\nfunction stripHttp1ConnectionHeaders (headers) {\n  const headersKeys = Object.keys(headers)\n  const dest = {}\n\n  let header\n  let i\n\n  for (i = 0; i < headersKeys.length; i++) {\n    header = headersKeys[i].toLowerCase()\n\n    switch (header) {\n      case 'connection':\n      case 'upgrade':\n      case 'http2-settings':\n      case 'te':\n      case 'transfer-encoding':\n      case 'proxy-connection':\n      case 'keep-alive':\n      case 'host':\n        break\n      default:\n        dest[header] = headers[header]\n        break\n    }\n  }\n  return dest\n}\n\n// issue ref: https://github.com/fastify/fast-proxy/issues/42\nfunction buildURL (source, reqBase) {\n  let baseOrigin = reqBase ? new URL(reqBase).href : undefined\n  const dest = new URL(source, reqBase)\n\n  // if base is specified, source url should not override it\n  if (baseOrigin) {\n    if (!baseOrigin.endsWith('/') && dest.href.length > baseOrigin.length) {\n      baseOrigin = baseOrigin + '/'\n    }\n\n    if (!dest.href.startsWith(baseOrigin)) {\n      throw new Error('source must be a relative path string')\n    }\n  }\n\n  return dest\n}\n\nmodule.exports = {\n  copyHeaders,\n  stripHttp1ConnectionHeaders,\n  filterPseudoHeaders,\n  buildURL\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-reply-from/lib/utils.js?");

/***/ }),

/***/ "../../../node_modules/fastify-static/index.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/fastify-static/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst statSync = (__webpack_require__(/*! fs */ \"fs\").statSync)\nconst { PassThrough } = __webpack_require__(/*! readable-stream */ \"../../../node_modules/readable-stream/readable.js\")\nconst glob = __webpack_require__(/*! glob */ \"../../../node_modules/glob/glob.js\")\nconst send = __webpack_require__(/*! send */ \"../../../node_modules/send/index.js\")\nconst contentDisposition = __webpack_require__(/*! content-disposition */ \"../../../node_modules/content-disposition/index.js\")\nconst fp = __webpack_require__(/*! fastify-plugin */ \"../../../node_modules/fastify-plugin/plugin.js\")\nconst util = __webpack_require__(/*! util */ \"util\")\nconst globPromise = util.promisify(glob)\nconst encodingNegotiator = __webpack_require__(/*! encoding-negotiator */ \"../../../node_modules/encoding-negotiator/index.js\")\n\nconst dirList = __webpack_require__(/*! ./lib/dirList */ \"../../../node_modules/fastify-static/lib/dirList.js\")\n\nasync function fastifyStatic (fastify, opts) {\n  checkRootPathForErrors(fastify, opts.root)\n\n  const setHeaders = opts.setHeaders\n\n  if (setHeaders !== undefined && typeof setHeaders !== 'function') {\n    throw new TypeError('The `setHeaders` option must be a function')\n  }\n\n  const invalidDirListOpts = dirList.validateOptions(opts.list)\n  if (invalidDirListOpts) {\n    throw invalidDirListOpts\n  }\n\n  const sendOptions = {\n    root: opts.root,\n    acceptRanges: opts.acceptRanges,\n    cacheControl: opts.cacheControl,\n    dotfiles: opts.dotfiles,\n    etag: opts.etag,\n    extensions: opts.extensions,\n    immutable: opts.immutable,\n    index: opts.index,\n    lastModified: opts.lastModified,\n    maxAge: opts.maxAge\n  }\n\n  const allowedPath = opts.allowedPath\n\n  if (opts.prefix === undefined) opts.prefix = '/'\n\n  let prefix = opts.prefix\n\n  if (!opts.prefixAvoidTrailingSlash) {\n    prefix =\n      opts.prefix[opts.prefix.length - 1] === '/'\n        ? opts.prefix\n        : opts.prefix + '/'\n  }\n\n  function pumpSendToReply (\n    request,\n    reply,\n    pathname,\n    rootPath,\n    rootPathOffset = 0,\n    pumpOptions = {},\n    checkedEncodings\n  ) {\n    const options = Object.assign({}, sendOptions, pumpOptions)\n\n    if (rootPath) {\n      if (Array.isArray(rootPath)) {\n        options.root = rootPath[rootPathOffset]\n      } else {\n        options.root = rootPath\n      }\n    }\n\n    if (allowedPath && !allowedPath(pathname, options.root)) {\n      return reply.callNotFound()\n    }\n\n    let encoding\n    let pathnameForSend = pathname\n\n    if (opts.preCompressed) {\n      /**\n       * We conditionally create this structure to track our attempts\n       * at sending pre-compressed assets\n       */\n      if (!checkedEncodings) {\n        checkedEncodings = new Set()\n      }\n\n      encoding = getEncodingHeader(request.headers, checkedEncodings)\n\n      if (encoding) {\n        if (pathname.endsWith('/')) {\n          pathname = findIndexFile(pathname, options.root, options.index)\n          if (!pathname) {\n            return reply.callNotFound()\n          }\n        }\n        pathnameForSend = pathname + '.' + getEncodingExtension(encoding)\n      }\n    }\n\n    const stream = send(request.raw, pathnameForSend, options)\n    let resolvedFilename\n    stream.on('file', function (file) {\n      resolvedFilename = file\n    })\n\n    const wrap = new PassThrough({\n      flush (cb) {\n        this.finished = true\n        if (reply.raw.statusCode === 304) {\n          reply.send('')\n        }\n        cb()\n      }\n    })\n\n    wrap.getHeader = reply.getHeader.bind(reply)\n    wrap.setHeader = reply.header.bind(reply)\n    wrap.finished = false\n\n    Object.defineProperty(wrap, 'filename', {\n      get () {\n        return resolvedFilename\n      }\n    })\n    Object.defineProperty(wrap, 'statusCode', {\n      get () {\n        return reply.raw.statusCode\n      },\n      set (code) {\n        reply.code(code)\n      }\n    })\n\n    if (request.method === 'HEAD') {\n      wrap.on('finish', reply.send.bind(reply))\n    } else {\n      wrap.on('pipe', function () {\n        if (encoding) {\n          reply.header('content-type', getContentType(pathname))\n          reply.header('content-encoding', encoding)\n        }\n        reply.send(wrap)\n      })\n    }\n\n    if (setHeaders !== undefined) {\n      stream.on('headers', setHeaders)\n    }\n\n    stream.on('directory', function (_, path) {\n      if (opts.list) {\n        dirList.send({\n          reply,\n          dir: path,\n          options: opts.list,\n          route: pathname,\n          prefix\n        }).catch((err) => reply.send(err))\n        return\n      }\n\n      if (opts.redirect === true) {\n        try {\n          reply.redirect(301, getRedirectUrl(request.raw.url))\n        } catch (error) {\n          // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack\n          /* istanbul ignore next */\n          reply.send(error)\n        }\n      } else {\n        reply.callNotFound()\n      }\n    })\n\n    stream.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        // if file exists, send real file, otherwise send dir list if name match\n        if (opts.list && dirList.handle(pathname, opts.list)) {\n          dirList.send({\n            reply,\n            dir: dirList.path(opts.root, pathname),\n            options: opts.list,\n            route: pathname,\n            prefix\n          }).catch((err) => reply.send(err))\n          return\n        }\n\n        // root paths left to try?\n        if (Array.isArray(rootPath) && rootPathOffset < (rootPath.length - 1)) {\n          return pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset + 1)\n        }\n\n        if (opts.preCompressed && !checkedEncodings.has(encoding)) {\n          checkedEncodings.add(encoding)\n          return pumpSendToReply(\n            request,\n            reply,\n            pathname,\n            rootPath,\n            undefined,\n            undefined,\n            checkedEncodings\n          )\n        }\n\n        return reply.callNotFound()\n      }\n\n      // The `send` library terminates the request with a 404 if the requested\n      // path contains a dotfile and `send` is initialized with `{dotfiles:\n      // 'ignore'}`. `send` aborts the request before getting far enough to\n      // check if the file exists (hence, a 404 `NotFoundError` instead of\n      // `ENOENT`).\n      // https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L582\n      if (err.status === 404) {\n        return reply.callNotFound()\n      }\n\n      reply.send(err)\n    })\n\n    // we cannot use pump, because send error\n    // handling is not compatible\n    stream.pipe(wrap)\n  }\n\n  const errorHandler = (error, request, reply) => {\n    if (error && error.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      reply.request.raw.destroy()\n      return\n    }\n\n    fastify.errorHandler(error, request, reply)\n  }\n\n  // Set the schema hide property if defined in opts or true by default\n  const routeOpts = {\n    schema: {\n      hide: typeof opts.schemaHide !== 'undefined' ? opts.schemaHide : true\n    },\n    errorHandler: fastify.errorHandler ? errorHandler : undefined\n  }\n\n  if (opts.decorateReply !== false) {\n    fastify.decorateReply('sendFile', function (filePath, rootPath, options) {\n      const opts = typeof rootPath === 'object' ? rootPath : options\n      const root = typeof rootPath === 'string' ? rootPath : opts && opts.root\n      pumpSendToReply(\n        this.request,\n        this,\n        filePath,\n        root || sendOptions.root,\n        0,\n        opts\n      )\n      return this\n    })\n\n    fastify.decorateReply(\n      'download',\n      function (filePath, fileName, options = {}) {\n        const { root, ...opts } =\n          typeof fileName === 'object' ? fileName : options\n        fileName = typeof fileName === 'string' ? fileName : filePath\n\n        // Set content disposition header\n        this.header('content-disposition', contentDisposition(fileName))\n\n        pumpSendToReply(this.request, this, filePath, root, 0, opts)\n\n        return this\n      }\n    )\n  }\n\n  if (opts.serve !== false) {\n    if (opts.wildcard && typeof opts.wildcard !== 'boolean') {\n      throw new Error('\"wildcard\" option must be a boolean')\n    }\n    if (opts.wildcard === undefined || opts.wildcard === true) {\n      fastify.head(prefix + '*', routeOpts, function (req, reply) {\n        pumpSendToReply(req, reply, '/' + req.params['*'], sendOptions.root)\n      })\n      fastify.get(prefix + '*', routeOpts, function (req, reply) {\n        pumpSendToReply(req, reply, '/' + req.params['*'], sendOptions.root)\n      })\n      if (opts.redirect === true && prefix !== opts.prefix) {\n        fastify.get(opts.prefix, routeOpts, function (req, reply) {\n          reply.redirect(301, getRedirectUrl(req.raw.url))\n        })\n      }\n    } else {\n      const globPattern = '**/*'\n      const indexDirs = new Map()\n      const routes = new Set()\n\n      for (const rootPath of Array.isArray(sendOptions.root) ? sendOptions.root : [sendOptions.root]) {\n        const files = await globPromise(path.join(rootPath, globPattern), { nodir: true })\n        const indexes = typeof opts.index === 'undefined' ? ['index.html'] : [].concat(opts.index)\n\n        for (let file of files) {\n          file = file\n            .replace(rootPath.replace(/\\\\/g, '/'), '')\n            .replace(/^\\//, '')\n          const route = encodeURI(prefix + file).replace(/\\/\\//g, '/')\n          if (routes.has(route)) {\n            continue\n          }\n          routes.add(route)\n          fastify.head(route, routeOpts, function (req, reply) {\n            pumpSendToReply(req, reply, '/' + file, rootPath)\n          })\n\n          fastify.get(route, routeOpts, function (req, reply) {\n            pumpSendToReply(req, reply, '/' + file, rootPath)\n          })\n\n          const key = path.posix.basename(route)\n          if (indexes.includes(key) && !indexDirs.has(key)) {\n            indexDirs.set(path.posix.dirname(route), rootPath)\n          }\n        }\n      }\n\n      for (const [dirname, rootPath] of indexDirs.entries()) {\n        const pathname = dirname + (dirname.endsWith('/') ? '' : '/')\n        const file = '/' + pathname.replace(prefix, '')\n\n        fastify.head(pathname, routeOpts, function (req, reply) {\n          pumpSendToReply(req, reply, file, rootPath)\n        })\n\n        fastify.get(pathname, routeOpts, function (req, reply) {\n          pumpSendToReply(req, reply, file, rootPath)\n        })\n\n        if (opts.redirect === true) {\n          fastify.head(pathname.replace(/\\/$/, ''), routeOpts, function (req, reply) {\n            pumpSendToReply(req, reply, file.replace(/\\/$/, ''), rootPath)\n          })\n          fastify.get(pathname.replace(/\\/$/, ''), routeOpts, function (req, reply) {\n            pumpSendToReply(req, reply, file.replace(/\\/$/, ''), rootPath)\n          })\n        }\n      }\n    }\n  }\n}\n\nfunction checkRootPathForErrors (fastify, rootPath) {\n  if (rootPath === undefined) {\n    throw new Error('\"root\" option is required')\n  }\n\n  if (Array.isArray(rootPath)) {\n    if (!rootPath.length) {\n      throw new Error('\"root\" option array requires one or more paths')\n    }\n\n    if ([...new Set(rootPath)].length !== rootPath.length) {\n      throw new Error(\n        '\"root\" option array contains one or more duplicate paths'\n      )\n    }\n\n    // check each path and fail at first invalid\n    rootPath.map((path) => checkPath(fastify, path))\n    return\n  }\n\n  if (typeof rootPath === 'string') {\n    return checkPath(fastify, rootPath)\n  }\n\n  throw new Error('\"root\" option must be a string or array of strings')\n}\n\nfunction checkPath (fastify, rootPath) {\n  if (typeof rootPath !== 'string') {\n    throw new Error('\"root\" option must be a string')\n  }\n  if (path.isAbsolute(rootPath) === false) {\n    throw new Error('\"root\" option must be an absolute path')\n  }\n\n  let pathStat\n\n  try {\n    pathStat = statSync(rootPath)\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      fastify.log.warn(`\"root\" path \"${rootPath}\" must exist`)\n      return\n    }\n\n    throw e\n  }\n\n  if (pathStat.isDirectory() === false) {\n    throw new Error('\"root\" option must point to a directory')\n  }\n}\n\nconst supportedEncodings = ['br', 'gzip', 'deflate']\n\nfunction getContentType (path) {\n  const type = send.mime.lookup(path)\n  const charset = send.mime.charsets.lookup(type)\n  if (!charset) {\n    return type\n  }\n  return `${type}; charset=${charset}`\n}\n\nfunction findIndexFile (pathname, root, indexFiles = ['index.html']) {\n  return indexFiles.find(filename => {\n    const p = path.join(root, pathname, filename)\n    try {\n      const stats = statSync(p)\n      return !stats.isDirectory()\n    } catch (e) {\n      return false\n    }\n  })\n}\n\n// Adapted from https://github.com/fastify/fastify-compress/blob/665e132fa63d3bf05ad37df3c20346660b71a857/index.js#L451\nfunction getEncodingHeader (headers, checked) {\n  if (!('accept-encoding' in headers)) return\n\n  const header = headers['accept-encoding'].toLowerCase().replace(/\\*/g, 'gzip')\n  return encodingNegotiator.negotiate(\n    header,\n    supportedEncodings.filter((enc) => !checked.has(enc))\n  )\n}\n\nfunction getEncodingExtension (encoding) {\n  switch (encoding) {\n    case 'br':\n      return 'br'\n\n    case 'gzip':\n      return 'gz'\n  }\n}\n\nfunction getRedirectUrl (url) {\n  let i = 0\n  // we detech how many slash before a valid path\n  for (i; i < url.length; i++) {\n    if (url[i] !== '/' && url[i] !== '\\\\') break\n  }\n  // turns all leading / or \\ into a single /\n  url = '/' + url.substr(i)\n  try {\n    const parsed = new URL(url, 'http://localhost.com/')\n    return parsed.pathname + (parsed.pathname[parsed.pathname.length - 1] !== '/' ? '/' : '') + (parsed.search || '')\n  } catch (error) {\n    // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack\n    /* istanbul ignore next */\n    const err = new Error(`Invalid redirect URL: ${url}`)\n    /* istanbul ignore next */\n    err.statusCode = 400\n    /* istanbul ignore next */\n    throw err\n  }\n}\n\nmodule.exports = fp(fastifyStatic, {\n  fastify: '3.x',\n  name: 'fastify-static'\n})\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-static/index.js?");

/***/ }),

/***/ "../../../node_modules/fastify-static/lib/dirList.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/fastify-static/lib/dirList.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = (__webpack_require__(/*! fs */ \"fs\").promises)\nconst pLimit = __webpack_require__(/*! p-limit */ \"../../../node_modules/p-limit/index.js\")\n\nconst dirList = {\n  /**\n   * get files and dirs from dir, or error\n   * @param {string} dir full path fs dir\n   * @param {function(error, entries)} callback\n   * note: can't use glob because don't get error on non existing dir\n   */\n  list: async function (dir, options) {\n    const entries = { dirs: [], files: [] }\n    const files = await fs.readdir(dir)\n    if (files.length < 1) {\n      return entries\n    }\n\n    const limit = pLimit(4)\n    await Promise.all(files.map(filename => limit(async () => {\n      let stats\n      try {\n        stats = await fs.stat(path.join(dir, filename))\n      } catch (error) {\n        return\n      }\n      const entry = { name: filename, stats }\n      if (stats.isDirectory()) {\n        if (options.extendedFolderInfo) {\n          entry.extendedInfo = await getExtendedInfo(path.join(dir, filename))\n        }\n        entries.dirs.push(entry)\n      } else {\n        entries.files.push(entry)\n      }\n    })))\n\n    async function getExtendedInfo (folderPath) {\n      const depth = folderPath.split(path.sep).length\n      let totalSize = 0\n      let fileCount = 0\n      let totalFileCount = 0\n      let folderCount = 0\n      let totalFolderCount = 0\n      let lastModified = 0\n\n      async function walk (dir) {\n        const files = await fs.readdir(dir)\n        const limit = pLimit(4)\n        await Promise.all(files.map(filename => limit(async () => {\n          const filePath = path.join(dir, filename)\n          let stats\n          try {\n            stats = await fs.stat(filePath)\n          } catch (error) {\n            return\n          }\n\n          if (stats.isDirectory()) {\n            totalFolderCount++\n            if (filePath.split(path.sep).length === depth + 1) {\n              folderCount++\n            }\n            await walk(filePath)\n          } else {\n            totalSize += stats.size\n            totalFileCount++\n            if (filePath.split(path.sep).length === depth + 1) {\n              fileCount++\n            }\n            lastModified = Math.max(lastModified, stats.mtimeMs)\n          }\n        })))\n      }\n\n      await walk(folderPath)\n      return {\n        totalSize,\n        fileCount,\n        totalFileCount,\n        folderCount,\n        totalFolderCount,\n        lastModified\n      }\n    }\n\n    entries.dirs.sort((a, b) => a.name.localeCompare(b.name))\n    entries.files.sort((a, b) => a.name.localeCompare(b.name))\n    return entries\n  },\n\n  /**\n   * send dir list content, or 404 on error\n   * @param {Fastify.Reply} reply\n   * @param {string} dir full path fs dir\n   * @param {ListOptions} options\n   * @param {string} route request route\n   */\n  send: async function ({ reply, dir, options, route, prefix }) {\n    let entries\n    try {\n      entries = await dirList.list(dir, options)\n    } catch (error) {\n      return reply.callNotFound()\n    }\n    const format = reply.request.query.format || options.format\n    if (format !== 'html') {\n      if (options.jsonFormat !== 'extended') {\n        const nameEntries = { dirs: [], files: [] }\n        entries.dirs.forEach(entry => nameEntries.dirs.push(entry.name))\n        entries.files.forEach(entry => nameEntries.files.push(entry.name))\n\n        reply.send(nameEntries)\n      } else {\n        reply.send(entries)\n      }\n      return\n    }\n\n    const html = options.render(\n      entries.dirs.map(entry => dirList.htmlInfo(entry, route, prefix, options)),\n      entries.files.map(entry => dirList.htmlInfo(entry, route, prefix, options)))\n    reply.type('text/html').send(html)\n  },\n\n  /**\n   * provide the html information about entry and route, to get name and full route\n   * @param entry file or dir name and stats\n   * @param {string} route request route\n   * @return {ListFile}\n   */\n  htmlInfo: function (entry, route, prefix, options) {\n    if (options.names && options.names.includes(path.basename(route))) {\n      route = path.normalize(path.join(route, '..'))\n    }\n    return {\n      href: path.join(prefix, route, entry.name).replace(/\\\\/g, '/'),\n      name: entry.name,\n      stats: entry.stats,\n      extendedInfo: entry.extendedInfo\n    }\n  },\n\n  /**\n   * say if the route can be handled by dir list or not\n   * @param {string} route request route\n   * @param {ListOptions} options\n   * @return {boolean}\n   */\n  handle: function (route, options) {\n    if (!options.names) {\n      return false\n    }\n    return options.names.includes(path.basename(route)) ||\n      // match trailing slash\n      (options.names.includes('/') && route[route.length - 1] === '/')\n  },\n\n  /**\n   * get path from route and fs root paths, considering trailing slash\n   * @param {string} root fs root path\n   * @param {string} route request route\n   */\n  path: function (root, route) {\n    const _route = route[route.length - 1] === '/'\n      ? route + 'none'\n      : route\n    return path.dirname(path.join(root, _route))\n  },\n\n  /**\n   * validate options\n   * @return {Error}\n   */\n  validateOptions: function (options) {\n    if (!options) {\n      return\n    }\n    if (options.format && options.format !== 'json' && options.format !== 'html') {\n      return new TypeError('The `list.format` option must be json or html')\n    }\n    if (options.names && !Array.isArray(options.names)) {\n      return new TypeError('The `list.names` option must be an array')\n    }\n    if (options.format === 'html' && typeof options.render !== 'function') {\n      return new TypeError('The `list.render` option must be a function and is required with html format')\n    }\n  }\n\n}\n\nmodule.exports = dirList\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-static/lib/dirList.js?");

/***/ }),

/***/ "../../../node_modules/fastify-warning/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fastify-warning/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { format } = __webpack_require__(/*! util */ \"util\")\n\nfunction build () {\n  const codes = {}\n  const emitted = new Map()\n\n  function create (name, code, message) {\n    if (!name) throw new Error('Fastify warning name must not be empty')\n    if (!code) throw new Error('Fastify warning code must not be empty')\n    if (!message) throw new Error('Fastify warning message must not be empty')\n\n    code = code.toUpperCase()\n\n    if (codes[code] !== undefined) {\n      throw new Error(`The code '${code}' already exist`)\n    }\n\n    function buildWarnOpts (a, b, c) {\n      // more performant than spread (...) operator\n      let formatted\n      if (a && b && c) {\n        formatted = format(message, a, b, c)\n      } else if (a && b) {\n        formatted = format(message, a, b)\n      } else if (a) {\n        formatted = format(message, a)\n      } else {\n        formatted = message\n      }\n\n      return {\n        code,\n        name,\n        message: formatted\n      }\n    }\n\n    emitted.set(code, false)\n    codes[code] = buildWarnOpts\n\n    return codes[code]\n  }\n\n  function emit (code, a, b, c) {\n    if (codes[code] === undefined) throw new Error(`The code '${code}' does not exist`)\n    if (emitted.get(code) === true) return\n    emitted.set(code, true)\n\n    const warning = codes[code](a, b, c)\n    process.emitWarning(warning.message, warning.name, warning.code)\n  }\n\n  return {\n    create,\n    emit,\n    emitted\n  }\n}\n\nmodule.exports = build\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify-warning/index.js?");

/***/ }),

/***/ "../../../node_modules/fastq/queue.js":
/*!********************************************!*\
  !*** ../../../node_modules/fastq/queue.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable no-var */\n\nvar reusify = __webpack_require__(/*! reusify */ \"../../../node_modules/reusify/reusify.js\")\n\nfunction fastqueue (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  if (concurrency < 1) {\n    throw new Error('fastqueue concurrency must be greater than 1')\n  }\n\n  var cache = reusify(Task)\n  var queueHead = null\n  var queueTail = null\n  var _running = 0\n  var errorHandler = null\n\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  }\n\n  return self\n\n  function running () {\n    return _running\n  }\n\n  function pause () {\n    self.paused = true\n  }\n\n  function length () {\n    var current = queueHead\n    var counter = 0\n\n    while (current) {\n      current = current.next\n      counter++\n    }\n\n    return counter\n  }\n\n  function getQueue () {\n    var current = queueHead\n    var tasks = []\n\n    while (current) {\n      tasks.push(current.value)\n      current = current.next\n    }\n\n    return tasks\n  }\n\n  function resume () {\n    if (!self.paused) return\n    self.paused = false\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++\n      release()\n    }\n  }\n\n  function idle () {\n    return _running === 0 && self.length() === 0\n  }\n\n  function push (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n    current.errorHandler = errorHandler\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current\n        queueTail = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function unshift (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead\n        queueHead = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function release (holder) {\n    if (holder) {\n      cache.release(holder)\n    }\n    var next = queueHead\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null\n        }\n        queueHead = next.next\n        next.next = null\n        worker.call(context, next.value, next.worked)\n        if (queueTail === null) {\n          self.empty()\n        }\n      } else {\n        _running--\n      }\n    } else if (--_running === 0) {\n      self.drain()\n    }\n  }\n\n  function kill () {\n    queueHead = null\n    queueTail = null\n    self.drain = noop\n  }\n\n  function killAndDrain () {\n    queueHead = null\n    queueTail = null\n    self.drain()\n    self.drain = noop\n  }\n\n  function error (handler) {\n    errorHandler = handler\n  }\n}\n\nfunction noop () {}\n\nfunction Task () {\n  this.value = null\n  this.callback = noop\n  this.next = null\n  this.release = noop\n  this.context = null\n  this.errorHandler = null\n\n  var self = this\n\n  this.worked = function worked (err, result) {\n    var callback = self.callback\n    var errorHandler = self.errorHandler\n    var val = self.value\n    self.value = null\n    self.callback = noop\n    if (self.errorHandler) {\n      errorHandler(err, val)\n    }\n    callback.call(self.context, err, result)\n    self.release(self)\n  }\n}\n\nfunction queueAsPromised (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  function asyncWrapper (arg, cb) {\n    worker.call(this, arg)\n      .then(function (res) {\n        cb(null, res)\n      }, cb)\n  }\n\n  var queue = fastqueue(context, asyncWrapper, concurrency)\n\n  var pushCb = queue.push\n  var unshiftCb = queue.unshift\n\n  queue.push = push\n  queue.unshift = unshift\n  queue.drained = drained\n\n  return queue\n\n  function push (value) {\n    var p = new Promise(function (resolve, reject) {\n      pushCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function unshift (value) {\n    var p = new Promise(function (resolve, reject) {\n      unshiftCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function drained () {\n    var previousDrain = queue.drain\n\n    var p = new Promise(function (resolve) {\n      queue.drain = function () {\n        previousDrain()\n        resolve()\n      }\n    })\n\n    return p\n  }\n}\n\nmodule.exports = fastqueue\nmodule.exports.promise = queueAsPromised\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastq/queue.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/find-my-way/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*\n  Char codes:\n    '#': 35\n    '*': 42\n    '-': 45\n    '.': 46\n    '/': 47\n    ':': 58\n    ';': 59\n    '?': 63\n*/\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst fastDecode = __webpack_require__(/*! fast-decode-uri-component */ \"../../../node_modules/fast-decode-uri-component/index.js\")\nconst isRegexSafe = __webpack_require__(/*! safe-regex2 */ \"../../../node_modules/safe-regex2/index.js\")\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = __webpack_require__(/*! ./lib/pretty-print */ \"../../../node_modules/find-my-way/lib/pretty-print.js\")\nconst Node = __webpack_require__(/*! ./node */ \"../../../node_modules/find-my-way/node.js\")\nconst Constrainer = __webpack_require__(/*! ./lib/constrainer */ \"../../../node_modules/find-my-way/lib/constrainer.js\")\n\nconst NODE_TYPES = Node.prototype.types\nconst httpMethods = http.METHODS\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nif (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {\n  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')\n}\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  if (opts.buildPrettyMeta) {\n    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function')\n    this.buildPrettyMeta = opts.buildPrettyMeta\n  } else {\n    this.buildPrettyMeta = defaultBuildPrettyMeta\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.constrainer = new Constrainer(opts.constraints)\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.on(method, pathFull, opts, handler, store)\n    this.on(method, pathOptional, opts, handler, store)\n    return\n  }\n\n  this._on(method, path, opts, handler, store)\n\n  if (this.ignoreTrailingSlash && path !== '/' && !path.endsWith('*')) {\n    if (path.endsWith('/')) {\n      this._on(method, path.slice(0, -1), opts, handler, store)\n    } else {\n      this._on(method, path + '/', opts, handler, store)\n    }\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  if (Array.isArray(method)) {\n    for (var k = 0; k < method.length; k++) {\n      this._on(method[k], path, opts, handler, store)\n    }\n    return\n  }\n\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n\n  let constraints = {}\n  if (opts.constraints !== undefined) {\n    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object')\n    if (Object.keys(opts.constraints).length !== 0) {\n      constraints = opts.constraints\n    }\n  }\n\n  this.constrainer.validateConstraints(constraints)\n  // Let the constrainer know if any constraints are being used now\n  this.constrainer.noteUsage(constraints)\n\n  const params = []\n  var j = 0\n\n  this.routes.push({\n    method: method,\n    path: path,\n    opts: opts,\n    handler: handler,\n    store: store\n  })\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    // search for parametric or wildcard routes\n    // parametric route\n    if (path.charCodeAt(i) === 58) {\n      if (i !== len - 1 && path.charCodeAt(i + 1) === 58) {\n        // It's a double colon. Let's just replace it with a single colon and go ahead\n        path = path.slice(0, i) + path.slice(i + 1)\n        len = path.length\n        continue\n      }\n\n      var nodeType = NODE_TYPES.PARAM\n      j = i + 1\n      var staticPart = path.slice(0, i)\n\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n\n      // add the static part of the route to the tree\n      this._insert(method, staticPart, NODE_TYPES.STATIC, null, null, null, null, constraints)\n\n      // isolate the parameter name\n      var isRegex = false\n      while (i < len && path.charCodeAt(i) !== 47) {\n        isRegex = isRegex || path[i] === '('\n        if (isRegex) {\n          i = getClosingParenthensePosition(path, i) + 1\n          break\n        } else if (path.charCodeAt(i) !== 45 && path.charCodeAt(i) !== 46) {\n          i++\n        } else {\n          break\n        }\n      }\n\n      if (isRegex && (i === len || path.charCodeAt(i) === 47)) {\n        nodeType = NODE_TYPES.REGEX\n      } else if (i < len && path.charCodeAt(i) !== 47) {\n        nodeType = NODE_TYPES.MULTI_PARAM\n      }\n\n      var parameter = path.slice(j, i)\n      var regex = isRegex ? parameter.slice(parameter.indexOf('('), i) : null\n      if (isRegex) {\n        regex = new RegExp(regex)\n        if (!this.allowUnsafeRegex) {\n          assert(isRegexSafe(regex), `The regex '${regex.toString()}' is not safe!`)\n        }\n      }\n      params.push(parameter.slice(0, isRegex ? parameter.indexOf('(') : i))\n\n      path = path.slice(0, j) + path.slice(i)\n      i = j\n      len = path.length\n\n      // if the path is ended\n      if (i === len) {\n        var completedPath = path.slice(0, i)\n        if (this.caseSensitive === false) {\n          completedPath = completedPath.toLowerCase()\n        }\n        return this._insert(method, completedPath, nodeType, params, handler, store, regex, constraints)\n      }\n      // add the parameter and continue with the search\n      staticPart = path.slice(0, i)\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n      this._insert(method, staticPart, nodeType, params, null, null, regex, constraints)\n\n      i--\n    // wildcard route\n    } else if (path.charCodeAt(i) === 42) {\n      this._insert(method, path.slice(0, i), NODE_TYPES.STATIC, null, null, null, null, constraints)\n      // add the wildcard parameter\n      params.push('*')\n      return this._insert(method, path.slice(0, len), NODE_TYPES.MATCH_ALL, params, handler, store, null, constraints)\n    }\n  }\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  // static route\n  this._insert(method, path, NODE_TYPES.STATIC, params, handler, store, null, constraints)\n}\n\nRouter.prototype._insert = function _insert (method, path, kind, params, handler, store, regex, constraints) {\n  const route = path\n  var prefix = ''\n  var pathLen = 0\n  var prefixLen = 0\n  var len = 0\n  var max = 0\n  var node = null\n\n  // Boot the tree for this method if it doesn't exist yet\n  var currentNode = this.trees[method]\n  if (typeof currentNode === 'undefined') {\n    currentNode = new Node({ method: method, constrainer: this.constrainer })\n    this.trees[method] = currentNode\n  }\n\n  while (true) {\n    prefix = currentNode.prefix\n    prefixLen = prefix.length\n    pathLen = path.length\n    len = 0\n\n    // search for the longest common prefix\n    max = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < max && path[len] === prefix[len]) len++\n\n    // the longest common prefix is smaller than the current prefix\n    // let's split the node and add a new child\n    if (len < prefixLen) {\n      node = currentNode.split(len)\n\n      // if the longest common prefix has the same length of the current path\n      // the handler should be added to the current node, to a child otherwise\n      if (len === pathLen) {\n        assert(!currentNode.getHandler(constraints), `Method '${method}' already declared for route '${route}' with constraints '${JSON.stringify(constraints)}'`)\n        currentNode.addHandler(handler, params, store, constraints)\n        currentNode.kind = kind\n      } else {\n        node = new Node({\n          method: method,\n          prefix: path.slice(len),\n          kind: kind,\n          handlers: null,\n          regex: regex,\n          constrainer: this.constrainer\n        })\n        node.addHandler(handler, params, store, constraints)\n        currentNode.addChild(node)\n      }\n\n    // the longest common prefix is smaller than the path length,\n    // but is higher than the prefix\n    } else if (len < pathLen) {\n      // remove the prefix\n      path = path.slice(len)\n      // check if there is a child with the label extracted from the new path\n      node = currentNode.findByLabel(path)\n      // there is a child within the given label, we must go deepen in the tree\n      if (node) {\n        currentNode = node\n        continue\n      }\n      // there are not children within the given label, let's create a new one!\n      node = new Node({ method: method, prefix: path, kind: kind, handlers: null, regex: regex, constrainer: this.constrainer })\n      node.addHandler(handler, params, store, constraints)\n      currentNode.addChild(node)\n\n    // the node already exist\n    } else if (handler) {\n      assert(!currentNode.getHandler(constraints), `Method '${method}' already declared for route '${route}' with constraints '${JSON.stringify(constraints)}'`)\n      currentNode.addHandler(handler, params, store, constraints)\n    }\n    return\n  }\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.off = function off (method, path) {\n  var self = this\n\n  if (Array.isArray(method)) {\n    return method.map(function (method) {\n      return self.off(method, path)\n    })\n  }\n\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.off(method, pathFull)\n    this.off(method, pathOptional)\n    return\n  }\n\n  // Rebuild tree without the specific route\n  const ignoreTrailingSlash = this.ignoreTrailingSlash\n  var newRoutes = self.routes.filter(function (route) {\n    if (!ignoreTrailingSlash) {\n      return !(method === route.method && path === route.path)\n    }\n    if (path.endsWith('/')) {\n      const routeMatches = path === route.path || path.slice(0, -1) === route.path\n      return !(method === route.method && routeMatches)\n    }\n    const routeMatches = path === route.path || (path + '/') === route.path\n    return !(method === route.method && routeMatches)\n  })\n  if (ignoreTrailingSlash) {\n    newRoutes = newRoutes.filter(function (route, i, ar) {\n      if (route.path.endsWith('/') && i < ar.length - 1) {\n        return route.path.slice(0, -1) !== ar[i + 1].path\n      } else if (route.path.endsWith('/') === false && i < ar.length - 1) {\n        return (route.path + '/') !== ar[i + 1].path\n      }\n      return true\n    })\n  }\n  self.reset()\n  newRoutes.forEach(function (route) {\n    self.on(route.method, route.path, route.opts, route.handler, route.store)\n  })\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx) {\n  var handle = this.find(req.method, sanitizeUrl(req.url), this.constrainer.deriveConstraints(req, ctx))\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store)\n}\n\nRouter.prototype.find = function find (method, path, derivedConstraints) {\n  var currentNode = this.trees[method]\n  if (currentNode === undefined) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  var originalPath = path\n  var originalPathLength = path.length\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  var maxParamLength = this.maxParamLength\n  var wildcardNode = null\n  var pathLenWildcard = 0\n  var decoded = null\n  var pindex = 0\n  var params = null\n  var i = 0\n  var idxInOriginalPath = 0\n\n  while (true) {\n    var pathLen = path.length\n    var prefix = currentNode.prefix\n\n    // found the route\n    if (pathLen === 0 || path === prefix) {\n      var handle = derivedConstraints !== undefined ? currentNode.getMatchingHandler(derivedConstraints) : currentNode.unconstrainedHandler\n      if (handle !== null && handle !== undefined) {\n        var paramsObj = {}\n        if (handle.paramsLength > 0) {\n          var paramNames = handle.params\n\n          for (i = 0; i < handle.paramsLength; i++) {\n            paramsObj[paramNames[i]] = params[i]\n          }\n        }\n\n        return {\n          handler: handle.handler,\n          params: paramsObj,\n          store: handle.store\n        }\n      }\n    }\n\n    var prefixLen = prefix.length\n    var len = 0\n    var previousPath = path\n\n    // search for the longest common prefix\n    i = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < i && path.charCodeAt(len) === prefix.charCodeAt(len)) len++\n\n    if (len === prefixLen) {\n      path = path.slice(len)\n      pathLen = path.length\n      idxInOriginalPath += len\n    }\n\n    var node = currentNode.findMatchingChild(derivedConstraints, path)\n\n    if (node === null) {\n      node = currentNode.parametricBrother\n      if (node === null) {\n        return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard, derivedConstraints, params)\n      }\n\n      var goBack = previousPath.charCodeAt(0) === 47 ? previousPath : '/' + previousPath\n      if (originalPath.indexOf(goBack) === -1) {\n        // we need to know the outstanding path so far from the originalPath since the last encountered \"/\" and assign it to previousPath.\n        // e.g originalPath: /aa/bbb/cc, path: bb/cc\n        // outstanding path: /bbb/cc\n        var pathDiff = originalPath.slice(0, originalPathLength - pathLen)\n        previousPath = pathDiff.slice(pathDiff.lastIndexOf('/') + 1, pathDiff.length) + path\n      }\n      idxInOriginalPath = idxInOriginalPath -\n        (previousPath.length - path.length)\n      path = previousPath\n      pathLen = previousPath.length\n      len = prefixLen\n    }\n\n    var kind = node.kind\n\n    // static route\n    if (kind === NODE_TYPES.STATIC) {\n      // if exist, save the wildcard child\n      if (currentNode.wildcardChild !== null) {\n        wildcardNode = currentNode.wildcardChild\n        pathLenWildcard = pathLen\n      }\n      currentNode = node\n      continue\n    }\n\n    if (len !== prefixLen) {\n      return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard, derivedConstraints, params)\n    }\n\n    // if exist, save the wildcard child\n    if (currentNode.wildcardChild !== null) {\n      wildcardNode = currentNode.wildcardChild\n      pathLenWildcard = pathLen\n    }\n\n    // parametric route\n    if (kind === NODE_TYPES.PARAM) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params || (params = [])\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // wildcard route\n    if (kind === NODE_TYPES.MATCH_ALL) {\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath))\n          : null\n      }\n      params || (params = [])\n      params[pindex] = decoded\n      currentNode = node\n      path = ''\n      continue\n    }\n\n    // parametric(regex) route\n    if (kind === NODE_TYPES.REGEX) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      if (!node.regex.test(decoded)) return null\n      params || (params = [])\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // multiparametric route\n    if (kind === NODE_TYPES.MULTI_PARAM) {\n      currentNode = node\n      i = 0\n      if (node.regex !== null) {\n        var matchedParameter = path.match(node.regex)\n        if (matchedParameter === null) return null\n        i = matchedParameter[1].length\n      } else {\n        while (i < pathLen && path.charCodeAt(i) !== 47 && path.charCodeAt(i) !== 45 && path.charCodeAt(i) !== 46) i++\n        if (i > maxParamLength) return null\n      }\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params || (params = [])\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    wildcardNode = null\n  }\n}\n\nRouter.prototype._getWildcardNode = function (node, path, len, derivedConstraints, params) {\n  if (node === null) return null\n  var decoded = fastDecode(path.slice(-len))\n  if (decoded === null) {\n    return this.onBadUrl !== null\n      ? this._onBadUrl(path.slice(-len))\n      : null\n  }\n\n  var handle = derivedConstraints !== undefined ? node.getMatchingHandler(derivedConstraints) : node.unconstrainedHandler\n\n  if (handle !== null && handle !== undefined) {\n    var paramsObj = {}\n    if (handle.paramsLength > 0 && params !== null) {\n      var paramNames = handle.params\n\n      for (i = 0; i < handle.paramsLength; i++) {\n        paramsObj[paramNames[i]] = params[i]\n      }\n    }\n\n    // we must override params[*] to decoded\n    paramsObj['*'] = decoded\n\n    return {\n      handler: handle.handler,\n      params: paramsObj,\n      store: handle.store\n    }\n  }\n  return null\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function (opts = {}) {\n  opts.commonPrefix = opts.commonPrefix === undefined ? true : opts.commonPrefix // default to original behaviour\n  if (!opts.commonPrefix) return prettyPrintRoutesArray.call(this, this.routes, opts)\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const node of Object.values(this.trees)) {\n    if (node) {\n      flattenNode(root, node)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode.call(this, root, '', true, opts)\n}\n\nfor (var i in http.METHODS) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!http.METHODS.hasOwnProperty(i)) continue\n  const m = http.METHODS[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction sanitizeUrl (url) {\n  for (var i = 0, len = url.length; i < len; i++) {\n    var charCode = url.charCodeAt(i)\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    if (charCode === 63 || charCode === 59 || charCode === 35) {\n      return url.slice(0, i)\n    }\n  }\n  return url\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display\n  if (!route) return {}\n  if (!route.store) return {}\n  return Object.assign({}, route.store)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/index.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/lib/constrainer.js":
/*!************************************************************!*\
  !*** ../../../node_modules/find-my-way/lib/constrainer.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst acceptVersionStrategy = __webpack_require__(/*! ./strategies/accept-version */ \"../../../node_modules/find-my-way/lib/strategies/accept-version.js\")\nconst acceptHostStrategy = __webpack_require__(/*! ./strategies/accept-host */ \"../../../node_modules/find-my-way/lib/strategies/accept-host.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nclass Constrainer {\n  constructor (customStrategies) {\n    this.strategies = {\n      version: acceptVersionStrategy,\n      host: acceptHostStrategy\n    }\n\n    this.strategiesInUse = new Set()\n\n    // validate and optimize prototypes of given custom strategies\n    if (customStrategies) {\n      var kCustomStrategies = Object.keys(customStrategies)\n      var strategy\n      for (var i = 0; i < kCustomStrategies.length; i++) {\n        strategy = customStrategies[kCustomStrategies[i]]\n        assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.')\n        assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.')\n        assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.')\n        strategy.isCustom = true\n        this.strategies[strategy.name] = strategy\n\n        if (strategy.mustMatchWhenDerived) {\n          this.noteUsage({ [kCustomStrategies[i]]: strategy })\n        }\n      }\n    }\n  }\n\n  deriveConstraints (req, ctx) {\n    return undefined\n  }\n\n  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.\n  noteUsage (constraints) {\n    if (constraints) {\n      const beforeSize = this.strategiesInUse.size\n      for (const key in constraints) {\n        this.strategiesInUse.add(key)\n      }\n      if (beforeSize !== this.strategiesInUse.size) {\n        this._buildDeriveConstraints()\n      }\n    }\n  }\n\n  newStoreForConstraint (constraint) {\n    if (!this.strategies[constraint]) {\n      throw new Error(`No strategy registered for constraint key ${constraint}`)\n    }\n    return this.strategies[constraint].storage()\n  }\n\n  validateConstraints (constraints) {\n    for (const key in constraints) {\n      const value = constraints[key]\n      if (typeof value === 'undefined') {\n        throw new Error('Can\\'t pass an undefined constraint value, must pass null or no key at all')\n      }\n      const strategy = this.strategies[key]\n      if (!strategy) {\n        throw new Error(`No strategy registered for constraint key ${key}`)\n      }\n      if (strategy.validate) {\n        strategy.validate(value)\n      }\n    }\n  }\n\n  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.\n  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined\n  // This allows us to not allocate an object to hold constraint values if no constraints are defined.\n  _buildDeriveConstraints () {\n    if (this.strategiesInUse.size === 0) return\n\n    const lines = [`\n      const derivedConstraints = {\n        __hasMustMatchValues: false,\n    `]\n\n    const mustMatchKeys = []\n\n    for (const key of this.strategiesInUse) {\n      const strategy = this.strategies[key]\n      // Optimization: inline the derivation for the common built in constraints\n      if (!strategy.isCustom) {\n        if (key === 'version') {\n          lines.push('   version: req.headers[\\'accept-version\\'],')\n        } else if (key === 'host') {\n          lines.push('   host: req.headers.host || req.headers[\\':authority\\'],')\n        } else {\n          throw new Error('unknown non-custom strategy for compiling constraint derivation function')\n        }\n      } else {\n        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`)\n      }\n\n      if (strategy.mustMatchWhenDerived) {\n        mustMatchKeys.push(key)\n      }\n    }\n\n    lines.push('}')\n\n    // There are some constraints that can be derived and marked as \"must match\", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.\n    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.\n    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.\n    if (mustMatchKeys.length > 0) {\n      lines.push(`derivedConstraints.__hasMustMatchValues = !!(${(mustMatchKeys.map(key => `derivedConstraints.${key}`).join(' || '))})`)\n    }\n    lines.push('return derivedConstraints')\n\n    this.deriveConstraints = new Function('req', 'ctx', lines.join('\\n')).bind(this) // eslint-disable-line\n  }\n}\n\nmodule.exports = Constrainer\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/lib/constrainer.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/lib/pretty-print.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/find-my-way/lib/pretty-print.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint-disable no-multi-spaces */\nconst indent              = '    '\nconst branchIndent        = '│   '\nconst midBranchIndent     = '├── '\nconst endBranchIndent     = '└── '\nconst wildcardDelimiter   = '*'\nconst pathDelimiter       = '/'\nconst pathRegExp          = /(?=\\/)/\n/* eslint-enable */\n\nfunction parseFunctionName (fn) {\n  let fName = fn.name || ''\n\n  fName = fName.replace('bound', '').trim()\n  fName = (fName || 'anonymous') + '()'\n  return fName\n}\n\nfunction parseMeta (meta) {\n  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))\n  if (typeof meta === 'symbol') return meta.toString()\n  if (typeof meta === 'function') return parseFunctionName(meta)\n  return meta\n}\n\nfunction buildMetaObject (route, metaArray) {\n  const out = {}\n  const cleanMeta = this.buildPrettyMeta(route)\n  if (!Array.isArray(metaArray)) metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : []\n  metaArray.forEach(m => {\n    const metaKey = typeof m === 'symbol' ? m.toString() : m\n    if (cleanMeta && cleanMeta[m]) {\n      out[metaKey] = parseMeta(cleanMeta[m])\n    }\n  })\n  return out\n}\n\nfunction prettyPrintRoutesArray (routeArray, opts = {}) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta objects to display\n  const mergedRouteArray = []\n\n  let tree = ''\n\n  routeArray.sort((a, b) => {\n    if (!a.path || !b.path) return 0\n    return a.path.localeCompare(b.path)\n  })\n\n  // merge alike paths\n  for (let i = 0; i < routeArray.length; i++) {\n    const route = routeArray[i]\n    const pathExists = mergedRouteArray.find(r => route.path === r.path)\n    if (pathExists) {\n      // path already declared, add new method and break out of loop\n      pathExists.handlers.push({\n        method: route.method,\n        opts: route.opts.constraints || undefined,\n        meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n      })\n      continue\n    }\n\n    const routeHandler = {\n      method: route.method,\n      opts: route.opts.constraints || undefined,\n      meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n    }\n    mergedRouteArray.push({\n      path: route.path,\n      methods: [route.method],\n      opts: [route.opts],\n      handlers: [routeHandler]\n    })\n  }\n\n  // insert root level path if none defined\n  if (!mergedRouteArray.filter(r => r.path === pathDelimiter).length) {\n    const rootPath = {\n      path: pathDelimiter,\n      truncatedPath: '',\n      methods: [],\n      opts: [],\n      handlers: [{}]\n    }\n\n    // if wildcard route exists, insert root level after wildcard\n    if (mergedRouteArray.filter(r => r.path === wildcardDelimiter).length) {\n      mergedRouteArray.splice(1, 0, rootPath)\n    } else {\n      mergedRouteArray.unshift(rootPath)\n    }\n  }\n\n  // build tree\n  const routeTree = buildRouteTree(mergedRouteArray)\n\n  // draw tree\n  routeTree.forEach((rootBranch, idx) => {\n    tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true)\n    tree += '\\n' // newline characters inserted at beginning of drawing function to allow for nested paths\n  })\n\n  return tree\n}\n\nfunction buildRouteTree (mergedRouteArray, rootPath) {\n  rootPath = rootPath || pathDelimiter\n\n  const result = []\n  const temp = { result }\n  mergedRouteArray.forEach((route, idx) => {\n    let splitPath = route.path.split(pathRegExp)\n\n    // add preceding slash for proper nesting\n    if (splitPath[0] !== pathDelimiter) {\n      // handle wildcard route\n      if (splitPath[0] !== wildcardDelimiter) splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)]\n    }\n\n    // build tree\n    splitPath.reduce((acc, path, pidx) => {\n      if (!acc[path]) {\n        acc[path] = { result: [] }\n        const pathSeg = { path, children: acc[path].result }\n\n        if (pidx === splitPath.length - 1) pathSeg.handlers = route.handlers\n        acc.result.push(pathSeg)\n      }\n      return acc[path]\n    }, temp)\n  })\n\n  // unfold root object from array\n  return result\n}\n\nfunction drawBranch (pathSeg, prefix, endBranch, noPrefix, rootBranch) {\n  let branch = ''\n\n  if (!noPrefix && !rootBranch) branch += '\\n'\n  if (!noPrefix) branch += `${prefix || ''}${endBranch ? endBranchIndent : midBranchIndent}`\n  branch += `${pathSeg.path}`\n\n  if (pathSeg.handlers) {\n    const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {\n      const match = acc.findIndex(h => JSON.stringify(h.opts) === JSON.stringify(curr.opts))\n      if (match !== -1) {\n        acc[match].method = [acc[match].method, curr.method].join(', ')\n      } else {\n        acc.push(curr)\n      }\n      return acc\n    }, [])\n\n    flatHandlers.forEach((handler, idx) => {\n      if (idx > 0) branch += `${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}${pathSeg.path}`\n      branch += ` (${handler.method || '-'})`\n      if (handler.opts && JSON.stringify(handler.opts) !== '{}') branch += ` ${JSON.stringify(handler.opts)}`\n      if (handler.meta) {\n        Reflect.ownKeys(handler.meta).forEach((m, hidx) => {\n          branch += `\\n${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}`\n          branch += `• (${m}) ${JSON.stringify(handler.meta[m])}`\n        })\n      }\n      if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1) branch += '\\n'\n    })\n  } else {\n    if (pathSeg.children.length > 1) branch += ' (-)'\n  }\n\n  if (!noPrefix) prefix = `${prefix || ''}${endBranch ? indent : branchIndent}`\n\n  pathSeg.children.forEach((child, idx) => {\n    const endBranch = idx === pathSeg.children.length - 1\n    const skipPrefix = (!pathSeg.handlers && pathSeg.children.length === 1)\n    branch += drawBranch(child, prefix, endBranch, skipPrefix)\n  })\n\n  return branch\n}\n\nfunction prettyPrintFlattenedNode (flattenedNode, prefix, tail, opts) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta items to display\n  let paramName = ''\n  const printHandlers = []\n\n  for (const node of flattenedNode.nodes) {\n    for (const handler of node.handlers) {\n      printHandlers.push({ method: node.method, ...handler })\n    }\n  }\n\n  if (printHandlers.length) {\n    printHandlers.forEach((handler, index) => {\n      let suffix = `(${handler.method || '-'})`\n      if (Object.keys(handler.constraints).length > 0) {\n        suffix += ' ' + JSON.stringify(handler.constraints)\n      }\n\n      let name = ''\n      // find locations of parameters in prefix\n      const paramIndices = flattenedNode.prefix.split('').map((ch, idx) => ch === ':' ? idx : null).filter(idx => idx !== null)\n      if (paramIndices.length) {\n        let prevLoc = 0\n        paramIndices.forEach((loc, idx) => {\n          // find parameter in prefix\n          name += flattenedNode.prefix.slice(prevLoc, loc + 1)\n          // insert parameters\n          name += handler.params[handler.params.length - paramIndices.length + idx]\n          if (idx === paramIndices.length - 1) name += flattenedNode.prefix.slice(loc + 1)\n          prevLoc = loc + 1\n        })\n      } else {\n        // there are no parameters, return full object\n        name = flattenedNode.prefix\n      }\n\n      if (index === 0) {\n        paramName += `${name} ${suffix}`\n      } else {\n        paramName += `\\n${prefix}${tail ? indent : branchIndent}${name} ${suffix}`\n      }\n      if (opts.includeMeta) {\n        const meta = buildMetaObject.call(this, handler, opts.includeMeta)\n        Object.keys(meta).forEach((m, hidx) => {\n          paramName += `\\n${prefix || ''}${tail ? indent : branchIndent}`\n          paramName += `• (${m}) ${JSON.stringify(meta[m])}`\n        })\n      }\n    })\n  } else {\n    paramName = flattenedNode.prefix\n  }\n\n  let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}\\n`\n\n  prefix = `${prefix}${tail ? indent : branchIndent}`\n  const labels = Object.keys(flattenedNode.children)\n  for (let i = 0; i < labels.length; i++) {\n    const child = flattenedNode.children[labels[i]]\n    tree += prettyPrintFlattenedNode.call(this, child, prefix, i === (labels.length - 1), opts)\n  }\n  return tree\n}\n\nfunction flattenNode (flattened, node) {\n  if (node.handlers.length > 0) {\n    flattened.nodes.push(node)\n  }\n\n  if (node.children) {\n    for (const child of Object.values(node.children)) {\n      // split on the slash separator but use a regex to lookahead and not actually match it, preserving it in the returned string segments\n      const childPrefixSegments = child.prefix.split(pathRegExp)\n      let cursor = flattened\n      let parent\n      for (const segment of childPrefixSegments) {\n        parent = cursor\n        cursor = cursor.children[segment]\n        if (!cursor) {\n          cursor = {\n            prefix: segment,\n            nodes: [],\n            children: {}\n          }\n          parent.children[segment] = cursor\n        }\n      }\n      flattenNode(cursor, child)\n    }\n  }\n}\n\nfunction compressFlattenedNode (flattenedNode) {\n  const childKeys = Object.keys(flattenedNode.children)\n  if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {\n    const child = flattenedNode.children[childKeys[0]]\n    if (child.nodes.length <= 1) {\n      compressFlattenedNode(child)\n      flattenedNode.nodes = child.nodes\n      flattenedNode.prefix += child.prefix\n      flattenedNode.children = child.children\n      return flattenedNode\n    }\n  }\n\n  for (const key of Object.keys(flattenedNode.children)) {\n    compressFlattenedNode(flattenedNode.children[key])\n  }\n\n  return flattenedNode\n}\n\nmodule.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/lib/pretty-print.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/lib/strategies/accept-host.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/find-my-way/lib/strategies/accept-host.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nfunction HostStorage () {\n  var hosts = {}\n  var regexHosts = []\n  return {\n    get: (host) => {\n      var exact = hosts[host]\n      if (exact) {\n        return exact\n      }\n      var item\n      for (var i = 0; i < regexHosts.length; i++) {\n        item = regexHosts[i]\n        if (item.host.test(host)) {\n          return item.value\n        }\n      }\n    },\n    set: (host, value) => {\n      if (host instanceof RegExp) {\n        regexHosts.push({ host, value })\n      } else {\n        hosts[host] = value\n      }\n    },\n    del: (host) => {\n      delete hosts[host]\n      regexHosts = regexHosts.filter((obj) => String(obj.host) !== String(host))\n    },\n    empty: () => {\n      hosts = {}\n      regexHosts = []\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'host',\n  mustMatchWhenDerived: false,\n  storage: HostStorage,\n  validate (value) {\n    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp')\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/lib/strategies/accept-host.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/lib/strategies/accept-version.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/find-my-way/lib/strategies/accept-version.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVerStore = __webpack_require__(/*! semver-store */ \"../../../node_modules/semver-store/index.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nmodule.exports = {\n  name: 'version',\n  mustMatchWhenDerived: true,\n  storage: SemVerStore,\n  validate (value) {\n    assert(typeof value === 'string', 'Version should be a string')\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/lib/strategies/accept-version.js?");

/***/ }),

/***/ "../../../node_modules/find-my-way/node.js":
/*!*************************************************!*\
  !*** ../../../node_modules/find-my-way/node.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst deepEqual = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\")\n\nconst types = {\n  STATIC: 0,\n  PARAM: 1,\n  MATCH_ALL: 2,\n  REGEX: 3,\n  // It's used for a parameter, that is followed by another parameter in the same part\n  MULTI_PARAM: 4\n}\n\nfunction Node (options) {\n  options = options || {}\n  this.prefix = options.prefix || '/'\n  this.label = this.prefix[0]\n  this.method = options.method // not used for logic, just for debugging and pretty printing\n  this.handlers = options.handlers || [] // unoptimized list of handler objects for which the fast matcher function will be compiled\n  this.unconstrainedHandler = options.unconstrainedHandler || null // optimized reference to the handler that will match most of the time\n  this.children = options.children || {}\n  this.numberOfChildren = Object.keys(this.children).length\n  this.kind = options.kind || this.types.STATIC\n  this.regex = options.regex || null\n  this.wildcardChild = null\n  this.parametricBrother = null\n  this.constrainer = options.constrainer\n  this.hasConstraints = options.hasConstraints || false\n  this.constrainedHandlerStores = null\n}\n\nObject.defineProperty(Node.prototype, 'types', {\n  value: types\n})\n\nNode.prototype.getLabel = function () {\n  return this.prefix[0]\n}\n\nNode.prototype.addChild = function (node) {\n  var label = ''\n  switch (node.kind) {\n    case this.types.STATIC:\n      label = node.getLabel()\n      break\n    case this.types.PARAM:\n    case this.types.REGEX:\n    case this.types.MULTI_PARAM:\n      label = ':'\n      break\n    case this.types.MATCH_ALL:\n      this.wildcardChild = node\n      label = '*'\n      break\n    default:\n      throw new Error(`Unknown node kind: ${node.kind}`)\n  }\n\n  assert(\n    this.children[label] === undefined,\n    `There is already a child with label '${label}'`\n  )\n\n  this.children[label] = node\n\n  const nodeChildren = Object.values(this.children)\n  this.numberOfChildren = nodeChildren.length\n\n  this._saveParametricBrother()\n\n  return this\n}\n\nNode.prototype._saveParametricBrother = function () {\n  let parametricBrother = this.parametricBrother\n  for (const child of Object.values(this.children)) {\n    if (child.prefix === ':') {\n      parametricBrother = child\n      break\n    }\n  }\n\n  // Save the parametric brother inside static children\n  if (parametricBrother) {\n    for (const child of Object.values(this.children)) {\n      if (child && child.kind === this.types.STATIC) {\n        child.parametricBrother = parametricBrother\n        child._saveParametricBrother(parametricBrother)\n      }\n    }\n  }\n}\n\nNode.prototype.reset = function (prefix) {\n  this.prefix = prefix\n  this.children = {}\n  this.handlers = []\n  this.unconstrainedHandler = null\n  this.kind = this.types.STATIC\n  this.numberOfChildren = 0\n  this.regex = null\n  this.wildcardChild = null\n  this.hasConstraints = false\n  this._decompileGetHandlerMatchingConstraints()\n  return this\n}\n\nNode.prototype.split = function (length) {\n  const newChild = new Node(\n    {\n      prefix: this.prefix.slice(length),\n      children: this.children,\n      kind: this.kind,\n      method: this.method,\n      handlers: this.handlers.slice(0),\n      regex: this.regex,\n      constrainer: this.constrainer,\n      hasConstraints: this.hasConstraints,\n      unconstrainedHandler: this.unconstrainedHandler\n    }\n  )\n\n  if (this.wildcardChild !== null) {\n    newChild.wildcardChild = this.wildcardChild\n  }\n\n  this.reset(this.prefix.slice(0, length))\n  this.addChild(newChild)\n  return newChild\n}\n\nNode.prototype.findByLabel = function (path) {\n  return this.children[path[0]]\n}\n\nNode.prototype.findMatchingChild = function (derivedConstraints, path) {\n  var child = this.children[path[0]]\n  if (child !== undefined && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {\n    if (path.slice(0, child.prefix.length) === child.prefix) {\n      return child\n    }\n  }\n\n  child = this.children[':']\n  if (child !== undefined && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {\n    return child\n  }\n\n  child = this.children['*']\n  if (child !== undefined && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {\n    return child\n  }\n\n  return null\n}\n\nNode.prototype.addHandler = function (handler, params, store, constraints) {\n  if (!handler) return\n  assert(!this.getHandler(constraints), `There is already a handler with constraints '${JSON.stringify(constraints)}' and method '${this.method}'`)\n\n  const handlerObject = {\n    handler: handler,\n    params: params,\n    constraints: constraints,\n    store: store || null,\n    paramsLength: params.length\n  }\n\n  this.handlers.push(handlerObject)\n  // Sort the most constrained handlers to the front of the list of handlers so they are tested first.\n  this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length)\n\n  if (Object.keys(constraints).length > 0) {\n    this.hasConstraints = true\n  } else {\n    this.unconstrainedHandler = handlerObject\n  }\n\n  if (this.hasConstraints && this.handlers.length > 32) {\n    throw new Error('find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached')\n  }\n\n  // Note that the fancy constraint handler matcher needs to be recompiled now that the list of handlers has changed\n  // This lazy compilation means we don't do the compile until the first time the route match is tried, which doesn't waste time re-compiling every time a new handler is added\n  this._decompileGetHandlerMatchingConstraints()\n}\n\nNode.prototype.getHandler = function (constraints) {\n  return this.handlers.filter(handler => deepEqual(constraints, handler.constraints))[0]\n}\n\n// We compile the handler matcher the first time this node is matched. We need to recompile it if new handlers are added, so when a new handler is added, we reset the handler matching function to this base one that will recompile it.\nfunction compileThenGetHandlerMatchingConstraints (derivedConstraints) {\n  this._compileGetHandlerMatchingConstraints()\n  return this._getHandlerMatchingConstraints(derivedConstraints)\n}\n\n// This is the hot path for node handler finding -- change with care!\nNode.prototype.getMatchingHandler = function (derivedConstraints) {\n  if (this.hasConstraints) {\n    // This node is constrained, use the performant precompiled constraint matcher\n    return this._getHandlerMatchingConstraints(derivedConstraints)\n  } else {\n    // This node doesn't have any handlers that are constrained, so it's handlers probably match. Some requests have constraint values that *must* match however, like version, so check for those before returning it.\n    if (derivedConstraints && derivedConstraints.__hasMustMatchValues) {\n      return null\n    } else {\n      return this.unconstrainedHandler\n    }\n  }\n}\n\n// Slot for the compiled constraint matching function\nNode.prototype._getHandlerMatchingConstraints = compileThenGetHandlerMatchingConstraints\n\nNode.prototype._decompileGetHandlerMatchingConstraints = function () {\n  this._getHandlerMatchingConstraints = compileThenGetHandlerMatchingConstraints\n  return null\n}\n\n// Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value\n// So for a host constraint, this might look like { \"fastify.io\": 0b0010, \"google.ca\": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.\n// The store's implementation comes from the strategies provided to the Router.\nNode.prototype._buildConstraintStore = function (constraint) {\n  const store = this.constrainer.newStoreForConstraint(constraint)\n\n  for (let i = 0; i < this.handlers.length; i++) {\n    const handler = this.handlers[i]\n    const mustMatchValue = handler.constraints[constraint]\n    if (typeof mustMatchValue !== 'undefined') {\n      let indexes = store.get(mustMatchValue)\n      if (!indexes) {\n        indexes = 0\n      }\n      indexes |= 1 << i // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip\n      store.set(mustMatchValue, indexes)\n    }\n  }\n\n  return store\n}\n\n// Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.\nNode.prototype._constrainedIndexBitmask = function (constraint) {\n  let mask = 0b0\n  for (let i = 0; i < this.handlers.length; i++) {\n    const handler = this.handlers[i]\n    if (handler.constraints && constraint in handler.constraints) {\n      mask |= 1 << i\n    }\n  }\n  return ~mask\n}\n\n// Compile a fast function to match the handlers for this node\n// The function implements a general case multi-constraint matching algorithm.\n// The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.\n// We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.\n// We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.\n// We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.\nNode.prototype._compileGetHandlerMatchingConstraints = function () {\n  this.constrainedHandlerStores = {}\n  let constraints = new Set()\n  for (const handler of this.handlers) {\n    for (const key of Object.keys(handler.constraints)) {\n      constraints.add(key)\n    }\n  }\n  constraints = Array.from(constraints)\n  const lines = []\n\n  // always check the version constraint first as it is the most selective\n  constraints.sort((a, b) => a === 'version' ? 1 : 0)\n\n  for (const constraint of constraints) {\n    this.constrainedHandlerStores[constraint] = this._buildConstraintStore(constraint)\n  }\n\n  lines.push(`\n  let candidates = 0b${'1'.repeat(this.handlers.length)}\n  let mask, matches\n  `)\n  for (const constraint of constraints) {\n    // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.\n    lines.push(`\n    mask = ${this._constrainedIndexBitmask(constraint)}\n    value = derivedConstraints.${constraint}\n    `)\n\n    // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.\n    // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.\n    lines.push(`\n    if (typeof value === \"undefined\") {\n      candidates &= mask\n    } else {\n      matches = this.constrainedHandlerStores.${constraint}.get(value) || 0\n      candidates &= (matches | mask)\n    }\n    if (candidates === 0) return null;\n    `)\n  }\n  // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit\n  lines.push(`\n  const handler = this.handlers[Math.floor(Math.log2(candidates))]\n  if (handler && derivedConstraints.__hasMustMatchValues && handler === this.unconstrainedHandler) {\n    return null;\n  }\n  return handler;\n  `)\n\n  this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\\n')) // eslint-disable-line\n}\n\nmodule.exports = Node\n\n\n//# sourceURL=webpack://qui/../../../node_modules/find-my-way/node.js?");

/***/ }),

/***/ "../../../node_modules/flatstr/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/flatstr/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// You may be tempted to copy and paste this, \n// but take a look at the commit history first,\n// this is a moving target so relying on the module\n// is the best way to make sure the optimization\n// method is kept up to date and compatible with\n// every Node version.\n\nfunction flatstr (s) {\n  s | 0\n  return s\n}\n\nmodule.exports = flatstr\n\n//# sourceURL=webpack://qui/../../../node_modules/flatstr/index.js?");

/***/ }),

/***/ "../../../node_modules/forwarded/index.js":
/*!************************************************!*\
  !*** ../../../node_modules/forwarded/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * forwarded\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = forwarded\n\n/**\n * Get all addresses in the request, using the `X-Forwarded-For` header.\n *\n * @param {object} req\n * @return {array}\n * @public\n */\n\nfunction forwarded (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  // simple header parsing\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')\n  var socketAddr = getSocketAddr(req)\n  var addrs = [socketAddr].concat(proxyAddrs)\n\n  // return all addresses\n  return addrs\n}\n\n/**\n * Get the socket address for a request.\n *\n * @param {object} req\n * @return {string}\n * @private\n */\n\nfunction getSocketAddr (req) {\n  return req.socket\n    ? req.socket.remoteAddress\n    : req.connection.remoteAddress\n}\n\n/**\n * Parse the X-Forwarded-For header.\n *\n * @param {string} header\n * @private\n */\n\nfunction parse (header) {\n  var end = header.length\n  var list = []\n  var start = header.length\n\n  // gather addresses, backwards\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i\n        }\n        break\n      case 0x2c: /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end))\n        }\n        start = end = i\n        break\n      default:\n        start = i\n        break\n    }\n  }\n\n  // final address\n  if (start !== end) {\n    list.push(header.substring(start, end))\n  }\n\n  return list\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/forwarded/index.js?");

/***/ }),

/***/ "../../../node_modules/fresh/index.js":
/*!********************************************!*\
  !*** ../../../node_modules/fresh/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * RegExp to check for no-cache token in Cache-Control.\n * @private\n */\n\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = fresh\n\n/**\n * Check freshness of the response using request and response headers.\n *\n * @param {Object} reqHeaders\n * @param {Object} resHeaders\n * @return {Boolean}\n * @public\n */\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders['if-modified-since']\n  var noneMatch = reqHeaders['if-none-match']\n\n  // unconditional request\n  if (!modifiedSince && !noneMatch) {\n    return false\n  }\n\n  // Always return stale when Cache-Control: no-cache\n  // to support end-to-end reload requests\n  // https://tools.ietf.org/html/rfc2616#section-14.9.4\n  var cacheControl = reqHeaders['cache-control']\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch && noneMatch !== '*') {\n    var etag = resHeaders['etag']\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders['last-modified']\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  // istanbul ignore next: guard against date.js Date.parse patching\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fresh/index.js?");

/***/ }),

/***/ "../../../node_modules/fs.realpath/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fs.realpath/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"../../../node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fs.realpath/index.js?");

/***/ }),

/***/ "../../../node_modules/fs.realpath/old.js":
/*!************************************************!*\
  !*** ../../../node_modules/fs.realpath/old.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fs.realpath/old.js?");

/***/ }),

/***/ "../../../node_modules/glob/common.js":
/*!********************************************!*\
  !*** ../../../node_modules/glob/common.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../../../node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../../../node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b, 'en')\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n  self.fs = options.fs || fs\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/glob/common.js?");

/***/ }),

/***/ "../../../node_modules/glob/glob.js":
/*!******************************************!*\
  !*** ../../../node_modules/glob/glob.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"../../../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../../../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../../../node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"../../../node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../../../node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"../../../node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"../../../node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    self.fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    self.fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/glob/glob.js?");

/***/ }),

/***/ "../../../node_modules/glob/sync.js":
/*!******************************************!*\
  !*** ../../../node_modules/glob/sync.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"../../../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../../../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"../../../node_modules/glob/glob.js\").Glob)\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../../../node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../../../node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = this.fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = this.fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/glob/sync.js?");

/***/ }),

/***/ "../../../node_modules/has-flag/index.js":
/*!***********************************************!*\
  !*** ../../../node_modules/has-flag/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/has-flag/index.js?");

/***/ }),

/***/ "../../../node_modules/http-errors/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/http-errors/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * http-errors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = __webpack_require__(/*! depd */ \"../../../node_modules/depd/index.js\")('http-errors')\nvar setPrototypeOf = __webpack_require__(/*! setprototypeof */ \"../../../node_modules/setprototypeof/index.js\")\nvar statuses = __webpack_require__(/*! statuses */ \"../../../node_modules/statuses/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")\nvar toIdentifier = __webpack_require__(/*! toidentifier */ \"../../../node_modules/toidentifier/index.js\")\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = createError\nmodule.exports.HttpError = createHttpErrorConstructor()\nmodule.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError)\n\n// Populate exports for all constructors\npopulateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)\n\n/**\n * Get the code class of a status code.\n * @private\n */\n\nfunction codeClass (status) {\n  return Number(String(status).charAt(0) + '00')\n}\n\n/**\n * Create a new HTTP Error.\n *\n * @returns {Error}\n * @public\n */\n\nfunction createError () {\n  // so much arity going on ~_~\n  var err\n  var msg\n  var status = 500\n  var props = {}\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i]\n    if (arg instanceof Error) {\n      err = arg\n      status = err.status || err.statusCode || status\n      continue\n    }\n    switch (typeof arg) {\n      case 'string':\n        msg = arg\n        break\n      case 'number':\n        status = arg\n        if (i !== 0) {\n          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')\n        }\n        break\n      case 'object':\n        props = arg\n        break\n    }\n  }\n\n  if (typeof status === 'number' && (status < 400 || status >= 600)) {\n    deprecate('non-error status code; use only 4xx or 5xx status codes')\n  }\n\n  if (typeof status !== 'number' ||\n    (!statuses[status] && (status < 400 || status >= 600))) {\n    status = 500\n  }\n\n  // constructor\n  var HttpError = createError[status] || createError[codeClass(status)]\n\n  if (!err) {\n    // create error\n    err = HttpError\n      ? new HttpError(msg)\n      : new Error(msg || statuses[status])\n    Error.captureStackTrace(err, createError)\n  }\n\n  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {\n    // add properties to generic error\n    err.expose = status < 500\n    err.status = err.statusCode = status\n  }\n\n  for (var key in props) {\n    if (key !== 'status' && key !== 'statusCode') {\n      err[key] = props[key]\n    }\n  }\n\n  return err\n}\n\n/**\n * Create HTTP error abstract base class.\n * @private\n */\n\nfunction createHttpErrorConstructor () {\n  function HttpError () {\n    throw new TypeError('cannot construct abstract class')\n  }\n\n  inherits(HttpError, Error)\n\n  return HttpError\n}\n\n/**\n * Create a constructor for a client error.\n * @private\n */\n\nfunction createClientErrorConstructor (HttpError, name, code) {\n  var className = toClassName(name)\n\n  function ClientError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ClientError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ClientError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ClientError, HttpError)\n  nameFunc(ClientError, className)\n\n  ClientError.prototype.status = code\n  ClientError.prototype.statusCode = code\n  ClientError.prototype.expose = true\n\n  return ClientError\n}\n\n/**\n * Create function to test is a value is a HttpError.\n * @private\n */\n\nfunction createIsHttpErrorFunction (HttpError) {\n  return function isHttpError (val) {\n    if (!val || typeof val !== 'object') {\n      return false\n    }\n\n    if (val instanceof HttpError) {\n      return true\n    }\n\n    return val instanceof Error &&\n      typeof val.expose === 'boolean' &&\n      typeof val.statusCode === 'number' && val.status === val.statusCode\n  }\n}\n\n/**\n * Create a constructor for a server error.\n * @private\n */\n\nfunction createServerErrorConstructor (HttpError, name, code) {\n  var className = toClassName(name)\n\n  function ServerError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ServerError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ServerError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ServerError, HttpError)\n  nameFunc(ServerError, className)\n\n  ServerError.prototype.status = code\n  ServerError.prototype.statusCode = code\n  ServerError.prototype.expose = false\n\n  return ServerError\n}\n\n/**\n * Set the name of a function, if possible.\n * @private\n */\n\nfunction nameFunc (func, name) {\n  var desc = Object.getOwnPropertyDescriptor(func, 'name')\n\n  if (desc && desc.configurable) {\n    desc.value = name\n    Object.defineProperty(func, 'name', desc)\n  }\n}\n\n/**\n * Populate the exports object with constructors for every error class.\n * @private\n */\n\nfunction populateConstructorExports (exports, codes, HttpError) {\n  codes.forEach(function forEachCode (code) {\n    var CodeError\n    var name = toIdentifier(statuses[code])\n\n    switch (codeClass(code)) {\n      case 400:\n        CodeError = createClientErrorConstructor(HttpError, name, code)\n        break\n      case 500:\n        CodeError = createServerErrorConstructor(HttpError, name, code)\n        break\n    }\n\n    if (CodeError) {\n      // export the constructor\n      exports[code] = CodeError\n      exports[name] = CodeError\n    }\n  })\n\n  // backwards-compatibility\n  exports[\"I'mateapot\"] = deprecate.function(exports.ImATeapot,\n    '\"I\\'mateapot\"; use \"ImATeapot\" instead')\n}\n\n/**\n * Get a class name from a name identifier.\n * @private\n */\n\nfunction toClassName (name) {\n  return name.substr(-5) !== 'Error'\n    ? name + 'Error'\n    : name\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/http-errors/index.js?");

/***/ }),

/***/ "../../../node_modules/inflight/inflight.js":
/*!**************************************************!*\
  !*** ../../../node_modules/inflight/inflight.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../../../node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"../../../node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/inflight/inflight.js?");

/***/ }),

/***/ "../../../node_modules/inherits/inherits.js":
/*!**************************************************!*\
  !*** ../../../node_modules/inherits/inherits.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"../../../node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/inherits/inherits.js?");

/***/ }),

/***/ "../../../node_modules/inherits/inherits_browser.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/inherits/inherits_browser.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "../../../node_modules/ipaddr.js/lib/ipaddr.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/ipaddr.js/lib/ipaddr.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function() {\n  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;\n\n  ipaddr = {};\n\n  root = this;\n\n  if (( true && module !== null) && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root['ipaddr'] = ipaddr;\n  }\n\n  matchCIDR = function(first, second, partSize, cidrBits) {\n    var part, shift;\n    if (first.length !== second.length) {\n      throw new Error(\"ipaddr: cannot match CIDR for objects with different lengths\");\n    }\n    part = 0;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  };\n\n  ipaddr.subnetMatch = function(address, rangeList, defaultName) {\n    var k, len, rangeName, rangeSubnets, subnet;\n    if (defaultName == null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      rangeSubnets = rangeList[rangeName];\n      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n        rangeSubnets = [rangeSubnets];\n      }\n      for (k = 0, len = rangeSubnets.length; k < len; k++) {\n        subnet = rangeSubnets[k];\n        if (address.kind() === subnet[0].kind()) {\n          if (address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  ipaddr.IPv4 = (function() {\n    function IPv4(octets) {\n      var k, len, octet;\n      if (octets.length !== 4) {\n        throw new Error(\"ipaddr: ipv4 octet count should be 4\");\n      }\n      for (k = 0, len = octets.length; k < len; k++) {\n        octet = octets[k];\n        if (!((0 <= octet && octet <= 255))) {\n          throw new Error(\"ipaddr: ipv4 octet should fit in 8 bits\");\n        }\n      }\n      this.octets = octets;\n    }\n\n    IPv4.prototype.kind = function() {\n      return 'ipv4';\n    };\n\n    IPv4.prototype.toString = function() {\n      return this.octets.join(\".\");\n    };\n\n    IPv4.prototype.toNormalizedString = function() {\n      return this.toString();\n    };\n\n    IPv4.prototype.toByteArray = function() {\n      return this.octets.slice(0);\n    };\n\n    IPv4.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error(\"ipaddr: cannot match ipv4 address with non-ipv4 one\");\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      \"private\": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    };\n\n    IPv4.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv4.prototype.toIPv4MappedAddress = function() {\n      return ipaddr.IPv6.parse(\"::ffff:\" + (this.toString()));\n    };\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, octet, stop, zeros, zerotable;\n      zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 3; k >= 0; i = k += -1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    return IPv4;\n\n  })();\n\n  ipv4Part = \"(0?\\\\d+|0x[a-f0-9]+)\";\n\n  ipv4Regexes = {\n    fourOctet: new RegExp(\"^\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"$\", 'i'),\n    longValue: new RegExp(\"^\" + ipv4Part + \"$\", 'i')\n  };\n\n  ipaddr.IPv4.parser = function(string) {\n    var match, parseIntAuto, part, shift, value;\n    parseIntAuto = function(string) {\n      if (string[0] === \"0\" && string[1] !== \"x\") {\n        return parseInt(string, 8);\n      } else {\n        return parseInt(string);\n      }\n    };\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return (function() {\n        var k, len, ref, results;\n        ref = match.slice(1, 6);\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      })();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error(\"ipaddr: address outside defined range\");\n      }\n      return ((function() {\n        var k, results;\n        results = [];\n        for (shift = k = 0; k <= 24; shift = k += 8) {\n          results.push((value >> shift) & 0xff);\n        }\n        return results;\n      })()).reverse();\n    } else {\n      return null;\n    }\n  };\n\n  ipaddr.IPv6 = (function() {\n    function IPv6(parts, zoneId) {\n      var i, k, l, len, part, ref;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = k = 0; k <= 14; i = k += 2) {\n          this.parts.push((parts[i] << 8) | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error(\"ipaddr: ipv6 part count should be 8 or 16\");\n      }\n      ref = this.parts;\n      for (l = 0, len = ref.length; l < len; l++) {\n        part = ref[l];\n        if (!((0 <= part && part <= 0xffff))) {\n          throw new Error(\"ipaddr: ipv6 part should fit in 16 bits\");\n        }\n      }\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    }\n\n    IPv6.prototype.kind = function() {\n      return 'ipv6';\n    };\n\n    IPv6.prototype.toString = function() {\n      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n    };\n\n    IPv6.prototype.toRFC5952String = function() {\n      var bestMatchIndex, bestMatchLength, match, regex, string;\n      regex = /((^|:)(0(:|$)){2,})/g;\n      string = this.toNormalizedString();\n      bestMatchIndex = 0;\n      bestMatchLength = -1;\n      while ((match = regex.exec(string))) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n      if (bestMatchLength < 0) {\n        return string;\n      }\n      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);\n    };\n\n    IPv6.prototype.toByteArray = function() {\n      var bytes, k, len, part, ref;\n      bytes = [];\n      ref = this.parts;\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    IPv6.prototype.toNormalizedString = function() {\n      var addr, part, suffix;\n      addr = ((function() {\n        var k, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(part.toString(16));\n        }\n        return results;\n      }).call(this)).join(\":\");\n      suffix = '';\n      if (this.zoneId) {\n        suffix = '%' + this.zoneId;\n      }\n      return addr + suffix;\n    };\n\n    IPv6.prototype.toFixedLengthString = function() {\n      var addr, part, suffix;\n      addr = ((function() {\n        var k, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(part.toString(16).padStart(4, '0'));\n        }\n        return results;\n      }).call(this)).join(\":\");\n      suffix = '';\n      if (this.zoneId) {\n        suffix = '%' + this.zoneId;\n      }\n      return addr + suffix;\n    };\n\n    IPv6.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error(\"ipaddr: cannot match ipv6 address with non-ipv6 one\");\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    IPv6.prototype.SpecialRanges = {\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    IPv6.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv6.prototype.isIPv4MappedAddress = function() {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    IPv6.prototype.toIPv4Address = function() {\n      var high, low, ref;\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error(\"ipaddr: trying to convert a generic ipv6 address to ipv4\");\n      }\n      ref = this.parts.slice(-2), high = ref[0], low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    IPv6.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, part, stop, zeros, zerotable;\n      zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 7; k >= 0; i = k += -1) {\n        part = this.parts[i];\n        if (part in zerotable) {\n          zeros = zerotable[part];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 16) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 128 - cidr;\n    };\n\n    return IPv6;\n\n  })();\n\n  ipv6Part = \"(?:[0-9a-f]+::?)+\";\n\n  zoneIndex = \"%[0-9a-z]{1,}\";\n\n  ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    \"native\": new RegExp(\"^(::)?(\" + ipv6Part + \")?([0-9a-f]+)?(::)?(\" + zoneIndex + \")?$\", 'i'),\n    transitional: new RegExp((\"^((?:\" + ipv6Part + \")|(?:::)(?:\" + ipv6Part + \")?)\") + (ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part) + (\"(\" + zoneIndex + \")?$\"), 'i')\n  };\n\n  expandIPv6 = function(string, parts) {\n    var colonCount, lastColon, part, replacement, replacementCount, zoneId;\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    }\n    colonCount = 0;\n    lastColon = -1;\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n    if (colonCount > parts) {\n      return null;\n    }\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n    string = string.replace('::', replacement);\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    parts = (function() {\n      var k, len, ref, results;\n      ref = string.split(\":\");\n      results = [];\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        results.push(parseInt(part, 16));\n      }\n      return results;\n    })();\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  };\n\n  ipaddr.IPv6.parser = function(string) {\n    var addr, k, len, match, octet, octets, zoneId;\n    if (ipv6Regexes['native'].test(string)) {\n      return expandIPv6(string, 8);\n    } else if (match = string.match(ipv6Regexes['transitional'])) {\n      zoneId = match[6] || '';\n      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (k = 0, len = octets.length; k < len; k++) {\n          octet = octets[k];\n          if (!((0 <= octet && octet <= 255))) {\n            return null;\n          }\n        }\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n    return null;\n  };\n\n  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {\n    return this.parser(string) !== null;\n  };\n\n  ipaddr.IPv4.isValid = function(string) {\n    var e;\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.isValidFourPartDecimal = function(string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ipaddr.IPv6.isValid = function(string) {\n    var addr, e;\n    if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n      return false;\n    }\n    try {\n      addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.parse = function(string) {\n    var parts;\n    parts = this.parser(string);\n    if (parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(parts);\n  };\n\n  ipaddr.IPv6.parse = function(string) {\n    var addr;\n    addr = this.parser(string);\n    if (addr.parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(addr.parts, addr.zoneId);\n  };\n\n  ipaddr.IPv4.parseCIDR = function(string) {\n    var maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv4 CIDR range\");\n  };\n\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {\n    var filledOctetCount, j, octets;\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n    octets = [0, 0, 0, 0];\n    j = 0;\n    filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n    }\n    return new this(octets);\n  };\n\n  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv4.networkAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv6.parseCIDR = function(string) {\n    var maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv6 CIDR range\");\n  };\n\n  ipaddr.isValid = function(string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  ipaddr.parse = function(string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 format\");\n    }\n  };\n\n  ipaddr.parseCIDR = function(string) {\n    var e;\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (error1) {\n      e = error1;\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (error1) {\n        e = error1;\n        throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 CIDR format\");\n      }\n    }\n  };\n\n  ipaddr.fromByteArray = function(bytes) {\n    var length;\n    length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error(\"ipaddr: the binary input is neither an IPv6 nor IPv4 address\");\n    }\n  };\n\n  ipaddr.process = function(string) {\n    var addr;\n    addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ipaddr.js/lib/ipaddr.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/js-yaml/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar loader = __webpack_require__(/*! ./lib/loader */ \"../../../node_modules/js-yaml/lib/loader.js\");\nvar dumper = __webpack_require__(/*! ./lib/dumper */ \"../../../node_modules/js-yaml/lib/dumper.js\");\n\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nmodule.exports.Type = __webpack_require__(/*! ./lib/type */ \"../../../node_modules/js-yaml/lib/type.js\");\nmodule.exports.Schema = __webpack_require__(/*! ./lib/schema */ \"../../../node_modules/js-yaml/lib/schema.js\");\nmodule.exports.FAILSAFE_SCHEMA = __webpack_require__(/*! ./lib/schema/failsafe */ \"../../../node_modules/js-yaml/lib/schema/failsafe.js\");\nmodule.exports.JSON_SCHEMA = __webpack_require__(/*! ./lib/schema/json */ \"../../../node_modules/js-yaml/lib/schema/json.js\");\nmodule.exports.CORE_SCHEMA = __webpack_require__(/*! ./lib/schema/core */ \"../../../node_modules/js-yaml/lib/schema/core.js\");\nmodule.exports.DEFAULT_SCHEMA = __webpack_require__(/*! ./lib/schema/default */ \"../../../node_modules/js-yaml/lib/schema/default.js\");\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.YAMLException = __webpack_require__(/*! ./lib/exception */ \"../../../node_modules/js-yaml/lib/exception.js\");\n\n// Re-export all types in case user wants to create custom schema\nmodule.exports.types = {\n  binary:    __webpack_require__(/*! ./lib/type/binary */ \"../../../node_modules/js-yaml/lib/type/binary.js\"),\n  float:     __webpack_require__(/*! ./lib/type/float */ \"../../../node_modules/js-yaml/lib/type/float.js\"),\n  map:       __webpack_require__(/*! ./lib/type/map */ \"../../../node_modules/js-yaml/lib/type/map.js\"),\n  null:      __webpack_require__(/*! ./lib/type/null */ \"../../../node_modules/js-yaml/lib/type/null.js\"),\n  pairs:     __webpack_require__(/*! ./lib/type/pairs */ \"../../../node_modules/js-yaml/lib/type/pairs.js\"),\n  set:       __webpack_require__(/*! ./lib/type/set */ \"../../../node_modules/js-yaml/lib/type/set.js\"),\n  timestamp: __webpack_require__(/*! ./lib/type/timestamp */ \"../../../node_modules/js-yaml/lib/type/timestamp.js\"),\n  bool:      __webpack_require__(/*! ./lib/type/bool */ \"../../../node_modules/js-yaml/lib/type/bool.js\"),\n  int:       __webpack_require__(/*! ./lib/type/int */ \"../../../node_modules/js-yaml/lib/type/int.js\"),\n  merge:     __webpack_require__(/*! ./lib/type/merge */ \"../../../node_modules/js-yaml/lib/type/merge.js\"),\n  omap:      __webpack_require__(/*! ./lib/type/omap */ \"../../../node_modules/js-yaml/lib/type/omap.js\"),\n  seq:       __webpack_require__(/*! ./lib/type/seq */ \"../../../node_modules/js-yaml/lib/type/seq.js\"),\n  str:       __webpack_require__(/*! ./lib/type/str */ \"../../../node_modules/js-yaml/lib/type/str.js\")\n};\n\n// Removed functions from JS-YAML 3.0.x\nmodule.exports.safeLoad            = renamed('safeLoad', 'load');\nmodule.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nmodule.exports.safeDump            = renamed('safeDump', 'dump');\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/index.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/common.js":
/*!***************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/common.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/common.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/dumper.js":
/*!***************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/dumper.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = __webpack_require__(/*! ./common */ \"../../../node_modules/js-yaml/lib/common.js\");\nvar YAMLException       = __webpack_require__(/*! ./exception */ \"../../../node_modules/js-yaml/lib/exception.js\");\nvar DEFAULT_SCHEMA      = __webpack_require__(/*! ./schema/default */ \"../../../node_modules/js-yaml/lib/schema/default.js\");\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/dumper.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/exception.js":
/*!******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/exception.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("// YAML error class. http://stackoverflow.com/questions/8458984\n//\n\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nmodule.exports = YAMLException;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/exception.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/loader.js":
/*!***************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/loader.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = __webpack_require__(/*! ./common */ \"../../../node_modules/js-yaml/lib/common.js\");\nvar YAMLException       = __webpack_require__(/*! ./exception */ \"../../../node_modules/js-yaml/lib/exception.js\");\nvar makeSnippet         = __webpack_require__(/*! ./snippet */ \"../../../node_modules/js-yaml/lib/snippet.js\");\nvar DEFAULT_SCHEMA      = __webpack_require__(/*! ./schema/default */ \"../../../node_modules/js-yaml/lib/schema/default.js\");\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = makeSnippet(mark);\n\n  return new YAMLException(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nmodule.exports.loadAll = loadAll;\nmodule.exports.load    = load;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/loader.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/schema.js":
/*!***************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/schema.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*eslint-disable max-len*/\n\nvar YAMLException = __webpack_require__(/*! ./exception */ \"../../../node_modules/js-yaml/lib/exception.js\");\nvar Type          = __webpack_require__(/*! ./type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/schema.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/schema/core.js":
/*!********************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/schema/core.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n\n\n\nmodule.exports = __webpack_require__(/*! ./json */ \"../../../node_modules/js-yaml/lib/schema/json.js\");\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/schema/core.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/schema/default.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/schema/default.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n\n\n\nmodule.exports = (__webpack_require__(/*! ./core */ \"../../../node_modules/js-yaml/lib/schema/core.js\").extend)({\n  implicit: [\n    __webpack_require__(/*! ../type/timestamp */ \"../../../node_modules/js-yaml/lib/type/timestamp.js\"),\n    __webpack_require__(/*! ../type/merge */ \"../../../node_modules/js-yaml/lib/type/merge.js\")\n  ],\n  explicit: [\n    __webpack_require__(/*! ../type/binary */ \"../../../node_modules/js-yaml/lib/type/binary.js\"),\n    __webpack_require__(/*! ../type/omap */ \"../../../node_modules/js-yaml/lib/type/omap.js\"),\n    __webpack_require__(/*! ../type/pairs */ \"../../../node_modules/js-yaml/lib/type/pairs.js\"),\n    __webpack_require__(/*! ../type/set */ \"../../../node_modules/js-yaml/lib/type/set.js\")\n  ]\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/schema/default.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/schema/failsafe.js":
/*!************************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/schema/failsafe.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n\n\n\nvar Schema = __webpack_require__(/*! ../schema */ \"../../../node_modules/js-yaml/lib/schema.js\");\n\n\nmodule.exports = new Schema({\n  explicit: [\n    __webpack_require__(/*! ../type/str */ \"../../../node_modules/js-yaml/lib/type/str.js\"),\n    __webpack_require__(/*! ../type/seq */ \"../../../node_modules/js-yaml/lib/type/seq.js\"),\n    __webpack_require__(/*! ../type/map */ \"../../../node_modules/js-yaml/lib/type/map.js\")\n  ]\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/schema/failsafe.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/schema/json.js":
/*!********************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/schema/json.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n\n\n\nmodule.exports = (__webpack_require__(/*! ./failsafe */ \"../../../node_modules/js-yaml/lib/schema/failsafe.js\").extend)({\n  implicit: [\n    __webpack_require__(/*! ../type/null */ \"../../../node_modules/js-yaml/lib/type/null.js\"),\n    __webpack_require__(/*! ../type/bool */ \"../../../node_modules/js-yaml/lib/type/bool.js\"),\n    __webpack_require__(/*! ../type/int */ \"../../../node_modules/js-yaml/lib/type/int.js\"),\n    __webpack_require__(/*! ../type/float */ \"../../../node_modules/js-yaml/lib/type/float.js\")\n  ]\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/schema/json.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/snippet.js":
/*!****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/snippet.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar common = __webpack_require__(/*! ./common */ \"../../../node_modules/js-yaml/lib/common.js\");\n\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nmodule.exports = makeSnippet;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/snippet.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type.js":
/*!*************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar YAMLException = __webpack_require__(/*! ./exception */ \"../../../node_modules/js-yaml/lib/exception.js\");\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/binary.js":
/*!********************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/binary.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/binary.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/bool.js":
/*!******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/bool.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/bool.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/float.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/float.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ../common */ \"../../../node_modules/js-yaml/lib/common.js\");\nvar Type   = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/float.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/int.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/int.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ../common */ \"../../../node_modules/js-yaml/lib/common.js\");\nvar Type   = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/int.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/map.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/map.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/map.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/merge.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/merge.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/merge.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/null.js":
/*!******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/null.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/null.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/omap.js":
/*!******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/omap.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/omap.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/pairs.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/pairs.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/pairs.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/seq.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/seq.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/seq.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/set.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/set.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/set.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/str.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/str.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/str.js?");

/***/ }),

/***/ "../../../node_modules/js-yaml/lib/type/timestamp.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/js-yaml/lib/type/timestamp.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Type = __webpack_require__(/*! ../type */ \"../../../node_modules/js-yaml/lib/type.js\");\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\n\n//# sourceURL=webpack://qui/../../../node_modules/js-yaml/lib/type/timestamp.js?");

/***/ }),

/***/ "../../../node_modules/json-schema-traverse/index.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/json-schema-traverse/index.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/json-schema-traverse/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/light-my-request/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst Ajv = __webpack_require__(/*! ajv */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/ajv.js\")\nconst Request = __webpack_require__(/*! ./lib/request */ \"../../../node_modules/light-my-request/lib/request.js\")\nconst Response = __webpack_require__(/*! ./lib/response */ \"../../../node_modules/light-my-request/lib/response.js\")\n\nconst errorMessage = 'The dispatch function has already been invoked'\nconst urlSchema = {\n  oneOf: [\n    { type: 'string' },\n    {\n      type: 'object',\n      properties: {\n        protocol: { type: 'string' },\n        hostname: { type: 'string' },\n        pathname: { type: 'string' }\n        // port type => any\n        // query type => any\n      },\n      additionalProperties: true,\n      required: ['pathname']\n    }\n  ]\n}\n\nconst ajv = new Ajv()\nconst schema = {\n  type: 'object',\n  properties: {\n    url: urlSchema,\n    path: urlSchema,\n    cookies: {\n      type: 'object',\n      additionalProperties: true\n    },\n    headers: {\n      type: 'object',\n      additionalProperties: true\n    },\n    query: {\n      type: 'object',\n      additionalProperties: true\n    },\n    simulate: {\n      type: 'object',\n      properties: {\n        end: { type: 'boolean' },\n        split: { type: 'boolean' },\n        error: { type: 'boolean' },\n        close: { type: 'boolean' }\n      }\n    },\n    authority: { type: 'string' },\n    remoteAddress: { type: 'string' },\n    method: { type: 'string', enum: http.METHODS.concat(http.METHODS.map(toLowerCase)) },\n    validate: { type: 'boolean' }\n    // payload type => any\n  },\n  additionalProperties: true,\n  oneOf: [\n    { required: ['url'] },\n    { required: ['path'] }\n  ]\n}\n\nconst optsValidator = ajv.compile(schema)\n\nfunction inject (dispatchFunc, options, callback) {\n  if (typeof callback === 'undefined') {\n    return new Chain(dispatchFunc, options)\n  } else {\n    return doInject(dispatchFunc, options, callback)\n  }\n}\n\nfunction makeRequest (dispatchFunc, server, req, res) {\n  req.once('error', function (err) {\n    if (this.destroyed) res.destroy(err)\n  })\n\n  req.once('close', function () {\n    if (this.destroyed && !this._error) res.destroy()\n  })\n\n  return req.prepare(() => dispatchFunc.call(server, req, res))\n}\n\nfunction doInject (dispatchFunc, options, callback) {\n  options = (typeof options === 'string' ? { url: options } : options)\n\n  if (options.validate !== false) {\n    assert(typeof dispatchFunc === 'function', 'dispatchFunc should be a function')\n    const isOptionValid = optsValidator(options)\n    if (!isOptionValid) {\n      throw new Error(optsValidator.errors.map(e => e.message))\n    }\n  }\n\n  const server = options.server || {}\n\n  if (typeof callback === 'function') {\n    const req = new Request(options)\n    const res = new Response(req, callback)\n\n    return makeRequest(dispatchFunc, server, req, res)\n  } else {\n    return new Promise((resolve, reject) => {\n      const req = new Request(options)\n      const res = new Response(req, resolve, reject)\n\n      makeRequest(dispatchFunc, server, req, res)\n    })\n  }\n}\n\nfunction Chain (dispatch, option) {\n  if (typeof option === 'string') {\n    this.option = { url: option }\n  } else {\n    this.option = Object.assign({}, option)\n  }\n\n  this.dispatch = dispatch\n  this._hasInvoked = false\n  this._promise = null\n\n  if (this.option.autoStart !== false) {\n    process.nextTick(() => {\n      if (!this._hasInvoked) {\n        this.end()\n      }\n    })\n  }\n}\n\nconst httpMethods = [\n  'delete',\n  'get',\n  'head',\n  'options',\n  'patch',\n  'post',\n  'put',\n  'trace'\n]\n\nhttpMethods.forEach(method => {\n  Chain.prototype[method] = function (url) {\n    if (this._hasInvoked === true || this._promise) {\n      throw new Error(errorMessage)\n    }\n    this.option.url = url\n    this.option.method = method.toUpperCase()\n    return this\n  }\n})\n\nconst chainMethods = [\n  'body',\n  'cookies',\n  'headers',\n  'payload',\n  'query'\n]\n\nchainMethods.forEach(method => {\n  Chain.prototype[method] = function (value) {\n    if (this._hasInvoked === true || this._promise) {\n      throw new Error(errorMessage)\n    }\n    this.option[method] = value\n    return this\n  }\n})\n\nChain.prototype.end = function (callback) {\n  if (this._hasInvoked === true || this._promise) {\n    throw new Error(errorMessage)\n  }\n  this._hasInvoked = true\n  if (typeof callback === 'function') {\n    doInject(this.dispatch, this.option, callback)\n  } else {\n    this._promise = doInject(this.dispatch, this.option)\n    return this._promise\n  }\n}\n\nObject.getOwnPropertyNames(Promise.prototype).forEach(method => {\n  if (method === 'constructor') return\n  Chain.prototype[method] = function (...args) {\n    if (!this._promise) {\n      if (this._hasInvoked === true) {\n        throw new Error(errorMessage)\n      }\n      this._hasInvoked = true\n      this._promise = doInject(this.dispatch, this.option)\n    }\n    return this._promise[method](...args)\n  }\n})\n\nfunction isInjection (obj) {\n  return (obj instanceof Request || obj instanceof Response)\n}\n\nfunction toLowerCase (m) { return m.toLowerCase() }\n\nmodule.exports = inject\nmodule.exports.inject = inject\nmodule.exports.isInjection = isInjection\n\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/lib/parseURL.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/light-my-request/lib/parseURL.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { URL } = __webpack_require__(/*! url */ \"url\")\n\nconst BASE_URL = 'http://localhost'\n\n/**\n * Parse URL\n *\n * @param {(Object|String)} url\n * @param {Object} [query]\n * @return {URL}\n */\nmodule.exports = function parseURL (url, query) {\n  if ((typeof url === 'string' || Object.prototype.toString.call(url) === '[object String]') && url.startsWith('//')) {\n    url = BASE_URL + url\n  }\n  const result = typeof url === 'object'\n    ? Object.assign(new URL(BASE_URL), url)\n    : new URL(url, BASE_URL)\n\n  const merged = Object.assign({}, url.query, query)\n  for (const key in merged) {\n    const value = merged[key]\n\n    if (Array.isArray(value)) {\n      result.searchParams.delete(key)\n      for (const param of value) {\n        result.searchParams.append(key, param)\n      }\n    } else {\n      result.searchParams.set(key, value)\n    }\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/lib/parseURL.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/lib/request.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/light-my-request/lib/request.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\")\nconst util = __webpack_require__(/*! util */ \"util\")\nconst cookie = __webpack_require__(/*! cookie */ \"../../../node_modules/cookie/index.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst warning = __webpack_require__(/*! fastify-warning */ \"../../../node_modules/fastify-warning/index.js\")()\n\nconst parseURL = __webpack_require__(/*! ./parseURL */ \"../../../node_modules/light-my-request/lib/parseURL.js\")\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\")\n\n// request.connectin deprecation https://nodejs.org/api/http.html#http_request_connection\nwarning.create('FastifyDeprecationLightMyRequest', 'FST_LIGHTMYREQUEST_DEP01', 'You are accessing \"request.connection\", use \"request.socket\" instead.')\n\n/**\n * Get hostname:port\n *\n * @param {URL} parsedURL\n * @return {String}\n */\nfunction hostHeaderFromURL (parsedURL) {\n  return parsedURL.port\n    ? parsedURL.host\n    : parsedURL.hostname + (parsedURL.protocol === 'https:' ? ':443' : ':80')\n}\n\n/**\n * Mock socket object used to fake access to a socket for a request\n *\n * @constructor\n * @param {String} remoteAddress the fake address to show consumers of the socket\n */\nclass MockSocket extends EventEmitter {\n  constructor (remoteAddress) {\n    super()\n    this.remoteAddress = remoteAddress\n  }\n}\n\n/**\n * Request\n *\n * @constructor\n * @param {Object} options\n * @param {(Object|String)} options.url || options.path\n * @param {String} [options.method='GET']\n * @param {String} [options.remoteAddress]\n * @param {Object} [options.cookies]\n * @param {Object} [options.headers]\n * @param {Object} [options.query]\n * @param {any} [options.payload]\n */\nfunction Request (options) {\n  Readable.call(this, {\n    autoDestroy: false\n  })\n\n  const parsedURL = parseURL(options.url || options.path, options.query)\n\n  this.url = parsedURL.pathname + parsedURL.search\n\n  this.httpVersion = '1.1'\n  this.method = options.method ? options.method.toUpperCase() : 'GET'\n\n  this.headers = {}\n  this.rawHeaders = []\n  const headers = options.headers || {}\n\n  for (const field in headers) {\n    const value = headers[field]\n    assert(value !== undefined, 'invalid value \"undefined\" for header ' + field)\n    this.headers[field.toLowerCase()] = '' + value\n  }\n\n  this.headers['user-agent'] = this.headers['user-agent'] || 'lightMyRequest'\n  this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL)\n\n  if (options.cookies) {\n    const { cookies } = options\n    const cookieValues = Object.keys(cookies).map(key => cookie.serialize(key, cookies[key]))\n    if (this.headers.cookie) {\n      cookieValues.unshift(this.headers.cookie)\n    }\n    this.headers.cookie = cookieValues.join('; ')\n  }\n\n  this.socket = new MockSocket(options.remoteAddress || '127.0.0.1')\n\n  Object.defineProperty(this, 'connection', {\n    get () {\n      warning.emit('FST_LIGHTMYREQUEST_DEP01')\n      return this.socket\n    },\n    configurable: true\n  })\n\n  // we keep both payload and body for compatibility reasons\n  let payload = options.payload || options.body || null\n  const payloadResume = payload && typeof payload.resume === 'function'\n\n  if (payload && typeof payload !== 'string' && !payloadResume && !Buffer.isBuffer(payload)) {\n    payload = JSON.stringify(payload)\n    this.headers['content-type'] = this.headers['content-type'] || 'application/json'\n  }\n\n  // Set the content-length for the corresponding payload if none set\n  if (payload && !payloadResume && !this.headers.hasOwnProperty('content-length')) {\n    this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString()\n  }\n\n  for (const header of Object.keys(this.headers)) {\n    this.rawHeaders.push(header, this.headers[header])\n  }\n\n  // Use _lightMyRequest namespace to avoid collision with Node\n  this._lightMyRequest = {\n    payload,\n    isDone: false,\n    simulate: options.simulate || {}\n  }\n\n  return this\n}\n\nutil.inherits(Request, Readable)\n\nRequest.prototype.prepare = function (next) {\n  const payload = this._lightMyRequest.payload\n  if (!payload || typeof payload.resume !== 'function') { // does not quack like a stream\n    return next()\n  }\n\n  const chunks = []\n\n  payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)))\n\n  payload.on('end', () => {\n    const payload = Buffer.concat(chunks)\n    this.headers['content-length'] = this.headers['content-length'] || ('' + payload.length)\n    this._lightMyRequest.payload = payload\n    return next()\n  })\n\n  // Force to resume the stream. Needed for Stream 1\n  payload.resume()\n}\n\nRequest.prototype._read = function (size) {\n  setImmediate(() => {\n    if (this._lightMyRequest.isDone) {\n      // 'end' defaults to true\n      if (this._lightMyRequest.simulate.end !== false) {\n        this.push(null)\n      }\n\n      return\n    }\n\n    this._lightMyRequest.isDone = true\n\n    if (this._lightMyRequest.payload) {\n      if (this._lightMyRequest.simulate.split) {\n        this.push(this._lightMyRequest.payload.slice(0, 1))\n        this.push(this._lightMyRequest.payload.slice(1))\n      } else {\n        this.push(this._lightMyRequest.payload)\n      }\n    }\n\n    if (this._lightMyRequest.simulate.error) {\n      this.emit('error', new Error('Simulated'))\n    }\n\n    if (this._lightMyRequest.simulate.close) {\n      this.emit('close')\n    }\n\n    // 'end' defaults to true\n    if (this._lightMyRequest.simulate.end !== false) {\n      this.push(null)\n    }\n  })\n}\n\nRequest.prototype.destroy = function (error) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  if (error) {\n    this._error = true\n    process.nextTick(() => this.emit('error', error))\n  }\n\n  process.nextTick(() => this.emit('close'))\n}\n\nmodule.exports = Request\n\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/lib/request.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/lib/response.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/light-my-request/lib/response.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst http = __webpack_require__(/*! http */ \"http\")\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\")\nconst util = __webpack_require__(/*! util */ \"util\")\n\nconst setCookie = __webpack_require__(/*! set-cookie-parser */ \"../../../node_modules/set-cookie-parser/lib/set-cookie.js\")\n\nfunction Response (req, onEnd, reject) {\n  http.ServerResponse.call(this, {\n    method: req.method,\n    httpVersionMajor: 1,\n    httpVersionMinor: 1\n  })\n\n  this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] }\n  // This forces node@8 to always render the headers\n  this.setHeader('foo', 'bar'); this.removeHeader('foo')\n\n  this.assignSocket(getNullSocket())\n\n  this._promiseCallback = typeof reject === 'function'\n\n  let called = false\n  const onEndSuccess = (payload) => {\n    // no need to early-return if already called because this handler is bound `once`\n    called = true\n    if (this._promiseCallback) {\n      return process.nextTick(() => onEnd(payload))\n    }\n    process.nextTick(() => onEnd(null, payload))\n  }\n\n  const onEndFailure = (err) => {\n    if (called) return\n    called = true\n    if (this._promiseCallback) {\n      return process.nextTick(() => reject(err))\n    }\n    process.nextTick(() => onEnd(err, null))\n  }\n\n  this.once('finish', () => {\n    const res = generatePayload(this)\n    res.raw.req = req\n    onEndSuccess(res)\n  })\n\n  this.connection.once('error', onEndFailure)\n\n  this.once('error', onEndFailure)\n\n  this.once('close', onEndFailure)\n}\n\nutil.inherits(Response, http.ServerResponse)\n\nResponse.prototype.setTimeout = function (msecs, callback) {\n  this.timeoutHandle = setTimeout(() => {\n    this.emit('timeout')\n  }, msecs)\n  this.on('timeout', callback)\n  return this\n}\n\nResponse.prototype.writeHead = function () {\n  const result = http.ServerResponse.prototype.writeHead.apply(this, arguments)\n\n  copyHeaders(this)\n\n  return result\n}\n\nResponse.prototype.write = function (data, encoding, callback) {\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n  http.ServerResponse.prototype.write.call(this, data, encoding, callback)\n  this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding))\n  return true\n}\n\nResponse.prototype.end = function (data, encoding, callback) {\n  if (data) {\n    this.write(data, encoding)\n  }\n\n  http.ServerResponse.prototype.end.call(this, callback)\n\n  this.emit('finish')\n\n  // We need to emit 'close' otherwise stream.finished() would\n  // not pick it up on Node v16\n\n  this.destroy()\n}\n\nResponse.prototype.destroy = function (error) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  if (error) {\n    process.nextTick(() => this.emit('error', error))\n  }\n\n  process.nextTick(() => this.emit('close'))\n}\n\nResponse.prototype.addTrailers = function (trailers) {\n  for (const key in trailers) {\n    this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim()\n  }\n}\n\nfunction generatePayload (response) {\n  if (response._lightMyRequest.headers === null) {\n    copyHeaders(response)\n  }\n  // Prepare response object\n  const res = {\n    raw: {\n      res: response\n    },\n    headers: response._lightMyRequest.headers,\n    statusCode: response.statusCode,\n    statusMessage: response.statusMessage,\n    trailers: {},\n    get cookies () {\n      return setCookie.parse(this)\n    }\n  }\n\n  // Prepare payload and trailers\n  const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks)\n  res.rawPayload = rawBuffer\n\n  // we keep both of them for compatibility reasons\n  res.payload = rawBuffer.toString()\n  res.body = res.payload\n  res.trailers = response._lightMyRequest.trailers\n\n  // Prepare payload parsers\n  res.json = function parseJsonPayload () {\n    if (res.headers['content-type'].indexOf('application/json') < 0) {\n      throw new Error('The content-type of the response is not application/json')\n    }\n    return JSON.parse(this.payload)\n  }\n\n  return res\n}\n\n// Throws away all written data to prevent response from buffering payload\nfunction getNullSocket () {\n  return new Writable({\n    write (chunk, encoding, callback) {\n      setImmediate(callback)\n    }\n  })\n}\n\nfunction copyHeaders (response) {\n  response._lightMyRequest.headers = Object.assign({}, response.getHeaders())\n\n  // Add raw headers\n  ;['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {\n    const regex = new RegExp('\\\\r\\\\n' + name + ': ([^\\\\r]*)\\\\r\\\\n')\n    const field = response._header.match(regex)\n    if (field) {\n      response._lightMyRequest.headers[name.toLowerCase()] = field[1]\n    }\n  })\n}\n\nmodule.exports = Response\n\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/lib/response.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/ajv.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/ajv.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/core.js\");\nconst draft7_1 = __webpack_require__(/*! ./vocabularies/draft7 */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js\");\nconst discriminator_1 = __webpack_require__(/*! ./vocabularies/discriminator */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js\");\nconst draft7MetaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nmodule.exports = exports = Ajv;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = Ajv;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\n//# sourceMappingURL=ajv.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/ajv.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js\");\nconst scope_1 = __webpack_require__(/*! ./scope */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js\");\nvar code_2 = __webpack_require__(/*! ./code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return code_2._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return code_2.str; } }));\nObject.defineProperty(exports, \"strConcat\", ({ enumerable: true, get: function () { return code_2.strConcat; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return code_2.nil; } }));\nObject.defineProperty(exports, \"getProperty\", ({ enumerable: true, get: function () { return code_2.getProperty; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return code_2.stringify; } }));\nObject.defineProperty(exports, \"regexpCode\", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return code_2.Name; } }));\nvar scope_2 = __webpack_require__(/*! ./scope */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js\");\nObject.defineProperty(exports, \"Scope\", ({ enumerable: true, get: function () { return scope_2.Scope; } }));\nObject.defineProperty(exports, \"ValueScope\", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));\nObject.defineProperty(exports, \"ValueScopeName\", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));\nObject.defineProperty(exports, \"varKinds\", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"),\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst validation_error_1 = __webpack_require__(/*! ../runtime/validation_error */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"),\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"),\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"),\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"),\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"),\n    errors: new codegen_1.Name(\"errors\"),\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports[\"default\"] = names;\n//# sourceMappingURL=names.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports[\"default\"] = MissingRefError;\n//# sourceMappingURL=ref_error.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\");\nconst traverse = __webpack_require__(/*! json-schema-traverse */ \"../../../node_modules/light-my-request/node_modules/json-schema-traverse/index.js\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst code_1 = __webpack_require__(/*! ./codegen/code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = __webpack_require__(/*! ../rules */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assignDefaults = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = __webpack_require__(/*! ./boolSchema */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js\");\nconst dataType_1 = __webpack_require__(/*! ./dataType */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js\");\nconst dataType_2 = __webpack_require__(/*! ./dataType */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst defaults_1 = __webpack_require__(/*! ./defaults */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js\");\nconst keyword_1 = __webpack_require__(/*! ./keyword */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js\");\nconst subschema_1 = __webpack_require__(/*! ./subschema */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ../resolve */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst code_1 = __webpack_require__(/*! ../../vocabularies/code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/core.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/core.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nconst validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js\");\nconst ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js\");\nconst rules_1 = __webpack_require__(/*! ./compile/rules */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js\");\nconst compile_1 = __webpack_require__(/*! ./compile */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js\");\nconst codegen_2 = __webpack_require__(/*! ./compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst resolve_1 = __webpack_require__(/*! ./compile/resolve */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js\");\nconst dataType_1 = __webpack_require__(/*! ./compile/validate/dataType */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst util_1 = __webpack_require__(/*! ./compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst $dataRefSchema = __webpack_require__(/*! ./refs/data.json */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/refs/data.json\");\nconst uri_1 = __webpack_require__(/*! ./runtime/uri */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports[\"default\"] = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/core.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../../node_modules/fast-deep-equal/index.js\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports[\"default\"] = equal;\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports[\"default\"] = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uri = __webpack_require__(/*! uri-js */ \"../../../node_modules/uri-js/dist/es5/uri.all.js\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports[\"default\"] = uri;\n//# sourceMappingURL=uri.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports[\"default\"] = ValidationError;\n//# sourceMappingURL=validation_error.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalItems.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalProperties.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=allOf.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=anyOf.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=contains.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports[\"default\"] = def;\n//# sourceMappingURL=dependencies.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports[\"default\"] = def;\n//# sourceMappingURL=if.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst prefixItems_1 = __webpack_require__(/*! ./prefixItems */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\");\nconst items_1 = __webpack_require__(/*! ./items */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst items2020_1 = __webpack_require__(/*! ./items2020 */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js\");\nconst contains_1 = __webpack_require__(/*! ./contains */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js\");\nconst dependencies_1 = __webpack_require__(/*! ./dependencies */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst propertyNames_1 = __webpack_require__(/*! ./propertyNames */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst properties_1 = __webpack_require__(/*! ./properties */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js\");\nconst patternProperties_1 = __webpack_require__(/*! ./patternProperties */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\");\nconst not_1 = __webpack_require__(/*! ./not */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js\");\nconst anyOf_1 = __webpack_require__(/*! ./anyOf */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\");\nconst oneOf_1 = __webpack_require__(/*! ./oneOf */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\");\nconst allOf_1 = __webpack_require__(/*! ./allOf */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js\");\nconst if_1 = __webpack_require__(/*! ./if */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js\");\nconst thenElse_1 = __webpack_require__(/*! ./thenElse */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports[\"default\"] = getApplicator;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateTuple = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports[\"default\"] = def;\n//# sourceMappingURL=items.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=items2020.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=not.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=oneOf.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst util_2 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=patternProperties.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst items_1 = __webpack_require__(/*! ./items */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=prefixItems.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ../../compile/validate */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=properties.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=propertyNames.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=thenElse.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = __webpack_require__(/*! ../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ../compile/names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst util_2 = __webpack_require__(/*! ../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=id.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst id_1 = __webpack_require__(/*! ./id */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js\");\nconst ref_1 = __webpack_require__(/*! ./ref */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports[\"default\"] = core;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/names.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports[\"default\"] = def;\n//# sourceMappingURL=ref.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst types_1 = __webpack_require__(/*! ../discriminator/types */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core_1 = __webpack_require__(/*! ./core */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js\");\nconst validation_1 = __webpack_require__(/*! ./validation */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js\");\nconst applicator_1 = __webpack_require__(/*! ./applicator */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js\");\nconst format_1 = __webpack_require__(/*! ./format */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports[\"default\"] = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=format.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst format_1 = __webpack_require__(/*! ./format */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js\");\nconst format = [format_1.default];\nexports[\"default\"] = format;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=const.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        const eql = (0, util_1.useFunc)(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${eql}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=enum.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst limitNumber_1 = __webpack_require__(/*! ./limitNumber */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\");\nconst multipleOf_1 = __webpack_require__(/*! ./multipleOf */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\");\nconst limitLength_1 = __webpack_require__(/*! ./limitLength */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js\");\nconst pattern_1 = __webpack_require__(/*! ./pattern */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js\");\nconst limitProperties_1 = __webpack_require__(/*! ./limitProperties */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\");\nconst required_1 = __webpack_require__(/*! ./required */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js\");\nconst limitItems_1 = __webpack_require__(/*! ./limitItems */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js\");\nconst uniqueItems_1 = __webpack_require__(/*! ./uniqueItems */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\");\nconst const_1 = __webpack_require__(/*! ./const */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js\");\nconst enum_1 = __webpack_require__(/*! ./enum */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports[\"default\"] = validation;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitItems.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst ucs2length_1 = __webpack_require__(/*! ../../runtime/ucs2length */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitLength.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitNumber.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitProperties.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=multipleOf.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=pattern.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=required.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dataType_1 = __webpack_require__(/*! ../../compile/validate/dataType */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../../node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=uniqueItems.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/json-schema-traverse/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/json-schema-traverse/index.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/json-schema-traverse/index.js?");

/***/ }),

/***/ "../../../node_modules/mime/mime.js":
/*!******************************************!*\
  !*** ../../../node_modules/mime/mime.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\nfunction Mime() {\n  // Map of extension -> mime type\n  this.types = Object.create(null);\n\n  // Map of mime type -> extension\n  this.extensions = Object.create(null);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * @param map (Object) type definitions\n */\nMime.prototype.define = function (map) {\n  for (var type in map) {\n    var exts = map[type];\n    for (var i = 0; i < exts.length; i++) {\n      if (process.env.DEBUG_MIME && this.types[exts[i]]) {\n        console.warn((this._loading || \"define()\").replace(/.*\\//, ''), 'changes \"' + exts[i] + '\" extension type from ' +\n          this.types[exts[i]] + ' to ' + type);\n      }\n\n      this.types[exts[i]] = type;\n    }\n\n    // Default extension is the first one we encounter\n    if (!this.extensions[type]) {\n      this.extensions[type] = exts[0];\n    }\n  }\n};\n\n/**\n * Load an Apache2-style \".types\" file\n *\n * This may be called multiple times (it's expected).  Where files declare\n * overlapping types/extensions, the last file wins.\n *\n * @param file (String) path of file to load.\n */\nMime.prototype.load = function(file) {\n  this._loading = file;\n  // Read file and split into lines\n  var map = {},\n      content = fs.readFileSync(file, 'ascii'),\n      lines = content.split(/[\\r\\n]+/);\n\n  lines.forEach(function(line) {\n    // Clean up whitespace/comments, and split into fields\n    var fields = line.replace(/\\s*#.*|^\\s*|\\s*$/g, '').split(/\\s+/);\n    map[fields.shift()] = fields;\n  });\n\n  this.define(map);\n\n  this._loading = null;\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.lookup = function(path, fallback) {\n  var ext = path.replace(/^.*[\\.\\/\\\\]/, '').toLowerCase();\n\n  return this.types[ext] || fallback || this.default_type;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.extension = function(mimeType) {\n  var type = mimeType.match(/^\\s*([^;\\s]*)(?:;|\\s|$)/)[1].toLowerCase();\n  return this.extensions[type];\n};\n\n// Default instance\nvar mime = new Mime();\n\n// Define built-in types\nmime.define(__webpack_require__(/*! ./types.json */ \"../../../node_modules/mime/types.json\"));\n\n// Default type\nmime.default_type = mime.lookup('bin');\n\n//\n// Additional API specific to the default instance\n//\n\nmime.Mime = Mime;\n\n/**\n * Lookup a charset based on mime type.\n */\nmime.charsets = {\n  lookup: function(mimeType, fallback) {\n    // Assume text types are utf8\n    return (/^text\\/|^application\\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;\n  }\n};\n\nmodule.exports = mime;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/mime/mime.js?");

/***/ }),

/***/ "../../../node_modules/minimatch/minimatch.js":
/*!****************************************************!*\
  !*** ../../../node_modules/minimatch/minimatch.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nconst path = (() => { try { return __webpack_require__(/*! path */ \"path\") } catch (e) {}})() || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nconst GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nconst expand = __webpack_require__(/*! brace-expansion */ \"../../../node_modules/brace-expansion/index.js\")\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  const t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = options => {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nconst SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = false\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/': /* istanbul ignore next */ {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "../../../node_modules/ms/index.js":
/*!*****************************************!*\
  !*** ../../../node_modules/ms/index.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ms/index.js?");

/***/ }),

/***/ "../../../node_modules/on-finished/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/on-finished/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = __webpack_require__(/*! ee-first */ \"../../../node_modules/ee-first/index.js\")\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/on-finished/index.js?");

/***/ }),

/***/ "../../../node_modules/once/once.js":
/*!******************************************!*\
  !*** ../../../node_modules/once/once.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../../../node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/once/once.js?");

/***/ }),

/***/ "../../../node_modules/p-limit/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/p-limit/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Queue = __webpack_require__(/*! yocto-queue */ \"../../../node_modules/yocto-queue/index.js\");\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tqueue.enqueue(run.bind(null, fn, resolve, ...args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, ...args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/p-limit/index.js?");

/***/ }),

/***/ "../../../node_modules/path-is-absolute/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/path-is-absolute/index.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/path-is-absolute/index.js?");

/***/ }),

/***/ "../../../node_modules/pino-std-serializers/index.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/pino-std-serializers/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst errSerializer = __webpack_require__(/*! ./lib/err */ \"../../../node_modules/pino-std-serializers/lib/err.js\")\nconst reqSerializers = __webpack_require__(/*! ./lib/req */ \"../../../node_modules/pino-std-serializers/lib/req.js\")\nconst resSerializers = __webpack_require__(/*! ./lib/res */ \"../../../node_modules/pino-std-serializers/lib/res.js\")\n\nmodule.exports = {\n  err: errSerializer,\n  mapHttpRequest: reqSerializers.mapHttpRequest,\n  mapHttpResponse: resSerializers.mapHttpResponse,\n  req: reqSerializers.reqSerializer,\n  res: resSerializers.resSerializer,\n\n  wrapErrorSerializer: function wrapErrorSerializer (customSerializer) {\n    if (customSerializer === errSerializer) return customSerializer\n    return function wrapErrSerializer (err) {\n      return customSerializer(errSerializer(err))\n    }\n  },\n\n  wrapRequestSerializer: function wrapRequestSerializer (customSerializer) {\n    if (customSerializer === reqSerializers.reqSerializer) return customSerializer\n    return function wrappedReqSerializer (req) {\n      return customSerializer(reqSerializers.reqSerializer(req))\n    }\n  },\n\n  wrapResponseSerializer: function wrapResponseSerializer (customSerializer) {\n    if (customSerializer === resSerializers.resSerializer) return customSerializer\n    return function wrappedResSerializer (res) {\n      return customSerializer(resSerializers.resSerializer(res))\n    }\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino-std-serializers/index.js?");

/***/ }),

/***/ "../../../node_modules/pino-std-serializers/lib/err.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/pino-std-serializers/lib/err.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = errSerializer\n\nconst { toString } = Object.prototype\nconst seen = Symbol('circular-ref-tag')\nconst rawSymbol = Symbol('pino-raw-err-ref')\nconst pinoErrProto = Object.create({}, {\n  type: {\n    enumerable: true,\n    writable: true,\n    value: undefined\n  },\n  message: {\n    enumerable: true,\n    writable: true,\n    value: undefined\n  },\n  stack: {\n    enumerable: true,\n    writable: true,\n    value: undefined\n  },\n  raw: {\n    enumerable: false,\n    get: function () {\n      return this[rawSymbol]\n    },\n    set: function (val) {\n      this[rawSymbol] = val\n    }\n  }\n})\nObject.defineProperty(pinoErrProto, rawSymbol, {\n  writable: true,\n  value: {}\n})\n\nfunction errSerializer (err) {\n  if (!(err instanceof Error)) {\n    return err\n  }\n\n  err[seen] = undefined // tag to prevent re-looking at this\n  const _err = Object.create(pinoErrProto)\n  _err.type = toString.call(err.constructor) === '[object Function]'\n    ? err.constructor.name\n    : err.name\n  _err.message = err.message\n  _err.stack = err.stack\n  for (const key in err) {\n    if (_err[key] === undefined) {\n      const val = err[key]\n      if (val instanceof Error) {\n        /* eslint-disable no-prototype-builtins */\n        if (!val.hasOwnProperty(seen)) {\n          _err[key] = errSerializer(val)\n        }\n      } else {\n        _err[key] = val\n      }\n    }\n  }\n\n  delete err[seen] // clean up tag in case err is serialized again later\n  _err.raw = err\n  return _err\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino-std-serializers/lib/err.js?");

/***/ }),

/***/ "../../../node_modules/pino-std-serializers/lib/req.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/pino-std-serializers/lib/req.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  mapHttpRequest,\n  reqSerializer\n}\n\nconst rawSymbol = Symbol('pino-raw-req-ref')\nconst pinoReqProto = Object.create({}, {\n  id: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  method: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  url: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  query: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  params: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  headers: {\n    enumerable: true,\n    writable: true,\n    value: {}\n  },\n  remoteAddress: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  remotePort: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  raw: {\n    enumerable: false,\n    get: function () {\n      return this[rawSymbol]\n    },\n    set: function (val) {\n      this[rawSymbol] = val\n    }\n  }\n})\nObject.defineProperty(pinoReqProto, rawSymbol, {\n  writable: true,\n  value: {}\n})\n\nfunction reqSerializer (req) {\n  // req.info is for hapi compat.\n  const connection = req.info || req.socket\n  const _req = Object.create(pinoReqProto)\n  _req.id = (typeof req.id === 'function' ? req.id() : (req.id || (req.info ? req.info.id : undefined)))\n  _req.method = req.method\n  // req.originalUrl is for expressjs compat.\n  if (req.originalUrl) {\n    _req.url = req.originalUrl\n    _req.query = req.query\n    _req.params = req.params\n  } else {\n    // req.url.path is  for hapi compat.\n    _req.url = req.path || (req.url ? (req.url.path || req.url) : undefined)\n  }\n  _req.headers = req.headers\n  _req.remoteAddress = connection && connection.remoteAddress\n  _req.remotePort = connection && connection.remotePort\n  // req.raw is  for hapi compat/equivalence\n  _req.raw = req.raw || req\n  return _req\n}\n\nfunction mapHttpRequest (req) {\n  return {\n    req: reqSerializer(req)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino-std-serializers/lib/req.js?");

/***/ }),

/***/ "../../../node_modules/pino-std-serializers/lib/res.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/pino-std-serializers/lib/res.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  mapHttpResponse,\n  resSerializer\n}\n\nconst rawSymbol = Symbol('pino-raw-res-ref')\nconst pinoResProto = Object.create({}, {\n  statusCode: {\n    enumerable: true,\n    writable: true,\n    value: 0\n  },\n  headers: {\n    enumerable: true,\n    writable: true,\n    value: ''\n  },\n  raw: {\n    enumerable: false,\n    get: function () {\n      return this[rawSymbol]\n    },\n    set: function (val) {\n      this[rawSymbol] = val\n    }\n  }\n})\nObject.defineProperty(pinoResProto, rawSymbol, {\n  writable: true,\n  value: {}\n})\n\nfunction resSerializer (res) {\n  const _res = Object.create(pinoResProto)\n  _res.statusCode = res.statusCode\n  _res.headers = res.getHeaders ? res.getHeaders() : res._headers\n  _res.raw = res\n  return _res\n}\n\nfunction mapHttpResponse (res) {\n  return {\n    res: resSerializer(res)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino-std-serializers/lib/res.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/deprecations.js":
/*!******************************************************!*\
  !*** ../../../node_modules/pino/lib/deprecations.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst warning = __webpack_require__(/*! process-warning */ \"../../../node_modules/process-warning/index.js\")()\nmodule.exports = warning\n\nconst warnName = 'PinoWarning'\n\nwarning.create(warnName, 'PINODEP004', 'bindings.serializers is deprecated, use options.serializers option instead')\n\nwarning.create(warnName, 'PINODEP005', 'bindings.formatters is deprecated, use options.formatters option instead')\n\nwarning.create(warnName, 'PINODEP006', 'bindings.customLevels is deprecated, use options.customLevels option instead')\n\nwarning.create(warnName, 'PINODEP007', 'bindings.level is deprecated, use options.level option instead')\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/deprecations.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/levels.js":
/*!************************************************!*\
  !*** ../../../node_modules/pino/lib/levels.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint no-prototype-builtins: 0 */\nconst flatstr = __webpack_require__(/*! flatstr */ \"../../../node_modules/flatstr/index.js\")\nconst {\n  lsCacheSym,\n  levelValSym,\n  useOnlyCustomLevelsSym,\n  streamSym,\n  formattersSym,\n  hooksSym\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/pino/lib/symbols.js\")\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"../../../node_modules/pino/lib/tools.js\")\n\nconst levels = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  fatal: 60\n}\nconst levelMethods = {\n  fatal: (hook) => {\n    const logFatal = genLog(levels.fatal, hook)\n    return function (...args) {\n      const stream = this[streamSym]\n      logFatal.call(this, ...args)\n      if (typeof stream.flushSync === 'function') {\n        try {\n          stream.flushSync()\n        } catch (e) {\n          // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n        }\n      }\n    }\n  },\n  error: (hook) => genLog(levels.error, hook),\n  warn: (hook) => genLog(levels.warn, hook),\n  info: (hook) => genLog(levels.info, hook),\n  debug: (hook) => genLog(levels.debug, hook),\n  trace: (hook) => genLog(levels.trace, hook)\n}\n\nconst nums = Object.keys(levels).reduce((o, k) => {\n  o[levels[k]] = k\n  return o\n}, {})\n\nconst initialLsCache = Object.keys(nums).reduce((o, k) => {\n  o[k] = flatstr('{\"level\":' + Number(k))\n  return o\n}, {})\n\nfunction genLsCache (instance) {\n  const formatter = instance[formattersSym].level\n  const { labels } = instance.levels\n  const cache = {}\n  for (const label in labels) {\n    const level = formatter(labels[label], Number(label))\n    cache[label] = JSON.stringify(level).slice(0, -1)\n  }\n  instance[lsCacheSym] = cache\n  return instance\n}\n\nfunction isStandardLevel (level, useOnlyCustomLevels) {\n  if (useOnlyCustomLevels) {\n    return false\n  }\n\n  switch (level) {\n    case 'fatal':\n    case 'error':\n    case 'warn':\n    case 'info':\n    case 'debug':\n    case 'trace':\n      return true\n    default:\n      return false\n  }\n}\n\nfunction setLevel (level) {\n  const { labels, values } = this.levels\n  if (typeof level === 'number') {\n    if (labels[level] === undefined) throw Error('unknown level value' + level)\n    level = labels[level]\n  }\n  if (values[level] === undefined) throw Error('unknown level ' + level)\n  const preLevelVal = this[levelValSym]\n  const levelVal = this[levelValSym] = values[level]\n  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym]\n  const hook = this[hooksSym].logMethod\n\n  for (const key in values) {\n    if (levelVal > values[key]) {\n      this[key] = noop\n      continue\n    }\n    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook)\n  }\n\n  this.emit(\n    'level-change',\n    level,\n    levelVal,\n    labels[preLevelVal],\n    preLevelVal\n  )\n}\n\nfunction getLevel (level) {\n  const { levels, levelVal } = this\n  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n  return (levels && levels.labels) ? levels.labels[levelVal] : ''\n}\n\nfunction isLevelEnabled (logLevel) {\n  const { values } = this.levels\n  const logLevelVal = values[logLevel]\n  return logLevelVal !== undefined && (logLevelVal >= this[levelValSym])\n}\n\nfunction mappings (customLevels = null, useOnlyCustomLevels = false) {\n  const customNums = customLevels\n    /* eslint-disable */\n    ? Object.keys(customLevels).reduce((o, k) => {\n        o[customLevels[k]] = k\n        return o\n      }, {})\n    : null\n    /* eslint-enable */\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),\n    useOnlyCustomLevels ? null : nums,\n    customNums\n  )\n  const values = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : levels,\n    customLevels\n  )\n  return { labels, values }\n}\n\nfunction assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {\n  if (typeof defaultLevel === 'number') {\n    const values = [].concat(\n      Object.keys(customLevels || {}).map(key => customLevels[key]),\n      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),\n      Infinity\n    )\n    if (!values.includes(defaultLevel)) {\n      throw Error(`default level:${defaultLevel} must be included in custom levels`)\n    }\n    return\n  }\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : levels,\n    customLevels\n  )\n  if (!(defaultLevel in labels)) {\n    throw Error(`default level:${defaultLevel} must be included in custom levels`)\n  }\n}\n\nfunction assertNoLevelCollisions (levels, customLevels) {\n  const { labels, values } = levels\n  for (const k in customLevels) {\n    if (k in values) {\n      throw Error('levels cannot be overridden')\n    }\n    if (customLevels[k] in labels) {\n      throw Error('pre-existing level values cannot be used for new levels')\n    }\n  }\n}\n\nmodule.exports = {\n  initialLsCache,\n  genLsCache,\n  levelMethods,\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  assertNoLevelCollisions,\n  assertDefaultLevelFound\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/levels.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/meta.js":
/*!**********************************************!*\
  !*** ../../../node_modules/pino/lib/meta.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { version } = __webpack_require__(/*! ../package.json */ \"../../../node_modules/pino/package.json\")\n\nmodule.exports = { version }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/meta.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/proto.js":
/*!***********************************************!*\
  !*** ../../../node_modules/pino/lib/proto.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\")\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"../../../node_modules/sonic-boom/index.js\")\nconst flatstr = __webpack_require__(/*! flatstr */ \"../../../node_modules/flatstr/index.js\")\nconst warning = __webpack_require__(/*! ./deprecations */ \"../../../node_modules/pino/lib/deprecations.js\")\nconst {\n  lsCacheSym,\n  levelValSym,\n  setLevelSym,\n  getLevelSym,\n  chindingsSym,\n  parsedChindingsSym,\n  mixinSym,\n  asJsonSym,\n  writeSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  serializersSym,\n  formattersSym,\n  useOnlyCustomLevelsSym,\n  needsMetadataGsym,\n  redactFmtSym,\n  stringifySym,\n  formatOptsSym,\n  stringifiersSym\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/pino/lib/symbols.js\")\nconst {\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  initialLsCache,\n  genLsCache,\n  assertNoLevelCollisions\n} = __webpack_require__(/*! ./levels */ \"../../../node_modules/pino/lib/levels.js\")\nconst {\n  asChindings,\n  asJson,\n  buildFormatters,\n  stringify\n} = __webpack_require__(/*! ./tools */ \"../../../node_modules/pino/lib/tools.js\")\nconst {\n  version\n} = __webpack_require__(/*! ./meta */ \"../../../node_modules/pino/lib/meta.js\")\nconst redaction = __webpack_require__(/*! ./redaction */ \"../../../node_modules/pino/lib/redaction.js\")\n\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {}\nconst prototype = {\n  constructor,\n  child,\n  bindings,\n  setBindings,\n  flush,\n  isLevelEnabled,\n  version,\n  get level () { return this[getLevelSym]() },\n  set level (lvl) { this[setLevelSym](lvl) },\n  get levelVal () { return this[levelValSym] },\n  set levelVal (n) { throw Error('levelVal is read-only') },\n  [lsCacheSym]: initialLsCache,\n  [writeSym]: write,\n  [asJsonSym]: asJson,\n  [getLevelSym]: getLevel,\n  [setLevelSym]: setLevel\n}\n\nObject.setPrototypeOf(prototype, EventEmitter.prototype)\n\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function () {\n  return Object.create(prototype)\n}\n\nconst resetChildingsFormatter = bindings => bindings\nfunction child (bindings, options) {\n  if (!bindings) {\n    throw Error('missing bindings for child Pino')\n  }\n  options = options || {} // default options to empty object\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const instance = Object.create(this)\n\n  if (bindings.hasOwnProperty('serializers') === true) {\n    warning.emit('PINODEP004')\n    options.serializers = bindings.serializers\n  }\n  if (bindings.hasOwnProperty('formatters') === true) {\n    warning.emit('PINODEP005')\n    options.formatters = bindings.formatters\n  }\n  if (bindings.hasOwnProperty('customLevels') === true) {\n    warning.emit('PINODEP006')\n    options.customLevels = bindings.customLevels\n  }\n  if (bindings.hasOwnProperty('level') === true) {\n    warning.emit('PINODEP007')\n    options.level = bindings.level\n  }\n  if (options.hasOwnProperty('serializers') === true) {\n    instance[serializersSym] = Object.create(null)\n\n    for (const k in serializers) {\n      instance[serializersSym][k] = serializers[k]\n    }\n    const parentSymbols = Object.getOwnPropertySymbols(serializers)\n    /* eslint no-var: off */\n    for (var i = 0; i < parentSymbols.length; i++) {\n      const ks = parentSymbols[i]\n      instance[serializersSym][ks] = serializers[ks]\n    }\n\n    for (const bk in options.serializers) {\n      instance[serializersSym][bk] = options.serializers[bk]\n    }\n    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers)\n    for (var bi = 0; bi < bindingsSymbols.length; bi++) {\n      const bks = bindingsSymbols[bi]\n      instance[serializersSym][bks] = options.serializers[bks]\n    }\n  } else instance[serializersSym] = serializers\n  if (options.hasOwnProperty('formatters')) {\n    const { level, bindings: chindings, log } = options.formatters\n    instance[formattersSym] = buildFormatters(\n      level || formatters.level,\n      chindings || resetChildingsFormatter,\n      log || formatters.log\n    )\n  } else {\n    instance[formattersSym] = buildFormatters(\n      formatters.level,\n      resetChildingsFormatter,\n      formatters.log\n    )\n  }\n  if (options.hasOwnProperty('customLevels') === true) {\n    assertNoLevelCollisions(this.levels, options.customLevels)\n    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym])\n    genLsCache(instance)\n  }\n\n  // redact must place before asChindings and only replace if exist\n  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {\n    instance.redact = options.redact // replace redact directly\n    const stringifiers = redaction(instance.redact, stringify)\n    const formatOpts = { stringify: stringifiers[redactFmtSym] }\n    instance[stringifySym] = stringify\n    instance[stringifiersSym] = stringifiers\n    instance[formatOptsSym] = formatOpts\n  }\n\n  instance[chindingsSym] = asChindings(instance, bindings)\n  const childLevel = options.level || this.level\n  instance[setLevelSym](childLevel)\n\n  return instance\n}\n\nfunction bindings () {\n  const chindings = this[chindingsSym]\n  const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n  const bindingsFromJson = JSON.parse(chindingsJson)\n  delete bindingsFromJson.pid\n  delete bindingsFromJson.hostname\n  return bindingsFromJson\n}\n\nfunction setBindings (newBindings) {\n  const chindings = asChindings(this, newBindings)\n  this[chindingsSym] = chindings\n  delete this[parsedChindingsSym]\n}\n\nfunction write (_obj, msg, num) {\n  const t = this[timeSym]()\n  const mixin = this[mixinSym]\n  const objError = _obj instanceof Error\n  let obj\n\n  if (_obj === undefined || _obj === null) {\n    obj = mixin ? mixin({}) : {}\n  } else {\n    obj = Object.assign(mixin ? mixin(_obj) : {}, _obj)\n    if (!msg && objError) {\n      msg = _obj.message\n    }\n\n    if (objError) {\n      obj.stack = _obj.stack\n      if (!obj.type) {\n        obj.type = 'Error'\n      }\n    }\n  }\n\n  const s = this[asJsonSym](obj, msg, num, t)\n\n  const stream = this[streamSym]\n  if (stream[needsMetadataGsym] === true) {\n    stream.lastLevel = num\n    stream.lastObj = obj\n    stream.lastMsg = msg\n    stream.lastTime = t.slice(this[timeSliceIndexSym])\n    stream.lastLogger = this // for child loggers\n  }\n  if (stream instanceof SonicBoom) stream.write(s)\n  else stream.write(flatstr(s))\n}\n\nfunction flush () {\n  const stream = this[streamSym]\n  if ('flush' in stream) stream.flush()\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/proto.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/redaction.js":
/*!***************************************************!*\
  !*** ../../../node_modules/pino/lib/redaction.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastRedact = __webpack_require__(/*! fast-redact */ \"../../../node_modules/fast-redact/index.js\")\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/pino/lib/symbols.js\")\nconst { rx, validator } = fastRedact\n\nconst validate = validator({\n  ERR_PATHS_MUST_BE_STRINGS: () => 'pino – redacted paths must be strings',\n  ERR_INVALID_PATH: (s) => `pino – redact paths array contains an invalid path (${s})`\n})\n\nconst CENSOR = '[Redacted]'\nconst strict = false // TODO should this be configurable?\n\nfunction redaction (opts, serialize) {\n  const { paths, censor } = handle(opts)\n\n  const shape = paths.reduce((o, str) => {\n    rx.lastIndex = 0\n    const first = rx.exec(str)\n    const next = rx.exec(str)\n\n    // ns is the top-level path segment, brackets + quoting removed.\n    let ns = first[1] !== undefined\n      ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, '$1')\n      : first[0]\n\n    if (ns === '*') {\n      ns = wildcardFirstSym\n    }\n\n    // top level key:\n    if (next === null) {\n      o[ns] = null\n      return o\n    }\n\n    // path with at least two segments:\n    // if ns is already redacted at the top level, ignore lower level redactions\n    if (o[ns] === null) {\n      return o\n    }\n\n    const { index } = next\n    const nextPath = `${str.substr(index, str.length - 1)}`\n\n    o[ns] = o[ns] || []\n\n    // shape is a mix of paths beginning with literal values and wildcard\n    // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n    // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n    // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n    // (* entry has wildcardFirstSym as key)\n    if (ns !== wildcardFirstSym && o[ns].length === 0) {\n      // first time ns's get all '*' redactions so far\n      o[ns].push(...(o[wildcardFirstSym] || []))\n    }\n\n    if (ns === wildcardFirstSym) {\n      // new * path gets added to all previously registered literal ns's.\n      Object.keys(o).forEach(function (k) {\n        if (o[k]) {\n          o[k].push(nextPath)\n        }\n      })\n    }\n\n    o[ns].push(nextPath)\n    return o\n  }, {})\n\n  // the redactor assigned to the format symbol key\n  // provides top level redaction for instances where\n  // an object is interpolated into the msg string\n  const result = {\n    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })\n  }\n\n  const topCensor = (...args) => {\n    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)\n  }\n\n  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {\n    // top level key:\n    if (shape[k] === null) {\n      o[k] = (value) => topCensor(value, [k])\n    } else {\n      const wrappedCensor = typeof censor === 'function'\n        ? (value, path) => {\n            return censor(value, [k, ...path])\n          }\n        : censor\n      o[k] = fastRedact({\n        paths: shape[k],\n        censor: wrappedCensor,\n        serialize,\n        strict\n      })\n    }\n    return o\n  }, result)\n}\n\nfunction handle (opts) {\n  if (Array.isArray(opts)) {\n    opts = { paths: opts, censor: CENSOR }\n    validate(opts)\n    return opts\n  }\n  let { paths, censor = CENSOR, remove } = opts\n  if (Array.isArray(paths) === false) { throw Error('pino – redact must contain an array of strings') }\n  if (remove === true) censor = undefined\n  validate({ paths, censor })\n\n  return { paths, censor }\n}\n\nmodule.exports = redaction\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/redaction.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/symbols.js":
/*!*************************************************!*\
  !*** ../../../node_modules/pino/lib/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst setLevelSym = Symbol('pino.setLevel')\nconst getLevelSym = Symbol('pino.getLevel')\nconst levelValSym = Symbol('pino.levelVal')\nconst useLevelLabelsSym = Symbol('pino.useLevelLabels')\nconst useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels')\nconst mixinSym = Symbol('pino.mixin')\n\nconst lsCacheSym = Symbol('pino.lsCache')\nconst chindingsSym = Symbol('pino.chindings')\nconst parsedChindingsSym = Symbol('pino.parsedChindings')\n\nconst asJsonSym = Symbol('pino.asJson')\nconst writeSym = Symbol('pino.write')\nconst redactFmtSym = Symbol('pino.redactFmt')\n\nconst timeSym = Symbol('pino.time')\nconst timeSliceIndexSym = Symbol('pino.timeSliceIndex')\nconst streamSym = Symbol('pino.stream')\nconst stringifySym = Symbol('pino.stringify')\nconst stringifiersSym = Symbol('pino.stringifiers')\nconst endSym = Symbol('pino.end')\nconst formatOptsSym = Symbol('pino.formatOpts')\nconst messageKeySym = Symbol('pino.messageKey')\nconst nestedKeySym = Symbol('pino.nestedKey')\n\nconst wildcardFirstSym = Symbol('pino.wildcardFirst')\n\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for('pino.serializers')\nconst formattersSym = Symbol.for('pino.formatters')\nconst hooksSym = Symbol.for('pino.hooks')\nconst needsMetadataGsym = Symbol.for('pino.metadata')\n\nmodule.exports = {\n  setLevelSym,\n  getLevelSym,\n  levelValSym,\n  useLevelLabelsSym,\n  mixinSym,\n  lsCacheSym,\n  chindingsSym,\n  parsedChindingsSym,\n  asJsonSym,\n  writeSym,\n  serializersSym,\n  redactFmtSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifiersSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  nestedKeySym,\n  wildcardFirstSym,\n  needsMetadataGsym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/symbols.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/time.js":
/*!**********************************************!*\
  !*** ../../../node_modules/pino/lib/time.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst nullTime = () => ''\n\nconst epochTime = () => `,\"time\":${Date.now()}`\n\nconst unixTime = () => `,\"time\":${Math.round(Date.now() / 1000.0)}`\n\nconst isoTime = () => `,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n\nmodule.exports = { nullTime, epochTime, unixTime, isoTime }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/time.js?");

/***/ }),

/***/ "../../../node_modules/pino/lib/tools.js":
/*!***********************************************!*\
  !*** ../../../node_modules/pino/lib/tools.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst format = __webpack_require__(/*! quick-format-unescaped */ \"../../../node_modules/quick-format-unescaped/index.js\")\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"../../../node_modules/pino-std-serializers/index.js\")\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"../../../node_modules/sonic-boom/index.js\")\nconst stringifySafe = __webpack_require__(/*! fast-safe-stringify */ \"../../../node_modules/fast-safe-stringify/index.js\")\nconst {\n  lsCacheSym,\n  chindingsSym,\n  parsedChindingsSym,\n  writeSym,\n  serializersSym,\n  formatOptsSym,\n  endSym,\n  stringifiersSym,\n  stringifySym,\n  wildcardFirstSym,\n  needsMetadataGsym,\n  redactFmtSym,\n  streamSym,\n  nestedKeySym,\n  formattersSym,\n  messageKeySym\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/pino/lib/symbols.js\")\n\nfunction noop () {}\n\nfunction genLog (level, hook) {\n  if (!hook) return LOG\n\n  return function hookWrappedLog (...args) {\n    hook.call(this, args, LOG, level)\n  }\n\n  function LOG (o, ...n) {\n    if (typeof o === 'object') {\n      let msg = o\n      if (o !== null) {\n        if (o.method && o.headers && o.socket) {\n          o = mapHttpRequest(o)\n        } else if (typeof o.setHeader === 'function') {\n          o = mapHttpResponse(o)\n        }\n      }\n      if (this[nestedKeySym]) o = { [this[nestedKeySym]]: o }\n      let formatParams\n      if (msg === null && n.length === 0) {\n        formatParams = [null]\n      } else {\n        msg = n.shift()\n        formatParams = n\n      }\n      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level)\n    } else {\n      this[writeSym](null, format(o, n, this[formatOptsSym]), level)\n    }\n  }\n}\n\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString (str) {\n  let result = ''\n  let last = 0\n  let found = false\n  let point = 255\n  const l = str.length\n  if (l > 100) {\n    return JSON.stringify(str)\n  }\n  for (var i = 0; i < l && point >= 32; i++) {\n    point = str.charCodeAt(i)\n    if (point === 34 || point === 92) {\n      result += str.slice(last, i) + '\\\\'\n      last = i\n      found = true\n    }\n  }\n  if (!found) {\n    result = str\n  } else {\n    result += str.slice(last)\n  }\n  return point < 32 ? JSON.stringify(str) : '\"' + result + '\"'\n}\n\nfunction asJson (obj, msg, num, time) {\n  const stringify = this[stringifySym]\n  const stringifiers = this[stringifiersSym]\n  const end = this[endSym]\n  const chindings = this[chindingsSym]\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const messageKey = this[messageKeySym]\n  let data = this[lsCacheSym][num] + time\n\n  // we need the child bindings added to the output first so instance logged\n  // objects can take precedence when JSON.parse-ing the resulting log line\n  data = data + chindings\n\n  let value\n  const notHasOwnProperty = obj.hasOwnProperty === undefined\n  if (formatters.log) {\n    obj = formatters.log(obj)\n  }\n  if (msg !== undefined) {\n    obj[messageKey] = msg\n  }\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  for (const key in obj) {\n    value = obj[key]\n    if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== undefined) {\n      value = serializers[key] ? serializers[key](value) : value\n\n      const stringifier = stringifiers[key] || wildcardStringifier\n\n      switch (typeof value) {\n        case 'undefined':\n        case 'function':\n          continue\n        case 'number':\n          /* eslint no-fallthrough: \"off\" */\n          if (Number.isFinite(value) === false) {\n            value = null\n          }\n        // this case explicitly falls through to the next one\n        case 'boolean':\n          if (stringifier) value = stringifier(value)\n          break\n        case 'string':\n          value = (stringifier || asString)(value)\n          break\n        default:\n          value = (stringifier || stringify)(value)\n      }\n      if (value === undefined) continue\n      data += ',\"' + key + '\":' + value\n    }\n  }\n\n  return data + end\n}\n\nfunction asChindings (instance, bindings) {\n  let value\n  let data = instance[chindingsSym]\n  const stringify = instance[stringifySym]\n  const stringifiers = instance[stringifiersSym]\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  const serializers = instance[serializersSym]\n  const formatter = instance[formattersSym].bindings\n  bindings = formatter(bindings)\n\n  for (const key in bindings) {\n    value = bindings[key]\n    const valid = key !== 'level' &&\n      key !== 'serializers' &&\n      key !== 'formatters' &&\n      key !== 'customLevels' &&\n      bindings.hasOwnProperty(key) &&\n      value !== undefined\n    if (valid === true) {\n      value = serializers[key] ? serializers[key](value) : value\n      value = (stringifiers[key] || wildcardStringifier || stringify)(value)\n      if (value === undefined) continue\n      data += ',\"' + key + '\":' + value\n    }\n  }\n  return data\n}\n\nfunction getPrettyStream (opts, prettifier, dest, instance) {\n  if (prettifier && typeof prettifier === 'function') {\n    prettifier = prettifier.bind(instance)\n    return prettifierMetaWrapper(prettifier(opts), dest, opts)\n  }\n  try {\n    const prettyFactory = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'pino-pretty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) || __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'pino-pretty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n    prettyFactory.asMetaWrapper = prettifierMetaWrapper\n    return prettifierMetaWrapper(prettyFactory(opts), dest, opts)\n  } catch (e) {\n    if (e.message.startsWith(\"Cannot find module 'pino-pretty'\")) {\n      throw Error('Missing `pino-pretty` module: `pino-pretty` must be installed separately')\n    };\n    throw e\n  }\n}\n\nfunction prettifierMetaWrapper (pretty, dest, opts) {\n  opts = Object.assign({ suppressFlushSyncWarning: false }, opts)\n  let warned = false\n  return {\n    [needsMetadataGsym]: true,\n    lastLevel: 0,\n    lastMsg: null,\n    lastObj: null,\n    lastLogger: null,\n    flushSync () {\n      if (opts.suppressFlushSyncWarning || warned) {\n        return\n      }\n      warned = true\n      setMetadataProps(dest, this)\n      dest.write(pretty(Object.assign({\n        level: 40, // warn\n        msg: 'pino.final with prettyPrint does not support flushing',\n        time: Date.now()\n      }, this.chindings())))\n    },\n    chindings () {\n      const lastLogger = this.lastLogger\n      let chindings = null\n\n      // protection against flushSync being called before logging\n      // anything\n      if (!lastLogger) {\n        return null\n      }\n\n      if (lastLogger.hasOwnProperty(parsedChindingsSym)) {\n        chindings = lastLogger[parsedChindingsSym]\n      } else {\n        chindings = JSON.parse('{' + lastLogger[chindingsSym].substr(1) + '}')\n        lastLogger[parsedChindingsSym] = chindings\n      }\n\n      return chindings\n    },\n    write (chunk) {\n      const lastLogger = this.lastLogger\n      const chindings = this.chindings()\n\n      let time = this.lastTime\n\n      if (time.match(/^\\d+/)) {\n        time = parseInt(time)\n      } else {\n        time = time.slice(1, -1)\n      }\n\n      const lastObj = this.lastObj\n      const lastMsg = this.lastMsg\n      const errorProps = null\n\n      const formatters = lastLogger[formattersSym]\n      const formattedObj = formatters.log ? formatters.log(lastObj) : lastObj\n\n      const messageKey = lastLogger[messageKeySym]\n      if (lastMsg && formattedObj && !formattedObj.hasOwnProperty(messageKey)) {\n        formattedObj[messageKey] = lastMsg\n      }\n\n      const obj = Object.assign({\n        level: this.lastLevel,\n        time\n      }, formattedObj, errorProps)\n\n      const serializers = lastLogger[serializersSym]\n      const keys = Object.keys(serializers)\n\n      for (var i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        if (obj[key] !== undefined) {\n          obj[key] = serializers[key](obj[key])\n        }\n      }\n\n      for (const key in chindings) {\n        if (!obj.hasOwnProperty(key)) {\n          obj[key] = chindings[key]\n        }\n      }\n\n      const stringifiers = lastLogger[stringifiersSym]\n      const redact = stringifiers[redactFmtSym]\n\n      const formatted = pretty(typeof redact === 'function' ? redact(obj) : obj)\n      if (formatted === undefined) return\n\n      setMetadataProps(dest, this)\n      dest.write(formatted)\n    }\n  }\n}\n\nfunction hasBeenTampered (stream) {\n  return stream.write !== stream.constructor.prototype.write\n}\n\nfunction buildSafeSonicBoom (opts) {\n  const stream = new SonicBoom(opts)\n  stream.on('error', filterBrokenPipe)\n  return stream\n\n  function filterBrokenPipe (err) {\n    // TODO verify on Windows\n    if (err.code === 'EPIPE') {\n      // If we get EPIPE, we should stop logging here\n      // however we have no control to the consumer of\n      // SonicBoom, so we just overwrite the write method\n      stream.write = noop\n      stream.end = noop\n      stream.flushSync = noop\n      stream.destroy = noop\n      return\n    }\n    stream.removeListener('error', filterBrokenPipe)\n    stream.emit('error', err)\n  }\n}\n\nfunction createArgsNormalizer (defaultOptions) {\n  return function normalizeArgs (instance, opts = {}, stream) {\n    // support stream as a string\n    if (typeof opts === 'string') {\n      stream = buildSafeSonicBoom({ dest: opts, sync: true })\n      opts = {}\n    } else if (typeof stream === 'string') {\n      stream = buildSafeSonicBoom({ dest: stream, sync: true })\n    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n      stream = opts\n      opts = null\n    }\n    opts = Object.assign({}, defaultOptions, opts)\n    if ('extreme' in opts) {\n      throw Error('The extreme option has been removed, use pino.destination({ sync: false }) instead')\n    }\n    if ('onTerminated' in opts) {\n      throw Error('The onTerminated option has been removed, use pino.final instead')\n    }\n    if ('changeLevelName' in opts) {\n      process.emitWarning(\n        'The changeLevelName option is deprecated and will be removed in v7. Use levelKey instead.',\n        { code: 'changeLevelName_deprecation' }\n      )\n      opts.levelKey = opts.changeLevelName\n      delete opts.changeLevelName\n    }\n    const { enabled, prettyPrint, prettifier, messageKey } = opts\n    if (enabled === false) opts.level = 'silent'\n    stream = stream || process.stdout\n    if (stream === process.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {\n      stream = buildSafeSonicBoom({ fd: stream.fd, sync: true })\n    }\n    if (prettyPrint) {\n      const prettyOpts = Object.assign({ messageKey }, prettyPrint)\n      stream = getPrettyStream(prettyOpts, prettifier, stream, instance)\n    }\n    return { opts, stream }\n  }\n}\n\nfunction final (logger, handler) {\n  if (typeof logger === 'undefined' || typeof logger.child !== 'function') {\n    throw Error('expected a pino logger instance')\n  }\n  const hasHandler = (typeof handler !== 'undefined')\n  if (hasHandler && typeof handler !== 'function') {\n    throw Error('if supplied, the handler parameter should be a function')\n  }\n  const stream = logger[streamSym]\n  if (typeof stream.flushSync !== 'function') {\n    throw Error('final requires a stream that has a flushSync method, such as pino.destination')\n  }\n\n  const finalLogger = new Proxy(logger, {\n    get: (logger, key) => {\n      if (key in logger.levels.values) {\n        return (...args) => {\n          logger[key](...args)\n          stream.flushSync()\n        }\n      }\n      return logger[key]\n    }\n  })\n\n  if (!hasHandler) {\n    return finalLogger\n  }\n\n  return (err = null, ...args) => {\n    try {\n      stream.flushSync()\n    } catch (e) {\n      // it's too late to wait for the stream to be ready\n      // because this is a final tick scenario.\n      // in practice there shouldn't be a situation where it isn't\n      // however, swallow the error just in case (and for easier testing)\n    }\n    return handler(err, finalLogger, ...args)\n  }\n}\n\nfunction stringify (obj) {\n  try {\n    return JSON.stringify(obj)\n  } catch (_) {\n    return stringifySafe(obj)\n  }\n}\n\nfunction buildFormatters (level, bindings, log) {\n  return {\n    level,\n    bindings,\n    log\n  }\n}\n\nfunction setMetadataProps (dest, that) {\n  if (dest[needsMetadataGsym] === true) {\n    dest.lastLevel = that.lastLevel\n    dest.lastMsg = that.lastMsg\n    dest.lastObj = that.lastObj\n    dest.lastTime = that.lastTime\n    dest.lastLogger = that.lastLogger\n  }\n}\n\nmodule.exports = {\n  noop,\n  buildSafeSonicBoom,\n  getPrettyStream,\n  asChindings,\n  asJson,\n  genLog,\n  createArgsNormalizer,\n  final,\n  stringify,\n  buildFormatters\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/lib/tools.js?");

/***/ }),

/***/ "../../../node_modules/pino/pino.js":
/*!******************************************!*\
  !*** ../../../node_modules/pino/pino.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint no-prototype-builtins: 0 */\nconst os = __webpack_require__(/*! os */ \"os\")\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"../../../node_modules/pino-std-serializers/index.js\")\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"../../../node_modules/pino/lib/redaction.js\")\nconst time = __webpack_require__(/*! ./lib/time */ \"../../../node_modules/pino/lib/time.js\")\nconst proto = __webpack_require__(/*! ./lib/proto */ \"../../../node_modules/pino/lib/proto.js\")\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"../../../node_modules/pino/lib/symbols.js\")\nconst { assertDefaultLevelFound, mappings, genLsCache } = __webpack_require__(/*! ./lib/levels */ \"../../../node_modules/pino/lib/levels.js\")\nconst {\n  createArgsNormalizer,\n  asChindings,\n  final,\n  stringify,\n  buildSafeSonicBoom,\n  buildFormatters,\n  noop\n} = __webpack_require__(/*! ./lib/tools */ \"../../../node_modules/pino/lib/tools.js\")\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"../../../node_modules/pino/lib/meta.js\")\nconst {\n  chindingsSym,\n  redactFmtSym,\n  serializersSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifiersSym,\n  setLevelSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  nestedKeySym,\n  mixinSym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym\n} = symbols\nconst { epochTime, nullTime } = time\nconst { pid } = process\nconst hostname = os.hostname()\nconst defaultErrorSerializer = stdSerializers.err\nconst defaultOptions = {\n  level: 'info',\n  messageKey: 'msg',\n  nestedKey: null,\n  enabled: true,\n  prettyPrint: false,\n  base: { pid, hostname },\n  serializers: Object.assign(Object.create(null), {\n    err: defaultErrorSerializer\n  }),\n  formatters: Object.assign(Object.create(null), {\n    bindings (bindings) {\n      return bindings\n    },\n    level (label, number) {\n      return { level: number }\n    }\n  }),\n  hooks: {\n    logMethod: undefined\n  },\n  timestamp: epochTime,\n  name: undefined,\n  redact: null,\n  customLevels: null,\n  levelKey: undefined,\n  useOnlyCustomLevels: false\n}\n\nconst normalize = createArgsNormalizer(defaultOptions)\n\nconst serializers = Object.assign(Object.create(null), stdSerializers)\n\nfunction pino (...args) {\n  const instance = {}\n  const { opts, stream } = normalize(instance, ...args)\n  const {\n    redact,\n    crlf,\n    serializers,\n    timestamp,\n    messageKey,\n    nestedKey,\n    base,\n    name,\n    level,\n    customLevels,\n    useLevelLabels,\n    changeLevelName,\n    levelKey,\n    mixin,\n    useOnlyCustomLevels,\n    formatters,\n    hooks\n  } = opts\n\n  const allFormatters = buildFormatters(\n    formatters.level,\n    formatters.bindings,\n    formatters.log\n  )\n\n  if (useLevelLabels && !(changeLevelName || levelKey)) {\n    process.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001')\n    allFormatters.level = labelsFormatter\n  } else if ((changeLevelName || levelKey) && !useLevelLabels) {\n    process.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002')\n    allFormatters.level = levelNameFormatter(changeLevelName || levelKey)\n  } else if ((changeLevelName || levelKey) && useLevelLabels) {\n    process.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001')\n    process.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002')\n    allFormatters.level = levelNameLabelFormatter(changeLevelName || levelKey)\n  }\n\n  if (serializers[Symbol.for('pino.*')]) {\n    process.emitWarning('The pino.* serializer is deprecated, use the formatters.log options instead', 'Warning', 'PINODEP003')\n    allFormatters.log = serializers[Symbol.for('pino.*')]\n  }\n\n  if (!allFormatters.bindings) {\n    allFormatters.bindings = defaultOptions.formatters.bindings\n  }\n  if (!allFormatters.level) {\n    allFormatters.level = defaultOptions.formatters.level\n  }\n\n  const stringifiers = redact ? redaction(redact, stringify) : {}\n  const formatOpts = redact\n    ? { stringify: stringifiers[redactFmtSym] }\n    : { stringify }\n  const end = '}' + (crlf ? '\\r\\n' : '\\n')\n  const coreChindings = asChindings.bind(null, {\n    [chindingsSym]: '',\n    [serializersSym]: serializers,\n    [stringifiersSym]: stringifiers,\n    [stringifySym]: stringify,\n    [formattersSym]: allFormatters\n  })\n\n  let chindings = ''\n  if (base !== null) {\n    if (name === undefined) {\n      chindings = coreChindings(base)\n    } else {\n      chindings = coreChindings(Object.assign({}, base, { name }))\n    }\n  }\n\n  const time = (timestamp instanceof Function)\n    ? timestamp\n    : (timestamp ? epochTime : nullTime)\n  const timeSliceIndex = time().indexOf(':') + 1\n\n  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')\n  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`)\n\n  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels)\n  const levels = mappings(customLevels, useOnlyCustomLevels)\n\n  Object.assign(instance, {\n    levels,\n    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n    [streamSym]: stream,\n    [timeSym]: time,\n    [timeSliceIndexSym]: timeSliceIndex,\n    [stringifySym]: stringify,\n    [stringifiersSym]: stringifiers,\n    [endSym]: end,\n    [formatOptsSym]: formatOpts,\n    [messageKeySym]: messageKey,\n    [nestedKeySym]: nestedKey,\n    [serializersSym]: serializers,\n    [mixinSym]: mixin,\n    [chindingsSym]: chindings,\n    [formattersSym]: allFormatters,\n    [hooksSym]: hooks,\n    silent: noop\n  })\n\n  Object.setPrototypeOf(instance, proto())\n\n  genLsCache(instance)\n\n  instance[setLevelSym](level)\n\n  return instance\n}\n\nfunction labelsFormatter (label, number) {\n  return { level: label }\n}\n\nfunction levelNameFormatter (name) {\n  return function (label, number) {\n    return { [name]: number }\n  }\n}\n\nfunction levelNameLabelFormatter (name) {\n  return function (label, number) {\n    return { [name]: label }\n  }\n}\n\nmodule.exports = pino\n\nmodule.exports.extreme = (dest = process.stdout.fd) => {\n  process.emitWarning(\n    'The pino.extreme() option is deprecated and will be removed in v7. Use pino.destination({ sync: false }) instead.',\n    { code: 'extreme_deprecation' }\n  )\n  return buildSafeSonicBoom({ dest, minLength: 4096, sync: false })\n}\n\nmodule.exports.destination = (dest = process.stdout.fd) => {\n  if (typeof dest === 'object') {\n    dest.dest = dest.dest || process.stdout.fd\n    return buildSafeSonicBoom(dest)\n  } else {\n    return buildSafeSonicBoom({ dest, minLength: 0, sync: true })\n  }\n}\n\nmodule.exports.final = final\nmodule.exports.levels = mappings()\nmodule.exports.stdSerializers = serializers\nmodule.exports.stdTimeFunctions = Object.assign({}, time)\nmodule.exports.symbols = symbols\nmodule.exports.version = version\n\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino\nmodule.exports.pino = pino\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/pino.js?");

/***/ }),

/***/ "../../../node_modules/process-warning/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/process-warning/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { format } = __webpack_require__(/*! util */ \"util\")\n\nfunction build () {\n  const codes = {}\n  const emitted = new Map()\n\n  function create (name, code, message) {\n    if (!name) throw new Error('Warning name must not be empty')\n    if (!code) throw new Error('Warning code must not be empty')\n    if (!message) throw new Error('Warning message must not be empty')\n\n    code = code.toUpperCase()\n\n    if (codes[code] !== undefined) {\n      throw new Error(`The code '${code}' already exist`)\n    }\n\n    function buildWarnOpts (a, b, c) {\n      // more performant than spread (...) operator\n      let formatted\n      if (a && b && c) {\n        formatted = format(message, a, b, c)\n      } else if (a && b) {\n        formatted = format(message, a, b)\n      } else if (a) {\n        formatted = format(message, a)\n      } else {\n        formatted = message\n      }\n\n      return {\n        code,\n        name,\n        message: formatted\n      }\n    }\n\n    emitted.set(code, false)\n    codes[code] = buildWarnOpts\n\n    return codes[code]\n  }\n\n  function emit (code, a, b, c) {\n    if (codes[code] === undefined) throw new Error(`The code '${code}' does not exist`)\n    if (emitted.get(code) === true) return\n    emitted.set(code, true)\n\n    const warning = codes[code](a, b, c)\n    process.emitWarning(warning.message, warning.name, warning.code)\n  }\n\n  return {\n    create,\n    emit,\n    emitted\n  }\n}\n\nmodule.exports = build\n\n\n//# sourceURL=webpack://qui/../../../node_modules/process-warning/index.js?");

/***/ }),

/***/ "../../../node_modules/proxy-addr/index.js":
/*!*************************************************!*\
  !*** ../../../node_modules/proxy-addr/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = __webpack_require__(/*! forwarded */ \"../../../node_modules/forwarded/index.js\")\nvar ipaddr = __webpack_require__(/*! ipaddr.js */ \"../../../node_modules/ipaddr.js/lib/ipaddr.js\")\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/proxy-addr/index.js?");

/***/ }),

/***/ "../../../node_modules/pump/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/pump/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var once = __webpack_require__(/*! once */ \"../../../node_modules/once/once.js\")\nvar eos = __webpack_require__(/*! end-of-stream */ \"../../../node_modules/end-of-stream/index.js\")\nvar fs = __webpack_require__(/*! fs */ \"fs\") // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n\n\n//# sourceURL=webpack://qui/../../../node_modules/pump/index.js?");

/***/ }),

/***/ "../../../node_modules/queue-microtask/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/queue-microtask/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n\n\n//# sourceURL=webpack://qui/../../../node_modules/queue-microtask/index.js?");

/***/ }),

/***/ "../../../node_modules/quick-format-unescaped/index.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/quick-format-unescaped/index.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction tryStringify (o) {\n  try { return JSON.stringify(o) } catch(e) { return '\"[Circular]\"' }\n}\n\nmodule.exports = format\n\nfunction format(f, args, opts) {\n  var ss = (opts && opts.stringify) || tryStringify\n  var offset = 1\n  if (typeof f === 'object' && f !== null) {\n    var len = args.length + offset\n    if (len === 1) return f\n    var objects = new Array(len)\n    objects[0] = ss(f)\n    for (var index = 1; index < len; index++) {\n      objects[index] = ss(args[index])\n    }\n    return objects.join(' ')\n  }\n  if (typeof f !== 'string') {\n    return f\n  }\n  var argLen = args.length\n  if (argLen === 0) return f\n  var str = ''\n  var a = 1 - offset\n  var lastPos = -1\n  var flen = (f && f.length) || 0\n  for (var i = 0; i < flen;) {\n    if (f.charCodeAt(i) === 37 && i + 1 < flen) {\n      lastPos = lastPos > -1 ? lastPos : 0\n      switch (f.charCodeAt(i + 1)) {\n        case 100: // 'd'\n        case 102: // 'f'\n          if (a >= argLen)\n            break\n          if (args[a] == null)  break\n          if (lastPos < i)\n            str += f.slice(lastPos, i)\n          str += Number(args[a])\n          lastPos = i + 2\n          i++\n          break\n        case 105: // 'i'\n          if (a >= argLen)\n            break\n          if (args[a] == null)  break\n          if (lastPos < i)\n            str += f.slice(lastPos, i)\n          str += Math.floor(Number(args[a]))\n          lastPos = i + 2\n          i++\n          break\n        case 79: // 'O'\n        case 111: // 'o'\n        case 106: // 'j'\n          if (a >= argLen)\n            break\n          if (args[a] === undefined) break\n          if (lastPos < i)\n            str += f.slice(lastPos, i)\n          var type = typeof args[a]\n          if (type === 'string') {\n            str += '\\'' + args[a] + '\\''\n            lastPos = i + 2\n            i++\n            break\n          }\n          if (type === 'function') {\n            str += args[a].name || '<anonymous>'\n            lastPos = i + 2\n            i++\n            break\n          }\n          str += ss(args[a])\n          lastPos = i + 2\n          i++\n          break\n        case 115: // 's'\n          if (a >= argLen)\n            break\n          if (lastPos < i)\n            str += f.slice(lastPos, i)\n          str += String(args[a])\n          lastPos = i + 2\n          i++\n          break\n        case 37: // '%'\n          if (lastPos < i)\n            str += f.slice(lastPos, i)\n          str += '%'\n          lastPos = i + 2\n          i++\n          a--\n          break\n      }\n      ++a\n    }\n    ++i\n  }\n  if (lastPos === -1)\n    return f\n  else if (lastPos < flen) {\n    str += f.slice(lastPos)\n  }\n\n  return str\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/quick-format-unescaped/index.js?");

/***/ }),

/***/ "../../../node_modules/range-parser/index.js":
/*!***************************************************!*\
  !*** ../../../node_modules/range-parser/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/range-parser/index.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/errors.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/readable-stream/errors.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n\n  function getMessage (arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message\n    } else {\n      return message(arg1, arg2, arg3)\n    }\n  }\n\n  class NodeError extends Base {\n    constructor (arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n\treturn str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n\tif (this_len === undefined || this_len > str.length) {\n\t\tthis_len = str.length;\n\t}\n\treturn str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"'\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented'\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/errors.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/_stream_duplex.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"../../../node_modules/readable-stream/lib/_stream_readable.js\");\n\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"../../../node_modules/readable-stream/lib/_stream_writable.js\");\n\n__webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/_stream_passthrough.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"../../../node_modules/readable-stream/lib/_stream_transform.js\");\n\n__webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/_stream_readable.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/_stream_readable.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../../../node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"../../../node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../../../node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"../../../node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../../../node_modules/readable-stream/errors.js\").codes),\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"../../../node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"../../../node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"../../../node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"../../../node_modules/readable-stream/lib/internal/streams/from.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/_stream_transform.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/_stream_transform.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../../../node_modules/readable-stream/errors.js\").codes),\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/_stream_writable.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/_stream_writable.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"../../../node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../../../node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../../../node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"../../../node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../../../node_modules/readable-stream/errors.js\").codes),\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"../../../node_modules/inherits/inherits.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! buffer */ \"buffer\"),\n    Buffer = _require.Buffer;\n\nvar _require2 = __webpack_require__(/*! util */ \"util\"),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
eval(" // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"../../../node_modules/readable-stream/errors.js\").codes.ERR_STREAM_PREMATURE_CLOSE);\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/from.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/from.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar ERR_INVALID_ARG_TYPE = (__webpack_require__(/*! ../../../errors */ \"../../../node_modules/readable-stream/errors.js\").codes.ERR_INVALID_ARG_TYPE);\n\nfunction from(Readable, iterable, opts) {\n  var iterator;\n\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts)); // Reading boolean to protect against _read\n  // being called before last iteration completion.\n\n  var reading = false;\n\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _ref = yield iterator.next(),\n            value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          readable.push(null);\n        } else if (readable.push((yield value))) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n\n  return readable;\n}\n\nmodule.exports = from;\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/from.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"../../../node_modules/readable-stream/errors.js\").codes),\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/state.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/state.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"../../../node_modules/readable-stream/errors.js\").codes.ERR_INVALID_OPT_VALUE);\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/lib/internal/streams/stream.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! stream */ \"stream\");\n\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/lib/internal/streams/stream.js?");

/***/ }),

/***/ "../../../node_modules/readable-stream/readable.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/readable-stream/readable.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"../../../node_modules/readable-stream/lib/_stream_readable.js\");\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"../../../node_modules/readable-stream/lib/_stream_writable.js\");\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"../../../node_modules/readable-stream/lib/_stream_duplex.js\");\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"../../../node_modules/readable-stream/lib/_stream_transform.js\");\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"../../../node_modules/readable-stream/lib/_stream_passthrough.js\");\n  exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"../../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"../../../node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/readable-stream/readable.js?");

/***/ }),

/***/ "../../../node_modules/ret/lib/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/ret/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util      = __webpack_require__(/*! ./util */ \"../../../node_modules/ret/lib/util.js\");\nconst types     = __webpack_require__(/*! ./types */ \"../../../node_modules/ret/lib/types.js\");\nconst sets      = __webpack_require__(/*! ./sets */ \"../../../node_modules/ret/lib/sets.js\");\nconst positions = __webpack_require__(/*! ./positions */ \"../../../node_modules/ret/lib/positions.js\");\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ret/lib/index.js?");

/***/ }),

/***/ "../../../node_modules/ret/lib/positions.js":
/*!**************************************************!*\
  !*** ../../../node_modules/ret/lib/positions.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const types = __webpack_require__(/*! ./types */ \"../../../node_modules/ret/lib/types.js\");\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ret/lib/positions.js?");

/***/ }),

/***/ "../../../node_modules/ret/lib/sets.js":
/*!*********************************************!*\
  !*** ../../../node_modules/ret/lib/sets.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const types = __webpack_require__(/*! ./types */ \"../../../node_modules/ret/lib/types.js\");\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ret/lib/sets.js?");

/***/ }),

/***/ "../../../node_modules/ret/lib/types.js":
/*!**********************************************!*\
  !*** ../../../node_modules/ret/lib/types.js ***!
  \**********************************************/
/***/ ((module) => {

eval("module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ret/lib/types.js?");

/***/ }),

/***/ "../../../node_modules/ret/lib/util.js":
/*!*********************************************!*\
  !*** ../../../node_modules/ret/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const types = __webpack_require__(/*! ./types */ \"../../../node_modules/ret/lib/types.js\");\nconst sets  = __webpack_require__(/*! ./sets */ \"../../../node_modules/ret/lib/sets.js\");\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/ret/lib/util.js?");

/***/ }),

/***/ "../../../node_modules/reusify/reusify.js":
/*!************************************************!*\
  !*** ../../../node_modules/reusify/reusify.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction reusify (Constructor) {\n  var head = new Constructor()\n  var tail = head\n\n  function get () {\n    var current = head\n\n    if (current.next) {\n      head = current.next\n    } else {\n      head = new Constructor()\n      tail = head\n    }\n\n    current.next = null\n\n    return current\n  }\n\n  function release (obj) {\n    tail.next = obj\n    tail = obj\n  }\n\n  return {\n    get: get,\n    release: release\n  }\n}\n\nmodule.exports = reusify\n\n\n//# sourceURL=webpack://qui/../../../node_modules/reusify/reusify.js?");

/***/ }),

/***/ "../../../node_modules/rfdc/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/rfdc/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = rfdc\n\nfunction copyBuffer (cur) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n  opts = opts || {}\n\n  if (opts.circles) return rfdcCircles(opts)\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        a2[k] = fn(cur)\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = clone(cur)\n      }\n    }\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = cloneProto(cur)\n      }\n    }\n    return o2\n  }\n}\n\nfunction rfdcCircles (opts) {\n  var refs = []\n  var refsNew = []\n\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        var index = refs.indexOf(cur)\n        if (index !== -1) {\n          a2[k] = refsNew[index]\n        } else {\n          a2[k] = fn(cur)\n        }\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = clone(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = cloneProto(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/rfdc/index.js?");

/***/ }),

/***/ "../../../node_modules/safe-regex2/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/safe-regex2/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar parse = __webpack_require__(/*! ret */ \"../../../node_modules/ret/lib/index.js\")\nvar types = parse.types\n\nmodule.exports = function (re, opts) {\n  if (!opts) opts = {}\n  var replimit = opts.limit === undefined ? 25 : opts.limit\n\n  if (isRegExp(re)) re = re.source\n  else if (typeof re !== 'string') re = String(re)\n\n  try { re = parse(re) } catch (err) { return false }\n\n  var reps = 0\n  return (function walk (node, starHeight) {\n    var i\n    var ok\n    var len\n\n    if (node.type === types.REPETITION) {\n      starHeight++\n      reps++\n      if (starHeight > 1) return false\n      if (reps > replimit) return false\n    }\n\n    if (node.options) {\n      for (i = 0, len = node.options.length; i < len; i++) {\n        ok = walk({ stack: node.options[i] }, starHeight)\n        if (!ok) return false\n      }\n    }\n    var stack = node.stack || (node.value && node.value.stack)\n    if (!stack) return true\n\n    for (i = 0; i < stack.length; i++) {\n      ok = walk(stack[i], starHeight)\n      if (!ok) return false\n    }\n\n    return true\n  })(re, 0)\n}\n\nfunction isRegExp (x) {\n  return {}.toString.call(x) === '[object RegExp]'\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/safe-regex2/index.js?");

/***/ }),

/***/ "../../../node_modules/secure-json-parse/index.js":
/*!********************************************************!*\
  !*** ../../../node_modules/secure-json-parse/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    } else {\n      options = {}\n    }\n  }\n\n  const protoAction = options.protoAction || 'error'\n  const constructorAction = options.constructorAction || 'error'\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  scan(obj, { protoAction, constructorAction })\n\n  return obj\n}\n\nfunction scan (obj, { protoAction = 'error', constructorAction = 'error' } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(node[key])\n        }\n      }\n    }\n  }\n}\n\nfunction safeParse (text, reviver) {\n  try {\n    return parse(text, reviver)\n  } catch (ignoreError) {\n    return null\n  }\n}\n\nmodule.exports = {\n  parse,\n  scan,\n  safeParse\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/secure-json-parse/index.js?");

/***/ }),

/***/ "../../../node_modules/semver-store/index.js":
/*!***************************************************!*\
  !*** ../../../node_modules/semver-store/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction SemVerStore () {\n  if (!(this instanceof SemVerStore)) {\n    return new SemVerStore()\n  }\n  this.tree = new Node()\n}\n\nSemVerStore.prototype.set = function (version, store) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  var currentNode = this.tree\n  version = version.split('.')\n  while (version.length) {\n    currentNode = currentNode.addChild(\n      new Node(version.shift())\n    )\n  }\n  currentNode.setStore(store)\n  return this\n}\n\nSemVerStore.prototype.get = function (version) {\n  if (typeof version !== 'string') return null\n  if (version === '*') version = 'x.x.x'\n  var node = this.tree\n  var firstDot = version.indexOf('.')\n  var secondDot = version.indexOf('.', firstDot + 1)\n  var major = version.slice(0, firstDot)\n  var minor = secondDot === -1\n    ? version.slice(firstDot + 1)\n    : version.slice(firstDot + 1, secondDot)\n  var patch = secondDot === -1\n    ? 'x'\n    : version.slice(secondDot + 1)\n\n  node = node.getChild(major)\n  if (node === null) return null\n  node = node.getChild(minor)\n  if (node === null) return null\n  node = node.getChild(patch)\n  if (node === null) return null\n  return node.store\n}\n\nSemVerStore.prototype.del = function (version) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  var firstDot = version.indexOf('.')\n  var secondDot = version.indexOf('.', firstDot + 1)\n  var major = version.slice(0, firstDot)\n  var minor = secondDot === -1\n    ? version.slice(firstDot + 1)\n    : version.slice(firstDot + 1, secondDot)\n  var patch = secondDot === -1\n    ? 'x'\n    : version.slice(secondDot + 1)\n\n  // check existence of major node\n  var majorNode = this.tree.children[major]\n  if (majorNode == null) return this\n\n  // if minor is the wildcard, then remove the full major node\n  if (minor === 'x') {\n    this.tree.removeChild(major)\n    return this\n  }\n\n  // check existence of minor node\n  var minorNode = majorNode.children[minor]\n  if (minorNode == null) return this\n\n  // if patch is the wildcard, then remove the full minor node\n  // and also the major if there are no more children\n  if (patch === 'x') {\n    this.tree.children[major].removeChild(minor)\n    if (this.tree.children[major].length === 0) {\n      this.tree.removeChild(major)\n    }\n    return this\n  }\n\n  // check existence of patch node\n  var patchNode = minorNode.children[patch]\n  if (patchNode == null) return this\n\n  // Specific delete\n  this.tree\n    .children[major]\n    .children[minor]\n    .removeChild(patch)\n\n  // check if the minor node has no more children, if so removes it\n  // same for the major node\n  if (this.tree.children[major].children[minor].length === 0) {\n    this.tree.children[major].removeChild(minor)\n    if (this.tree.children[major].length === 0) {\n      this.tree.removeChild(major)\n    }\n  }\n\n  return this\n}\n\nSemVerStore.prototype.empty = function () {\n  this.tree = new Node()\n  return this\n}\n\nfunction getMax (arr) {\n  var l = arr.length\n  var max = arr[0]\n  for (var i = 1; i < l; i++) {\n    if (arr[i] > max) {\n      max = arr[i]\n    }\n  }\n  return max\n}\n\nfunction Node (prefix, children, store) {\n  this.prefix = Number(prefix) || 0\n  this.children = children || null\n  this.childrenPrefixes = children ? Object.keys(children) : []\n  this.store = store || null\n}\n\nNode.prototype.getChild = function (prefix) {\n  if (this.children === null) return null\n  if (prefix === 'x') {\n    var max = getMax(this.childrenPrefixes)\n    return this.children[max]\n  }\n  return this.children[prefix] || null\n}\n\nNode.prototype.addChild = function (node) {\n  this.children = this.children || {}\n  var child = this.getChild(node.prefix)\n  if (child === null) {\n    this.children[node.prefix] = node\n    this.childrenPrefixes.push(node.prefix)\n  }\n  return child || node\n}\n\nNode.prototype.removeChild = function (prefix) {\n  if (prefix === 'x') {\n    this.children = null\n    this.childrenPrefixes = []\n    return this\n  }\n  if (this.children[prefix] !== undefined) {\n    prefix = Number(prefix)\n    delete this.children[prefix]\n    this.childrenPrefixes.splice(\n      this.childrenPrefixes.indexOf(prefix), 1\n    )\n  }\n  return this\n}\n\nNode.prototype.setStore = function (store) {\n  this.store = store\n  return this\n}\n\nObject.defineProperty(Node.prototype, 'length', {\n  get: function () {\n    return this.childrenPrefixes.length\n  }\n})\n\nmodule.exports = SemVerStore\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver-store/index.js?");

/***/ }),

/***/ "../../../node_modules/semver/classes/comparator.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/semver/classes/comparator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"../../../node_modules/semver/internal/parse-options.js\")\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"../../../node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"../../../node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"../../../node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"../../../node_modules/semver/classes/range.js\")\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/classes/comparator.js?");

/***/ }),

/***/ "../../../node_modules/semver/classes/range.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/classes/range.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0)\n        this.set = [first]\n      else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    range = range.trim()\n\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts = Object.keys(this.options).join(',')\n    const memoKey = `parseRange:${memoOpts}:${range}`\n    const cached = cache.get(memoKey)\n    if (cached)\n      return cached\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const l = rangeList.length\n    const rangeMap = new Map()\n    for (const comp of rangeList) {\n      if (isNullSet(comp))\n        return [comp]\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has(''))\n      rangeMap.delete('')\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"../../../node_modules/semver/node_modules/lru-cache/index.js\")\nconst cache = new LRU({ max: 1000 })\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"../../../node_modules/semver/internal/parse-options.js\")\nconst Comparator = __webpack_require__(/*! ./comparator */ \"../../../node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"../../../node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = __webpack_require__(/*! ../internal/re */ \"../../../node_modules/semver/internal/re.js\")\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/classes/range.js?");

/***/ }),

/***/ "../../../node_modules/semver/classes/semver.js":
/*!******************************************************!*\
  !*** ../../../node_modules/semver/classes/semver.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! ../internal/debug */ \"../../../node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"../../../node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"../../../node_modules/semver/internal/re.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"../../../node_modules/semver/internal/parse-options.js\")\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"../../../node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/classes/semver.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/clean.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/clean.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"../../../node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/clean.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/cmp.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/functions/cmp.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const eq = __webpack_require__(/*! ./eq */ \"../../../node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"../../../node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"../../../node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"../../../node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"../../../node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"../../../node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/cmp.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/coerce.js":
/*!********************************************************!*\
  !*** ../../../node_modules/semver/functions/coerce.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"../../../node_modules/semver/functions/parse.js\")\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"../../../node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/coerce.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/compare-build.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/semver/functions/compare-build.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/compare-build.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/compare-loose.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/semver/functions/compare-loose.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/compare-loose.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/compare.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/semver/functions/compare.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/compare.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/diff.js":
/*!******************************************************!*\
  !*** ../../../node_modules/semver/functions/diff.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"../../../node_modules/semver/functions/parse.js\")\nconst eq = __webpack_require__(/*! ./eq */ \"../../../node_modules/semver/functions/eq.js\")\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/diff.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/eq.js":
/*!****************************************************!*\
  !*** ../../../node_modules/semver/functions/eq.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/eq.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/gt.js":
/*!****************************************************!*\
  !*** ../../../node_modules/semver/functions/gt.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/gt.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/gte.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/functions/gte.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/gte.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/inc.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/functions/inc.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/inc.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/lt.js":
/*!****************************************************!*\
  !*** ../../../node_modules/semver/functions/lt.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/lt.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/lte.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/functions/lte.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/lte.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/major.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/major.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/major.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/minor.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/minor.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/minor.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/neq.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/functions/neq.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/neq.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/parse.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/parse.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ \"../../../node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"../../../node_modules/semver/internal/re.js\")\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"../../../node_modules/semver/internal/parse-options.js\")\nconst parse = (version, options) => {\n  options = parseOptions(options)\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/parse.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/patch.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/patch.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/patch.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/prerelease.js":
/*!************************************************************!*\
  !*** ../../../node_modules/semver/functions/prerelease.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"../../../node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/prerelease.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/rcompare.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/semver/functions/rcompare.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"../../../node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/rcompare.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/rsort.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/rsort.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"../../../node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/rsort.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/satisfies.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/semver/functions/satisfies.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/satisfies.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/sort.js":
/*!******************************************************!*\
  !*** ../../../node_modules/semver/functions/sort.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"../../../node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/sort.js?");

/***/ }),

/***/ "../../../node_modules/semver/functions/valid.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/functions/valid.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"../../../node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/functions/valid.js?");

/***/ }),

/***/ "../../../node_modules/semver/index.js":
/*!*********************************************!*\
  !*** ../../../node_modules/semver/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"../../../node_modules/semver/internal/re.js\")\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: (__webpack_require__(/*! ./internal/constants */ \"../../../node_modules/semver/internal/constants.js\").SEMVER_SPEC_VERSION),\n  SemVer: __webpack_require__(/*! ./classes/semver */ \"../../../node_modules/semver/classes/semver.js\"),\n  compareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"../../../node_modules/semver/internal/identifiers.js\").compareIdentifiers),\n  rcompareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"../../../node_modules/semver/internal/identifiers.js\").rcompareIdentifiers),\n  parse: __webpack_require__(/*! ./functions/parse */ \"../../../node_modules/semver/functions/parse.js\"),\n  valid: __webpack_require__(/*! ./functions/valid */ \"../../../node_modules/semver/functions/valid.js\"),\n  clean: __webpack_require__(/*! ./functions/clean */ \"../../../node_modules/semver/functions/clean.js\"),\n  inc: __webpack_require__(/*! ./functions/inc */ \"../../../node_modules/semver/functions/inc.js\"),\n  diff: __webpack_require__(/*! ./functions/diff */ \"../../../node_modules/semver/functions/diff.js\"),\n  major: __webpack_require__(/*! ./functions/major */ \"../../../node_modules/semver/functions/major.js\"),\n  minor: __webpack_require__(/*! ./functions/minor */ \"../../../node_modules/semver/functions/minor.js\"),\n  patch: __webpack_require__(/*! ./functions/patch */ \"../../../node_modules/semver/functions/patch.js\"),\n  prerelease: __webpack_require__(/*! ./functions/prerelease */ \"../../../node_modules/semver/functions/prerelease.js\"),\n  compare: __webpack_require__(/*! ./functions/compare */ \"../../../node_modules/semver/functions/compare.js\"),\n  rcompare: __webpack_require__(/*! ./functions/rcompare */ \"../../../node_modules/semver/functions/rcompare.js\"),\n  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ \"../../../node_modules/semver/functions/compare-loose.js\"),\n  compareBuild: __webpack_require__(/*! ./functions/compare-build */ \"../../../node_modules/semver/functions/compare-build.js\"),\n  sort: __webpack_require__(/*! ./functions/sort */ \"../../../node_modules/semver/functions/sort.js\"),\n  rsort: __webpack_require__(/*! ./functions/rsort */ \"../../../node_modules/semver/functions/rsort.js\"),\n  gt: __webpack_require__(/*! ./functions/gt */ \"../../../node_modules/semver/functions/gt.js\"),\n  lt: __webpack_require__(/*! ./functions/lt */ \"../../../node_modules/semver/functions/lt.js\"),\n  eq: __webpack_require__(/*! ./functions/eq */ \"../../../node_modules/semver/functions/eq.js\"),\n  neq: __webpack_require__(/*! ./functions/neq */ \"../../../node_modules/semver/functions/neq.js\"),\n  gte: __webpack_require__(/*! ./functions/gte */ \"../../../node_modules/semver/functions/gte.js\"),\n  lte: __webpack_require__(/*! ./functions/lte */ \"../../../node_modules/semver/functions/lte.js\"),\n  cmp: __webpack_require__(/*! ./functions/cmp */ \"../../../node_modules/semver/functions/cmp.js\"),\n  coerce: __webpack_require__(/*! ./functions/coerce */ \"../../../node_modules/semver/functions/coerce.js\"),\n  Comparator: __webpack_require__(/*! ./classes/comparator */ \"../../../node_modules/semver/classes/comparator.js\"),\n  Range: __webpack_require__(/*! ./classes/range */ \"../../../node_modules/semver/classes/range.js\"),\n  satisfies: __webpack_require__(/*! ./functions/satisfies */ \"../../../node_modules/semver/functions/satisfies.js\"),\n  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ \"../../../node_modules/semver/ranges/to-comparators.js\"),\n  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ \"../../../node_modules/semver/ranges/max-satisfying.js\"),\n  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ \"../../../node_modules/semver/ranges/min-satisfying.js\"),\n  minVersion: __webpack_require__(/*! ./ranges/min-version */ \"../../../node_modules/semver/ranges/min-version.js\"),\n  validRange: __webpack_require__(/*! ./ranges/valid */ \"../../../node_modules/semver/ranges/valid.js\"),\n  outside: __webpack_require__(/*! ./ranges/outside */ \"../../../node_modules/semver/ranges/outside.js\"),\n  gtr: __webpack_require__(/*! ./ranges/gtr */ \"../../../node_modules/semver/ranges/gtr.js\"),\n  ltr: __webpack_require__(/*! ./ranges/ltr */ \"../../../node_modules/semver/ranges/ltr.js\"),\n  intersects: __webpack_require__(/*! ./ranges/intersects */ \"../../../node_modules/semver/ranges/intersects.js\"),\n  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ \"../../../node_modules/semver/ranges/simplify.js\"),\n  subset: __webpack_require__(/*! ./ranges/subset */ \"../../../node_modules/semver/ranges/subset.js\"),\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/index.js?");

/***/ }),

/***/ "../../../node_modules/semver/internal/constants.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/semver/internal/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/internal/constants.js?");

/***/ }),

/***/ "../../../node_modules/semver/internal/debug.js":
/*!******************************************************!*\
  !*** ../../../node_modules/semver/internal/debug.js ***!
  \******************************************************/
/***/ ((module) => {

eval("const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/internal/debug.js?");

/***/ }),

/***/ "../../../node_modules/semver/internal/identifiers.js":
/*!************************************************************!*\
  !*** ../../../node_modules/semver/internal/identifiers.js ***!
  \************************************************************/
/***/ ((module) => {

eval("const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/internal/identifiers.js?");

/***/ }),

/***/ "../../../node_modules/semver/internal/parse-options.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/semver/internal/parse-options.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl']\nconst parseOptions = options =>\n  !options ? {}\n  : typeof options !== 'object' ? { loose: true }\n  : opts.filter(k => options[k]).reduce((options, k) => {\n    options[k] = true\n    return options\n  }, {})\nmodule.exports = parseOptions\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/internal/parse-options.js?");

/***/ }),

/***/ "../../../node_modules/semver/internal/re.js":
/*!***************************************************!*\
  !*** ../../../node_modules/semver/internal/re.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ \"../../../node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"../../../node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/internal/re.js?");

/***/ }),

/***/ "../../../node_modules/semver/node_modules/lru-cache/index.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/semver/node_modules/lru-cache/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"../../../node_modules/semver/node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/node_modules/lru-cache/index.js?");

/***/ }),

/***/ "../../../node_modules/semver/node_modules/yallist/iterator.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/semver/node_modules/yallist/iterator.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/node_modules/yallist/iterator.js?");

/***/ }),

/***/ "../../../node_modules/semver/node_modules/yallist/yallist.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/semver/node_modules/yallist/yallist.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"../../../node_modules/semver/node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/node_modules/yallist/yallist.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/gtr.js":
/*!**************************************************!*\
  !*** ../../../node_modules/semver/ranges/gtr.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"../../../node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/gtr.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/intersects.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/semver/ranges/intersects.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/intersects.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/ltr.js":
/*!**************************************************!*\
  !*** ../../../node_modules/semver/ranges/ltr.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const outside = __webpack_require__(/*! ./outside */ \"../../../node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/ltr.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/max-satisfying.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/semver/ranges/max-satisfying.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/max-satisfying.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/min-satisfying.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/semver/ranges/min-satisfying.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/min-satisfying.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/min-version.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/semver/ranges/min-version.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"../../../node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin)))\n      minver = setMin\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/min-version.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/outside.js":
/*!******************************************************!*\
  !*** ../../../node_modules/semver/ranges/outside.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"../../../node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"../../../node_modules/semver/classes/comparator.js\")\nconst {ANY} = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"../../../node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"../../../node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"../../../node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"../../../node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"../../../node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/outside.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/simplify.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/semver/ranges/simplify.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"../../../node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"../../../node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/simplify.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/subset.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/semver/ranges/subset.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range.js */ \"../../../node_modules/semver/classes/range.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"../../../node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"../../../node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"../../../node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom)\n    return true\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom)\n    return true\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY)\n      return true\n    else if (options.includePrerelease)\n      sub = [ new Comparator('>=0.0.0-0') ]\n    else\n      sub = [ new Comparator('>=0.0.0') ]\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease)\n      return true\n    else\n      dom = [ new Comparator('>=0.0.0') ]\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/subset.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/to-comparators.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/semver/ranges/to-comparators.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/to-comparators.js?");

/***/ }),

/***/ "../../../node_modules/semver/ranges/valid.js":
/*!****************************************************!*\
  !*** ../../../node_modules/semver/ranges/valid.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"../../../node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n\n\n//# sourceURL=webpack://qui/../../../node_modules/semver/ranges/valid.js?");

/***/ }),

/***/ "../../../node_modules/send/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/send/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * send\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = __webpack_require__(/*! http-errors */ \"../../../node_modules/http-errors/index.js\")\nvar debug = __webpack_require__(/*! debug */ \"../../../node_modules/send/node_modules/debug/src/index.js\")('send')\nvar deprecate = __webpack_require__(/*! depd */ \"../../../node_modules/depd/index.js\")('send')\nvar destroy = __webpack_require__(/*! destroy */ \"../../../node_modules/destroy/index.js\")\nvar encodeUrl = __webpack_require__(/*! encodeurl */ \"../../../node_modules/encodeurl/index.js\")\nvar escapeHtml = __webpack_require__(/*! escape-html */ \"../../../node_modules/escape-html/index.js\")\nvar etag = __webpack_require__(/*! etag */ \"../../../node_modules/etag/index.js\")\nvar fresh = __webpack_require__(/*! fresh */ \"../../../node_modules/fresh/index.js\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar mime = __webpack_require__(/*! mime */ \"../../../node_modules/mime/mime.js\")\nvar ms = __webpack_require__(/*! ms */ \"../../../node_modules/send/node_modules/ms/index.js\")\nvar onFinished = __webpack_require__(/*! on-finished */ \"../../../node_modules/on-finished/index.js\")\nvar parseRange = __webpack_require__(/*! range-parser */ \"../../../node_modules/range-parser/index.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar statuses = __webpack_require__(/*! statuses */ \"../../../node_modules/statuses/index.js\")\nvar Stream = __webpack_require__(/*! stream */ \"stream\")\nvar util = __webpack_require__(/*! util */ \"util\")\n\n/**\n * Path function references.\n * @private\n */\n\nvar extname = path.extname\nvar join = path.join\nvar normalize = path.normalize\nvar resolve = path.resolve\nvar sep = path.sep\n\n/**\n * Regular expression for identifying a bytes Range header.\n * @private\n */\n\nvar BYTES_RANGE_REGEXP = /^ *bytes=/\n\n/**\n * Maximum value allowed for the max age.\n * @private\n */\n\nvar MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year\n\n/**\n * Regular expression to match a path with a directory up component.\n * @private\n */\n\nvar UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = send\nmodule.exports.mime = mime\n\n/**\n * Return a `SendStream` for `req` and `path`.\n *\n * @param {object} req\n * @param {string} path\n * @param {object} [options]\n * @return {SendStream}\n * @public\n */\n\nfunction send (req, path, options) {\n  return new SendStream(req, path, options)\n}\n\n/**\n * Initialize a `SendStream` with the given `path`.\n *\n * @param {Request} req\n * @param {String} path\n * @param {object} [options]\n * @private\n */\n\nfunction SendStream (req, path, options) {\n  Stream.call(this)\n\n  var opts = options || {}\n\n  this.options = opts\n  this.path = path\n  this.req = req\n\n  this._acceptRanges = opts.acceptRanges !== undefined\n    ? Boolean(opts.acceptRanges)\n    : true\n\n  this._cacheControl = opts.cacheControl !== undefined\n    ? Boolean(opts.cacheControl)\n    : true\n\n  this._etag = opts.etag !== undefined\n    ? Boolean(opts.etag)\n    : true\n\n  this._dotfiles = opts.dotfiles !== undefined\n    ? opts.dotfiles\n    : 'ignore'\n\n  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {\n    throw new TypeError('dotfiles option must be \"allow\", \"deny\", or \"ignore\"')\n  }\n\n  this._hidden = Boolean(opts.hidden)\n\n  if (opts.hidden !== undefined) {\n    deprecate('hidden: use dotfiles: \\'' + (this._hidden ? 'allow' : 'ignore') + '\\' instead')\n  }\n\n  // legacy support\n  if (opts.dotfiles === undefined) {\n    this._dotfiles = undefined\n  }\n\n  this._extensions = opts.extensions !== undefined\n    ? normalizeList(opts.extensions, 'extensions option')\n    : []\n\n  this._immutable = opts.immutable !== undefined\n    ? Boolean(opts.immutable)\n    : false\n\n  this._index = opts.index !== undefined\n    ? normalizeList(opts.index, 'index option')\n    : ['index.html']\n\n  this._lastModified = opts.lastModified !== undefined\n    ? Boolean(opts.lastModified)\n    : true\n\n  this._maxage = opts.maxAge || opts.maxage\n  this._maxage = typeof this._maxage === 'string'\n    ? ms(this._maxage)\n    : Number(this._maxage)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n\n  this._root = opts.root\n    ? resolve(opts.root)\n    : null\n\n  if (!this._root && opts.from) {\n    this.from(opts.from)\n  }\n}\n\n/**\n * Inherits from `Stream`.\n */\n\nutil.inherits(SendStream, Stream)\n\n/**\n * Enable or disable etag generation.\n *\n * @param {Boolean} val\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.etag = deprecate.function(function etag (val) {\n  this._etag = Boolean(val)\n  debug('etag %s', this._etag)\n  return this\n}, 'send.etag: pass etag as option')\n\n/**\n * Enable or disable \"hidden\" (dot) files.\n *\n * @param {Boolean} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.hidden = deprecate.function(function hidden (val) {\n  this._hidden = Boolean(val)\n  this._dotfiles = undefined\n  debug('hidden %s', this._hidden)\n  return this\n}, 'send.hidden: use dotfiles option')\n\n/**\n * Set index `paths`, set to a falsy\n * value to disable index support.\n *\n * @param {String|Boolean|Array} paths\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.index = deprecate.function(function index (paths) {\n  var index = !paths ? [] : normalizeList(paths, 'paths argument')\n  debug('index %o', paths)\n  this._index = index\n  return this\n}, 'send.index: pass index as option')\n\n/**\n * Set root `path`.\n *\n * @param {String} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.root = function root (path) {\n  this._root = resolve(String(path))\n  debug('root %s', this._root)\n  return this\n}\n\nSendStream.prototype.from = deprecate.function(SendStream.prototype.root,\n  'send.from: pass root as option')\n\nSendStream.prototype.root = deprecate.function(SendStream.prototype.root,\n  'send.root: pass root as option')\n\n/**\n * Set max-age to `maxAge`.\n *\n * @param {Number} maxAge\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {\n  this._maxage = typeof maxAge === 'string'\n    ? ms(maxAge)\n    : Number(maxAge)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n  debug('max-age %d', this._maxage)\n  return this\n}, 'send.maxage: pass maxAge as option')\n\n/**\n * Emit error with `status`.\n *\n * @param {number} status\n * @param {Error} [err]\n * @private\n */\n\nSendStream.prototype.error = function error (status, err) {\n  // emit if listeners instead of responding\n  if (hasListeners(this, 'error')) {\n    return this.emit('error', createError(status, err, {\n      expose: false\n    }))\n  }\n\n  var res = this.res\n  var msg = statuses[status] || String(status)\n  var doc = createHtmlDocument('Error', escapeHtml(msg))\n\n  // clear existing headers\n  clearHeaders(res)\n\n  // add error headers\n  if (err && err.headers) {\n    setHeaders(res, err.headers)\n  }\n\n  // send basic response\n  res.statusCode = status\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.end(doc)\n}\n\n/**\n * Check if the pathname ends with \"/\".\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {\n  return this.path[this.path.length - 1] === '/'\n}\n\n/**\n * Check if this is a conditional GET request.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isConditionalGET = function isConditionalGET () {\n  return this.req.headers['if-match'] ||\n    this.req.headers['if-unmodified-since'] ||\n    this.req.headers['if-none-match'] ||\n    this.req.headers['if-modified-since']\n}\n\n/**\n * Check if the request preconditions failed.\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {\n  var req = this.req\n  var res = this.res\n\n  // if-match\n  var match = req.headers['if-match']\n  if (match) {\n    var etag = res.getHeader('ETag')\n    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {\n      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag\n    }))\n  }\n\n  // if-unmodified-since\n  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])\n  if (!isNaN(unmodifiedSince)) {\n    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))\n    return isNaN(lastModified) || lastModified > unmodifiedSince\n  }\n\n  return false\n}\n\n/**\n * Strip content-* header fields.\n *\n * @private\n */\n\nSendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {\n  var res = this.res\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    var header = headers[i]\n    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {\n      res.removeHeader(header)\n    }\n  }\n}\n\n/**\n * Respond with 304 not modified.\n *\n * @api private\n */\n\nSendStream.prototype.notModified = function notModified () {\n  var res = this.res\n  debug('not modified')\n  this.removeContentHeaderFields()\n  res.statusCode = 304\n  res.end()\n}\n\n/**\n * Raise error that headers already sent.\n *\n * @api private\n */\n\nSendStream.prototype.headersAlreadySent = function headersAlreadySent () {\n  var err = new Error('Can\\'t set headers after they are sent.')\n  debug('headers already sent')\n  this.error(500, err)\n}\n\n/**\n * Check if the request is cacheable, aka\n * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isCachable = function isCachable () {\n  var statusCode = this.res.statusCode\n  return (statusCode >= 200 && statusCode < 300) ||\n    statusCode === 304\n}\n\n/**\n * Handle stat() error.\n *\n * @param {Error} error\n * @private\n */\n\nSendStream.prototype.onStatError = function onStatError (error) {\n  switch (error.code) {\n    case 'ENAMETOOLONG':\n    case 'ENOENT':\n    case 'ENOTDIR':\n      this.error(404, error)\n      break\n    default:\n      this.error(500, error)\n      break\n  }\n}\n\n/**\n * Check if the cache is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isFresh = function isFresh () {\n  return fresh(this.req.headers, {\n    etag: this.res.getHeader('ETag'),\n    'last-modified': this.res.getHeader('Last-Modified')\n  })\n}\n\n/**\n * Check if the range is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isRangeFresh = function isRangeFresh () {\n  var ifRange = this.req.headers['if-range']\n\n  if (!ifRange) {\n    return true\n  }\n\n  // if-range as etag\n  if (ifRange.indexOf('\"') !== -1) {\n    var etag = this.res.getHeader('ETag')\n    return Boolean(etag && ifRange.indexOf(etag) !== -1)\n  }\n\n  // if-range as modified date\n  var lastModified = this.res.getHeader('Last-Modified')\n  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)\n}\n\n/**\n * Redirect to path.\n *\n * @param {string} path\n * @private\n */\n\nSendStream.prototype.redirect = function redirect (path) {\n  var res = this.res\n\n  if (hasListeners(this, 'directory')) {\n    this.emit('directory', res, path)\n    return\n  }\n\n  if (this.hasTrailingSlash()) {\n    this.error(403)\n    return\n  }\n\n  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))\n  var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + escapeHtml(loc) + '\">' +\n    escapeHtml(loc) + '</a>')\n\n  // redirect\n  res.statusCode = 301\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.setHeader('Location', loc)\n  res.end(doc)\n}\n\n/**\n * Pipe to `res.\n *\n * @param {Stream} res\n * @return {Stream} res\n * @api public\n */\n\nSendStream.prototype.pipe = function pipe (res) {\n  // root path\n  var root = this._root\n\n  // references\n  this.res = res\n\n  // decode the path\n  var path = decode(this.path)\n  if (path === -1) {\n    this.error(400)\n    return res\n  }\n\n  // null byte(s)\n  if (~path.indexOf('\\0')) {\n    this.error(400)\n    return res\n  }\n\n  var parts\n  if (root !== null) {\n    // normalize\n    if (path) {\n      path = normalize('.' + sep + path)\n    }\n\n    // malicious path\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = path.split(sep)\n\n    // join / normalize from optional root dir\n    path = normalize(join(root, path))\n  } else {\n    // \"..\" is malicious without \"root\"\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = normalize(path).split(sep)\n\n    // resolve the path\n    path = resolve(path)\n  }\n\n  // dotfile handling\n  if (containsDotFile(parts)) {\n    var access = this._dotfiles\n\n    // legacy support\n    if (access === undefined) {\n      access = parts[parts.length - 1][0] === '.'\n        ? (this._hidden ? 'allow' : 'ignore')\n        : 'allow'\n    }\n\n    debug('%s dotfile \"%s\"', access, path)\n    switch (access) {\n      case 'allow':\n        break\n      case 'deny':\n        this.error(403)\n        return res\n      case 'ignore':\n      default:\n        this.error(404)\n        return res\n    }\n  }\n\n  // index file support\n  if (this._index.length && this.hasTrailingSlash()) {\n    this.sendIndex(path)\n    return res\n  }\n\n  this.sendFile(path)\n  return res\n}\n\n/**\n * Transfer `path`.\n *\n * @param {String} path\n * @api public\n */\n\nSendStream.prototype.send = function send (path, stat) {\n  var len = stat.size\n  var options = this.options\n  var opts = {}\n  var res = this.res\n  var req = this.req\n  var ranges = req.headers.range\n  var offset = options.start || 0\n\n  if (headersSent(res)) {\n    // impossible to send now\n    this.headersAlreadySent()\n    return\n  }\n\n  debug('pipe \"%s\"', path)\n\n  // set header fields\n  this.setHeader(path, stat)\n\n  // set content-type\n  this.type(path)\n\n  // conditional GET support\n  if (this.isConditionalGET()) {\n    if (this.isPreconditionFailure()) {\n      this.error(412)\n      return\n    }\n\n    if (this.isCachable() && this.isFresh()) {\n      this.notModified()\n      return\n    }\n  }\n\n  // adjust len to start/end options\n  len = Math.max(0, len - offset)\n  if (options.end !== undefined) {\n    var bytes = options.end - offset + 1\n    if (len > bytes) len = bytes\n  }\n\n  // Range support\n  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {\n    // parse\n    ranges = parseRange(len, ranges, {\n      combine: true\n    })\n\n    // If-Range support\n    if (!this.isRangeFresh()) {\n      debug('range stale')\n      ranges = -2\n    }\n\n    // unsatisfiable\n    if (ranges === -1) {\n      debug('range unsatisfiable')\n\n      // Content-Range\n      res.setHeader('Content-Range', contentRange('bytes', len))\n\n      // 416 Requested Range Not Satisfiable\n      return this.error(416, {\n        headers: { 'Content-Range': res.getHeader('Content-Range') }\n      })\n    }\n\n    // valid (syntactically invalid/multiple ranges are treated as a regular response)\n    if (ranges !== -2 && ranges.length === 1) {\n      debug('range %j', ranges)\n\n      // Content-Range\n      res.statusCode = 206\n      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))\n\n      // adjust for requested range\n      offset += ranges[0].start\n      len = ranges[0].end - ranges[0].start + 1\n    }\n  }\n\n  // clone options\n  for (var prop in options) {\n    opts[prop] = options[prop]\n  }\n\n  // set read options\n  opts.start = offset\n  opts.end = Math.max(offset, offset + len - 1)\n\n  // content-length\n  res.setHeader('Content-Length', len)\n\n  // HEAD support\n  if (req.method === 'HEAD') {\n    res.end()\n    return\n  }\n\n  this.stream(path, opts)\n}\n\n/**\n * Transfer file for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendFile = function sendFile (path) {\n  var i = 0\n  var self = this\n\n  debug('stat \"%s\"', path)\n  fs.stat(path, function onstat (err, stat) {\n    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {\n      // not found, check extensions\n      return next(err)\n    }\n    if (err) return self.onStatError(err)\n    if (stat.isDirectory()) return self.redirect(path)\n    self.emit('file', path, stat)\n    self.send(path, stat)\n  })\n\n  function next (err) {\n    if (self._extensions.length <= i) {\n      return err\n        ? self.onStatError(err)\n        : self.error(404)\n    }\n\n    var p = path + '.' + self._extensions[i++]\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n}\n\n/**\n * Transfer index for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendIndex = function sendIndex (path) {\n  var i = -1\n  var self = this\n\n  function next (err) {\n    if (++i >= self._index.length) {\n      if (err) return self.onStatError(err)\n      return self.error(404)\n    }\n\n    var p = join(path, self._index[i])\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n\n  next()\n}\n\n/**\n * Stream `path` to the response.\n *\n * @param {String} path\n * @param {Object} options\n * @api private\n */\n\nSendStream.prototype.stream = function stream (path, options) {\n  // TODO: this is all lame, refactor meeee\n  var finished = false\n  var self = this\n  var res = this.res\n\n  // pipe\n  var stream = fs.createReadStream(path, options)\n  this.emit('stream', stream)\n  stream.pipe(res)\n\n  // response finished, done with the fd\n  onFinished(res, function onfinished () {\n    finished = true\n    destroy(stream)\n  })\n\n  // error handling code-smell\n  stream.on('error', function onerror (err) {\n    // request already finished\n    if (finished) return\n\n    // clean up stream\n    finished = true\n    destroy(stream)\n\n    // error\n    self.onStatError(err)\n  })\n\n  // end\n  stream.on('end', function onend () {\n    self.emit('end')\n  })\n}\n\n/**\n * Set content-type based on `path`\n * if it hasn't been explicitly set.\n *\n * @param {String} path\n * @api private\n */\n\nSendStream.prototype.type = function type (path) {\n  var res = this.res\n\n  if (res.getHeader('Content-Type')) return\n\n  var type = mime.lookup(path)\n\n  if (!type) {\n    debug('no content-type')\n    return\n  }\n\n  var charset = mime.charsets.lookup(type)\n\n  debug('content-type %s', type)\n  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))\n}\n\n/**\n * Set response header fields, most\n * fields may be pre-defined.\n *\n * @param {String} path\n * @param {Object} stat\n * @api private\n */\n\nSendStream.prototype.setHeader = function setHeader (path, stat) {\n  var res = this.res\n\n  this.emit('headers', res, path, stat)\n\n  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {\n    debug('accept ranges')\n    res.setHeader('Accept-Ranges', 'bytes')\n  }\n\n  if (this._cacheControl && !res.getHeader('Cache-Control')) {\n    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)\n\n    if (this._immutable) {\n      cacheControl += ', immutable'\n    }\n\n    debug('cache-control %s', cacheControl)\n    res.setHeader('Cache-Control', cacheControl)\n  }\n\n  if (this._lastModified && !res.getHeader('Last-Modified')) {\n    var modified = stat.mtime.toUTCString()\n    debug('modified %s', modified)\n    res.setHeader('Last-Modified', modified)\n  }\n\n  if (this._etag && !res.getHeader('ETag')) {\n    var val = etag(stat)\n    debug('etag %s', val)\n    res.setHeader('ETag', val)\n  }\n}\n\n/**\n * Clear all headers from a response.\n *\n * @param {object} res\n * @private\n */\n\nfunction clearHeaders (res) {\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    res.removeHeader(headers[i])\n  }\n}\n\n/**\n * Collapse all leading slashes into a single slash\n *\n * @param {string} str\n * @private\n */\nfunction collapseLeadingSlashes (str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] !== '/') {\n      break\n    }\n  }\n\n  return i > 1\n    ? '/' + str.substr(i)\n    : str\n}\n\n/**\n * Determine if path parts contain a dotfile.\n *\n * @api private\n */\n\nfunction containsDotFile (parts) {\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i]\n    if (part.length > 1 && part[0] === '.') {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a Content-Range header.\n *\n * @param {string} type\n * @param {number} size\n * @param {array} [range]\n */\n\nfunction contentRange (type, size, range) {\n  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size\n}\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\nfunction createHtmlDocument (title, body) {\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>' + title + '</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * decodeURIComponent.\n *\n * Allows V8 to only deoptimize this fn instead of all\n * of send().\n *\n * @param {String} path\n * @api private\n */\n\nfunction decode (path) {\n  try {\n    return decodeURIComponent(path)\n  } catch (err) {\n    return -1\n  }\n}\n\n/**\n * Get the header names on a respnse.\n *\n * @param {object} res\n * @returns {array[string]}\n * @private\n */\n\nfunction getHeaderNames (res) {\n  return typeof res.getHeaderNames !== 'function'\n    ? Object.keys(res._headers || {})\n    : res.getHeaderNames()\n}\n\n/**\n * Determine if emitter has listeners of a given type.\n *\n * The way to do this check is done three different ways in Node.js >= 0.8\n * so this consolidates them into a minimal set using instance methods.\n *\n * @param {EventEmitter} emitter\n * @param {string} type\n * @returns {boolean}\n * @private\n */\n\nfunction hasListeners (emitter, type) {\n  var count = typeof emitter.listenerCount !== 'function'\n    ? emitter.listeners(type).length\n    : emitter.listenerCount(type)\n\n  return count > 0\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Normalize the index option into an array.\n *\n * @param {boolean|string|array} val\n * @param {string} name\n * @private\n */\n\nfunction normalizeList (val, name) {\n  var list = [].concat(val || [])\n\n  for (var i = 0; i < list.length; i++) {\n    if (typeof list[i] !== 'string') {\n      throw new TypeError(name + ' must be array of strings or false')\n    }\n  }\n\n  return list\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        if (start !== end) {\n          list.push(str.substring(start, end))\n        }\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  if (start !== end) {\n    list.push(str.substring(start, end))\n  }\n\n  return list\n}\n\n/**\n * Set an object of headers on a response.\n *\n * @param {object} res\n * @param {object} headers\n * @private\n */\n\nfunction setHeaders (res, headers) {\n  var keys = Object.keys(headers)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    res.setHeader(key, headers[key])\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/index.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/debug/node_modules/ms/index.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/send/node_modules/debug/node_modules/ms/index.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/debug/node_modules/ms/index.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/debug/src/browser.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/send/node_modules/debug/src/browser.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"../../../node_modules/send/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/debug/src/debug.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/send/node_modules/debug/src/debug.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"../../../node_modules/send/node_modules/debug/node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/debug/src/debug.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/debug/src/index.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/send/node_modules/debug/src/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"../../../node_modules/send/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"../../../node_modules/send/node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/debug/src/index.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/debug/src/node.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/send/node_modules/debug/src/node.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"../../../node_modules/send/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/debug/src/node.js?");

/***/ }),

/***/ "../../../node_modules/send/node_modules/ms/index.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/send/node_modules/ms/index.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/send/node_modules/ms/index.js?");

/***/ }),

/***/ "../../../node_modules/set-cookie-parser/lib/set-cookie.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n  var nameValue = parts.shift().split(\"=\");\n  var name = nameValue.shift();\n  var value = nameValue.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name, // grab everything before the first =\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers && input.headers[\"set-cookie\"]) {\n    // fast-path for node.js (which automatically normalizes header names to lower-case\n    input = input.headers[\"set-cookie\"];\n  } else if (input.headers) {\n    // slow-path for other environments - see #25\n    var sch =\n      input.headers[\n        Object.keys(input.headers).find(function (key) {\n          return key.toLowerCase() === \"set-cookie\";\n        })\n      ];\n    // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n    if (!sch && input.headers.cookie && !options.silent) {\n      console.warn(\n        \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n      );\n    }\n    input = sch;\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/set-cookie-parser/lib/set-cookie.js?");

/***/ }),

/***/ "../../../node_modules/setprototypeof/index.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/setprototypeof/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* eslint no-proto: 0 */\nmodule.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)\n\nfunction setProtoOf (obj, proto) {\n  obj.__proto__ = proto\n  return obj\n}\n\nfunction mixinProperties (obj, proto) {\n  for (var prop in proto) {\n    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {\n      obj[prop] = proto[prop]\n    }\n  }\n  return obj\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/setprototypeof/index.js?");

/***/ }),

/***/ "../../../node_modules/sonic-boom/index.js":
/*!*************************************************!*\
  !*** ../../../node_modules/sonic-boom/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst EventEmitter = __webpack_require__(/*! events */ \"events\")\nconst flatstr = __webpack_require__(/*! flatstr */ \"../../../node_modules/flatstr/index.js\")\nconst inherits = (__webpack_require__(/*! util */ \"util\").inherits)\n\nconst BUSY_WRITE_TIMEOUT = 100\n\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"../../../node_modules/atomic-sleep/index.js\")\n\n// 16 MB - magic number\n// This constant ensures that SonicBoom only needs\n// 32 MB of free memory to run. In case of having 1GB+\n// of data to write, this prevents an out of memory\n// condition.\nconst MAX_WRITE = 16 * 1024 * 1024\n\nfunction openFile (file, sonic) {\n  sonic._opening = true\n  sonic._writing = true\n  sonic._asyncDrainScheduled = false\n\n  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false\n  // for sync mode, there is no way to add a listener that will receive these\n\n  function fileOpened (err, fd) {\n    if (err) {\n      sonic._reopening = false\n      sonic._writing = false\n      sonic._opening = false\n\n      if (sonic.sync) {\n        process.nextTick(() => {\n          if (sonic.listenerCount('error') > 0) {\n            sonic.emit('error', err)\n          }\n        })\n      } else {\n        sonic.emit('error', err)\n      }\n      return\n    }\n\n    sonic.fd = fd\n    sonic.file = file\n    sonic._reopening = false\n    sonic._opening = false\n    sonic._writing = false\n\n    if (sonic.sync) {\n      process.nextTick(() => sonic.emit('ready'))\n    } else {\n      sonic.emit('ready')\n    }\n\n    if (sonic._reopening) {\n      return\n    }\n\n    // start\n    const len = sonic._buf.length\n    if (len > 0 && len > sonic.minLength && !sonic.destroyed) {\n      actualWrite(sonic)\n    }\n  }\n\n  if (sonic.sync) {\n    try {\n      const fd = fs.openSync(file, 'a')\n      fileOpened(null, fd)\n    } catch (err) {\n      fileOpened(err)\n      throw err\n    }\n  } else {\n    fs.open(file, 'a', fileOpened)\n  }\n}\n\nfunction SonicBoom (opts) {\n  if (!(this instanceof SonicBoom)) {\n    return new SonicBoom(opts)\n  }\n\n  let { fd, dest, minLength, sync } = opts || {}\n\n  fd = fd || dest\n\n  this._buf = ''\n  this.fd = -1\n  this._writing = false\n  this._writingBuf = ''\n  this._ending = false\n  this._reopening = false\n  this._asyncDrainScheduled = false\n  this.file = null\n  this.destroyed = false\n  this.sync = sync || false\n\n  this.minLength = minLength || 0\n\n  if (typeof fd === 'number') {\n    this.fd = fd\n    process.nextTick(() => this.emit('ready'))\n  } else if (typeof fd === 'string') {\n    openFile(fd, this)\n  } else {\n    throw new Error('SonicBoom supports only file descriptors and files')\n  }\n\n  this.release = (err, n) => {\n    if (err) {\n      if (err.code === 'EAGAIN') {\n        if (this.sync) {\n          // This error code should not happen in sync mode, because it is\n          // not using the underlining operating system asynchronous functions.\n          // However it happens, and so we handle it.\n          // Ref: https://github.com/pinojs/pino/issues/783\n          try {\n            sleep(BUSY_WRITE_TIMEOUT)\n            this.release(undefined, 0)\n          } catch (err) {\n            this.release(err)\n          }\n        } else {\n          // Let's give the destination some time to process the chunk.\n          setTimeout(() => {\n            fs.write(this.fd, this._writingBuf, 'utf8', this.release)\n          }, BUSY_WRITE_TIMEOUT)\n        }\n      } else {\n        // The error maybe recoverable later, so just put data back to this._buf\n        this._buf = this._writingBuf + this._buf\n        this._writingBuf = ''\n        this._writing = false\n\n        this.emit('error', err)\n      }\n      return\n    }\n\n    if (this._writingBuf.length !== n) {\n      this._writingBuf = this._writingBuf.slice(n)\n      if (this.sync) {\n        try {\n          do {\n            n = fs.writeSync(this.fd, this._writingBuf, 'utf8')\n            this._writingBuf = this._writingBuf.slice(n)\n          } while (this._writingBuf.length !== 0)\n        } catch (err) {\n          this.release(err)\n          return\n        }\n      } else {\n        fs.write(this.fd, this._writingBuf, 'utf8', this.release)\n        return\n      }\n    }\n\n    this._writingBuf = ''\n\n    if (this.destroyed) {\n      return\n    }\n\n    const len = this._buf.length\n    if (this._reopening) {\n      this._writing = false\n      this._reopening = false\n      this.reopen()\n    } else if (len > 0 && len > this.minLength) {\n      actualWrite(this)\n    } else if (this._ending) {\n      if (len > 0) {\n        actualWrite(this)\n      } else {\n        this._writing = false\n        actualClose(this)\n      }\n    } else {\n      this._writing = false\n      if (this.sync) {\n        if (!this._asyncDrainScheduled) {\n          this._asyncDrainScheduled = true\n          process.nextTick(emitDrain, this)\n        }\n      } else {\n        this.emit('drain')\n      }\n    }\n  }\n\n  this.on('newListener', function (name) {\n    if (name === 'drain') {\n      this._asyncDrainScheduled = false\n    }\n  })\n}\n\nfunction emitDrain (sonic) {\n  const hasListeners = sonic.listenerCount('drain') > 0\n  if (!hasListeners) return\n  sonic._asyncDrainScheduled = false\n  sonic.emit('drain')\n}\n\ninherits(SonicBoom, EventEmitter)\n\nSonicBoom.prototype.write = function (data) {\n  if (this.destroyed) {\n    throw new Error('SonicBoom destroyed')\n  }\n\n  this._buf += data\n  const len = this._buf.length\n  if (!this._writing && len > this.minLength) {\n    actualWrite(this)\n  }\n  return len < 16384\n}\n\nSonicBoom.prototype.flush = function () {\n  if (this.destroyed) {\n    throw new Error('SonicBoom destroyed')\n  }\n\n  if (this._writing || this.minLength <= 0) {\n    return\n  }\n\n  actualWrite(this)\n}\n\nSonicBoom.prototype.reopen = function (file) {\n  if (this.destroyed) {\n    throw new Error('SonicBoom destroyed')\n  }\n\n  if (this._opening) {\n    this.once('ready', () => {\n      this.reopen(file)\n    })\n    return\n  }\n\n  if (this._ending) {\n    return\n  }\n\n  if (!this.file) {\n    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')\n  }\n\n  this._reopening = true\n\n  if (this._writing) {\n    return\n  }\n\n  const fd = this.fd\n  this.once('ready', () => {\n    if (fd !== this.fd) {\n      fs.close(fd, (err) => {\n        if (err) {\n          return this.emit('error', err)\n        }\n      })\n    }\n  })\n\n  openFile(file || this.file, this)\n}\n\nSonicBoom.prototype.end = function () {\n  if (this.destroyed) {\n    throw new Error('SonicBoom destroyed')\n  }\n\n  if (this._opening) {\n    this.once('ready', () => {\n      this.end()\n    })\n    return\n  }\n\n  if (this._ending) {\n    return\n  }\n\n  this._ending = true\n\n  if (!this._writing && this._buf.length > 0 && this.fd >= 0) {\n    actualWrite(this)\n    return\n  }\n\n  if (this._writing) {\n    return\n  }\n\n  actualClose(this)\n}\n\nSonicBoom.prototype.flushSync = function () {\n  if (this.destroyed) {\n    throw new Error('SonicBoom destroyed')\n  }\n\n  if (this.fd < 0) {\n    throw new Error('sonic boom is not ready yet')\n  }\n\n  while (this._buf.length > 0) {\n    try {\n      fs.writeSync(this.fd, this._buf, 'utf8')\n      this._buf = ''\n    } catch (err) {\n      if (err.code !== 'EAGAIN') {\n        throw err\n      }\n\n      sleep(BUSY_WRITE_TIMEOUT)\n    }\n  }\n}\n\nSonicBoom.prototype.destroy = function () {\n  if (this.destroyed) {\n    return\n  }\n  actualClose(this)\n}\n\nfunction actualWrite (sonic) {\n  sonic._writing = true\n  let buf = sonic._buf\n  const release = sonic.release\n  if (buf.length > MAX_WRITE) {\n    buf = buf.slice(0, MAX_WRITE)\n    sonic._buf = sonic._buf.slice(MAX_WRITE)\n  } else {\n    sonic._buf = ''\n  }\n  flatstr(buf)\n  sonic._writingBuf = buf\n  if (sonic.sync) {\n    try {\n      const written = fs.writeSync(sonic.fd, buf, 'utf8')\n      release(null, written)\n    } catch (err) {\n      release(err)\n    }\n  } else {\n    fs.write(sonic.fd, buf, 'utf8', release)\n  }\n}\n\nfunction actualClose (sonic) {\n  if (sonic.fd === -1) {\n    sonic.once('ready', actualClose.bind(null, sonic))\n    return\n  }\n  // TODO write a test to check if we are not leaking fds\n  fs.close(sonic.fd, (err) => {\n    if (err) {\n      sonic.emit('error', err)\n      return\n    }\n\n    if (sonic._ending && !sonic._writing) {\n      sonic.emit('finish')\n    }\n    sonic.emit('close')\n  })\n  sonic.destroyed = true\n  sonic._buf = ''\n}\n\nmodule.exports = SonicBoom\n\n\n//# sourceURL=webpack://qui/../../../node_modules/sonic-boom/index.js?");

/***/ }),

/***/ "../../../node_modules/statuses/index.js":
/*!***********************************************!*\
  !*** ../../../node_modules/statuses/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = __webpack_require__(/*! ./codes.json */ \"../../../node_modules/statuses/codes.json\")\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/statuses/index.js?");

/***/ }),

/***/ "../../../node_modules/string-similarity/src/index.js":
/*!************************************************************!*\
  !*** ../../../node_modules/string-similarity/src/index.js ***!
  \************************************************************/
/***/ ((module) => {

eval("module.exports = {\n\tcompareTwoStrings:compareTwoStrings,\n\tfindBestMatch:findBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n\tfirst = first.replace(/\\s+/g, '')\n\tsecond = second.replace(/\\s+/g, '')\n\n\tif (first === second) return 1; // identical or empty\n\tif (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n\tlet firstBigrams = new Map();\n\tfor (let i = 0; i < first.length - 1; i++) {\n\t\tconst bigram = first.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram) + 1\n\t\t\t: 1;\n\n\t\tfirstBigrams.set(bigram, count);\n\t};\n\n\tlet intersectionSize = 0;\n\tfor (let i = 0; i < second.length - 1; i++) {\n\t\tconst bigram = second.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram)\n\t\t\t: 0;\n\n\t\tif (count > 0) {\n\t\t\tfirstBigrams.set(bigram, count - 1);\n\t\t\tintersectionSize++;\n\t\t}\n\t}\n\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n\t\n\tconst ratings = [];\n\tlet bestMatchIndex = 0;\n\n\tfor (let i = 0; i < targetStrings.length; i++) {\n\t\tconst currentTargetString = targetStrings[i];\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\n\t\tratings.push({target: currentTargetString, rating: currentRating})\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\n\t\t\tbestMatchIndex = i\n\t\t}\n\t}\n\t\n\t\n\tconst bestMatch = ratings[bestMatchIndex]\n\t\n\treturn { ratings: ratings, bestMatch: bestMatch, bestMatchIndex: bestMatchIndex };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n\tif (typeof mainString !== 'string') return false;\n\tif (!Array.isArray(targetStrings)) return false;\n\tif (!targetStrings.length) return false;\n\tif (targetStrings.find( function (s) { return typeof s !== 'string'})) return false;\n\treturn true;\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/string-similarity/src/index.js?");

/***/ }),

/***/ "../../../node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"../../../node_modules/string_decoder/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://qui/../../../node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "../../../node_modules/string_decoder/node_modules/safe-buffer/index.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/string_decoder/node_modules/safe-buffer/index.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/string_decoder/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "../../../node_modules/supports-color/index.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/supports-color/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"../../../node_modules/has-flag/index.js\");\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/supports-color/index.js?");

/***/ }),

/***/ "../../../node_modules/tiny-lru/lib/tiny-lru.cjs.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/tiny-lru/lib/tiny-lru.cjs.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass LRU {\r\n\t\tconstructor (max = 0, ttl = 0) {\r\n\t\t\tthis.first = null;\r\n\t\t\tthis.items = Object.create(null);\r\n\t\t\tthis.last = null;\r\n\t\t\tthis.max = max;\r\n\t\t\tthis.size = 0;\r\n\t\t\tthis.ttl = ttl;\r\n\t\t}\r\n\r\n\t\thas (key) {\r\n\t\t\treturn key in this.items;\r\n\t\t}\r\n\r\n\t\tclear () {\r\n\t\t\tthis.first = null;\r\n\t\t\tthis.items = Object.create(null);\r\n\t\t\tthis.last = null;\r\n\t\t\tthis.size = 0;\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tdelete (key) {\r\n\t\t\tif (this.has(key)) {\r\n\t\t\t\tconst item = this.items[key];\r\n\r\n\t\t\t\tdelete this.items[key];\r\n\t\t\t\tthis.size--;\r\n\r\n\t\t\t\tif (item.prev !== null) {\r\n\t\t\t\t\titem.prev.next = item.next;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (item.next !== null) {\r\n\t\t\t\t\titem.next.prev = item.prev;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.first === item) {\r\n\t\t\t\t\tthis.first = item.next;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.last === item) {\r\n\t\t\t\t\tthis.last = item.prev;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tevict () {\r\n\t\t\tconst item = this.first;\r\n\r\n\t\t\tdelete this.items[item.key];\r\n\t\t\tthis.first = item.next;\r\n\t\t\tthis.first.prev = null;\r\n\t\t\tthis.size--;\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tget (key) {\r\n\t\t\tlet result;\r\n\r\n\t\t\tif (this.has(key)) {\r\n\t\t\t\tconst item = this.items[key];\r\n\r\n\t\t\t\tif (this.ttl > 0 && item.expiry <= new Date().getTime()) {\r\n\t\t\t\t\tthis.delete(key);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult = item.value;\r\n\t\t\t\t\tthis.set(key, result, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tkeys () {\r\n\t\t\treturn Object.keys(this.items);\r\n\t\t}\r\n\r\n\t\tset (key, value, bypass = false) {\r\n\t\t\tlet item;\r\n\r\n\t\t\tif (bypass || this.has(key)) {\r\n\t\t\t\titem = this.items[key];\r\n\t\t\t\titem.value = value;\r\n\r\n\t\t\t\tif (bypass === false) {\r\n\t\t\t\t\titem.expiry = this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.last !== item) {\r\n\t\t\t\t\tconst last = this.last,\r\n\t\t\t\t\t\tnext = item.next,\r\n\t\t\t\t\t\tprev = item.prev;\r\n\r\n\t\t\t\t\tif (this.first === item) {\r\n\t\t\t\t\t\tthis.first = item.next;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titem.next = null;\r\n\t\t\t\t\titem.prev = this.last;\r\n\t\t\t\t\tlast.next = item;\r\n\r\n\t\t\t\t\tif (prev !== null) {\r\n\t\t\t\t\t\tprev.next = next;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (next !== null) {\r\n\t\t\t\t\t\tnext.prev = prev;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (this.max > 0 && this.size === this.max) {\r\n\t\t\t\t\tthis.evict();\r\n\t\t\t\t}\r\n\r\n\t\t\t\titem = this.items[key] = {\r\n\t\t\t\t\texpiry: this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\tprev: this.last,\r\n\t\t\t\t\tnext: null,\r\n\t\t\t\t\tvalue\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (++this.size === 1) {\r\n\t\t\t\t\tthis.first = item;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.last.next = item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.last = item;\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction factory (max = 1000, ttl = 0) {\r\n\t\tif (isNaN(max) || max < 0) {\r\n\t\t\tthrow new TypeError(\"Invalid max value\");\r\n\t\t}\r\n\r\n\t\tif (isNaN(ttl) || ttl < 0) {\r\n\t\t\tthrow new TypeError(\"Invalid ttl value\");\r\n\t\t}\r\n\r\n\t\treturn new LRU(max, ttl);\r\n\t}\n\nmodule.exports = factory;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/tiny-lru/lib/tiny-lru.cjs.js?");

/***/ }),

/***/ "../../../node_modules/toidentifier/index.js":
/*!***************************************************!*\
  !*** ../../../node_modules/toidentifier/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * toidentifier\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = toIdentifier\n\n/**\n * Trasform the given string into a JavaScript identifier\n *\n * @param {string} str\n * @returns {string}\n * @public\n */\n\nfunction toIdentifier (str) {\n  return str\n    .split(' ')\n    .map(function (token) {\n      return token.slice(0, 1).toUpperCase() + token.slice(1)\n    })\n    .join('')\n    .replace(/[^ _0-9a-z]/gi, '')\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/toidentifier/index.js?");

/***/ }),

/***/ "../../../node_modules/undici/index.js":
/*!*********************************************!*\
  !*** ../../../node_modules/undici/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Client = __webpack_require__(/*! ./lib/client */ \"../../../node_modules/undici/lib/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst Pool = __webpack_require__(/*! ./lib/pool */ \"../../../node_modules/undici/lib/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ \"../../../node_modules/undici/lib/balanced-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/agent */ \"../../../node_modules/undici/lib/agent.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"../../../node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"../../../node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"../../../node_modules/undici/lib/mock/mock-client.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"../../../node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"../../../node_modules/undici/lib/mock/mock-pool.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"../../../node_modules/undici/lib/mock/mock-errors.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ \"../../../node_modules/undici/lib/proxy-agent.js\")\n\nconst nodeVersion = process.versions.node.split('.')\nconst nodeMajor = Number(nodeVersion[0])\nconst nodeMinor = Number(nodeVersion[1])\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\n\nlet globalDispatcher = new Agent()\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  globalDispatcher = agent\n}\n\nfunction getGlobalDispatcher () {\n  return globalDispatcher\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      url = new URL(opts.path, util.parseOrigin(url))\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nif (nodeMajor > 16 || (nodeMajor === 16 && nodeMinor >= 5)) {\n  let fetchImpl = null\n  module.exports.fetch = async function fetch (resource, init) {\n    if (!fetchImpl) {\n      fetchImpl = __webpack_require__(/*! ./lib/fetch */ \"../../../node_modules/undici/lib/fetch/index.js\")\n    }\n    const dispatcher = getGlobalDispatcher()\n    return fetchImpl.call(dispatcher, resource, init)\n  }\n  module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ \"../../../node_modules/undici/lib/fetch/headers.js\").Headers\n  module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ \"../../../node_modules/undici/lib/fetch/response.js\").Response\n  module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ \"../../../node_modules/undici/lib/fetch/request.js\").Request\n  module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ \"../../../node_modules/undici/lib/fetch/formdata.js\").FormData\n  module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ \"../../../node_modules/undici/lib/fetch/file.js\").File\n}\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/index.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/agent.js":
/*!*************************************************!*\
  !*** ../../../node_modules/undici/lib/agent.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning } = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"../../../node_modules/undici/lib/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"../../../node_modules/undici/lib/client.js\")\nconst util = __webpack_require__(/*! ./core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst RedirectHandler = __webpack_require__(/*! ./handler/redirect */ \"../../../node_modules/undici/lib/handler/redirect.js\")\nconst { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ \"../../../node_modules/undici/lib/compat/dispatcher-weakref.js\")()\n\nconst kDestroyed = Symbol('destroyed')\nconst kClosed = Symbol('closed')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends Dispatcher {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n    this[kClosed] = false\n    this[kDestroyed] = false\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      let key\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin)\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const ref = this[kClients].get(key)\n\n      let dispatcher = ref ? ref.deref() : null\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions])\n          .on('drain', this[kOnDrain])\n          .on('connect', this[kOnConnect])\n          .on('disconnect', this[kOnDisconnect])\n          .on('connectionError', this[kOnConnectionError])\n\n        this[kClients].set(key, new WeakRef(dispatcher))\n        this[kFinalizer].register(dispatcher, key)\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      return dispatcher.dispatch(opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  close (callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises)\n    }\n\n    // Should never error.\n    Promise.all(closePromises).then(() => process.nextTick(callback))\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises)\n    }\n\n    // Should never error.\n    Promise.all(destroyPromises).then(() => process.nextTick(callback))\n  }\n}\n\nmodule.exports = Agent\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/agent.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/abort-signal.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/api/abort-signal.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort()\n  } else {\n    self.onError(new RequestAbortedError())\n  }\n}\n\nfunction addSignal (self, signal) {\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  if ('addEventListener' in self[kSignal]) {\n    self[kSignal].addEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].addListener('abort', self[kListener])\n  }\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/abort-signal.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/api-connect.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/api/api-connect.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"../../../node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/api-connect.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/api-pipeline.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/api/api-pipeline.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! stream */ \"stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"../../../node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body && body.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    assert(!res, 'pipeline cannot be retried')\n\n    if (ret.destroyed) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers: util.parseHeaders(headers),\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/api-pipeline.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/api-request.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/api/api-request.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Readable = __webpack_require__(/*! ./readable */ \"../../../node_modules/undici/lib/api/readable.js\")\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"../../../node_modules/undici/lib/api/abort-signal.js\")\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(headers)\n    const body = new Readable(resume, abort, parsedHeaders['content-type'])\n\n    this.callback = null\n    this.res = body\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: parsedHeaders,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/api-request.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/api-stream.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/undici/lib/api/api-stream.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { finished } = __webpack_require__(/*! stream */ \"stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"../../../node_modules/undici/lib/api/abort-signal.js\")\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    this.factory = null\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/api-stream.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/api-upgrade.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/api/api-upgrade.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"../../../node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/api-upgrade.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/index.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/undici/lib/api/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"../../../node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"../../../node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"../../../node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"../../../node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"../../../node_modules/undici/lib/api/api-connect.js\")\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/index.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/api/readable.js":
/*!********************************************************!*\
  !*** ../../../node_modules/undici/lib/api/readable.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\n\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\")\nconst { RequestAbortedError, NotSupportedError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor (resume, abort, contentType = '') {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      // Do nothing...\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob)\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/api/readable.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/balanced-pool.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/undici/lib/balanced-pool.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  BalancedPoolMissingUpstreamError\n} = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"../../../node_modules/undici/lib/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"../../../node_modules/undici/lib/pool.js\")\nconst { kUrl } = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\n\nconst kOptions = Symbol('options')\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], opts = {}) {\n    super()\n\n    this[kOptions] = opts\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n  }\n\n  addUpstream (upstream) {\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstream &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n\n    this[kAddClient](new Pool(upstream, Object.assign({}, this[kOptions])))\n\n    return this\n  }\n\n  removeUpstream (upstream) {\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstream &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    this[kClients].splice(this[kClients].indexOf(dispatcher), 1)\n    this[kClients].push(dispatcher)\n\n    return dispatcher\n  }\n}\n\nmodule.exports = BalancedPool\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/balanced-pool.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/client.js":
/*!**************************************************!*\
  !*** ../../../node_modules/undici/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst net = __webpack_require__(/*! net */ \"net\")\nconst util = __webpack_require__(/*! ./core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst Request = __webpack_require__(/*! ./core/request */ \"../../../node_modules/undici/lib/core/request.js\")\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst RedirectHandler = __webpack_require__(/*! ./handler/redirect */ \"../../../node_modules/undici/lib/handler/redirect.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  ClientDestroyedError,\n  ClientClosedError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"../../../node_modules/undici/lib/core/connect.js\")\n\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kClosed,\n  kDestroyed,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kOnDestroyed,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter\n} = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends Dispatcher {\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kClosed] = false\n    this[kDestroyed] = false\n    this[kServerName] = null\n    this[kOnDestroyed] = []\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  // TODO: Make private?\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  // TODO: Make private?\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections) {\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      const origin = opts.origin || this[kUrl].origin\n\n      const request = new Request(origin, opts, handler)\n\n      this[kQueue].push(request)\n      if (this[kResuming]) {\n        // Do nothing.\n      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n        // Wait a tick in case stream/iterator is ended in the same tick.\n        this[kResuming] = 1\n        process.nextTick(resume, this)\n      } else {\n        resume(this, true)\n      }\n\n      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n        this[kNeedDrain] = 2\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    this[kClosed] = true\n\n    if (!this[kSize]) {\n      this.destroy(callback)\n    } else {\n      this[kOnDestroyed].push(callback)\n    }\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    const requests = this[kQueue].splice(this[kPendingIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    if (!this[kSocket]) {\n      queueMicrotask(onDestroyed)\n    } else {\n      util.destroy(this[kSocket].on('close', onDestroyed), err)\n    }\n\n    resume(this)\n  }\n}\n\nconst constants = __webpack_require__(/*! ./llhttp/constants */ \"../../../node_modules/undici/lib/llhttp/constants.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const { resolve } = __webpack_require__(/*! path */ \"path\")\n  const { readFile } = (__webpack_require__(/*! fs */ \"fs\").promises)\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(await readFile(resolve(__dirname, './llhttp/llhttp_simd.wasm')))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(await readFile(resolve(__dirname, './llhttp/llhttp.wasm')))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n    // TODO: Emit warning?\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.trailer = ''\n    this.keepAlive = ''\n    this.contentLength = ''\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    // TODO (perf): Can we avoid this copy somehow?\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  finish () {\n    try {\n      try {\n        currentParser = this\n        this.llhttp.llhttp_finish(this.ptr) // TODO (fix): Check ret?\n      } finally {\n        currentParser = null\n      }\n    } catch (err) {\n      // TODO (fix): What if socket is already destroyed? Error will be swallowed.\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 7 && key.toString().toLowerCase() === 'trailer') {\n      this.trailer += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    // TODO: Check for content-length mismatch from server?\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    // TODO: More statusCode validation?\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* istanbul ignore if: this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT' && statusCode >= 200 && statusCode < 300) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, trailer, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.trailer = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    const trailers = trailer ? trailer.split(/,\\s*/) : []\n    for (let i = 0; i < trailers.length; i++) {\n      const trailer = trailers[i]\n      let found = false\n      for (let n = 0; n < headers.length; n += 2) {\n        const key = headers[n]\n        if (key.length === trailer.length && key.toString().toLowerCase() === trailer.toLowerCase()) {\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        util.destroy(socket, new TrailerMismatchError())\n        return -1\n      }\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      // TODO: What if running > 0?\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting]) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client[kDestroyed]) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client[kDestroyed]) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosed] && !client[kSize]) {\n      client.destroy(util.nop)\n      continue\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  // TODO: Expect: 100-continue\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (host) {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    // TODO (fix): Avoid using err.message for logic.\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // TODO (fix): What if socket errors while waiting for body?\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // TODO: What if not ended and bytesWritten === contentLength?\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n    request.onBodySent(chunk)\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    // TODO (fix): Add comment clarifying what this does?\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/client.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore file: only for Node 12 */\n\nconst { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\n\nclass CompatWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value[kConnected] === 0 && this.value[kSize] === 0\n      ? undefined\n      : this.value\n  }\n}\n\nclass CompatFinalizer {\n  constructor (finalizer) {\n    this.finalizer = finalizer\n  }\n\n  register (dispatcher, key) {\n    dispatcher.on('disconnect', () => {\n      if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n        this.finalizer(key)\n      }\n    })\n  }\n}\n\nmodule.exports = function () {\n  return {\n    WeakRef: global.WeakRef || CompatWeakRef,\n    FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/compat/dispatcher-weakref.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/core/connect.js":
/*!********************************************************!*\
  !*** ../../../node_modules/undici/lib/core/connect.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst net = __webpack_require__(/*! net */ \"net\")\nconst tls = __webpack_require__(/*! tls */ \"tls\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst util = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const timeoutId = timeout\n      ? setTimeout(onConnectTimeout, timeout, socket)\n      : null\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/core/connect.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/core/errors.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/undici/lib/core/errors.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass AbortError extends Error {\n  constructor () {\n    super('The operation was aborted')\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ConnectTimeoutError)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersTimeoutError)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersOverflowError)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, BodyTimeoutError)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidArgumentError)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidReturnValueError)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass RequestAbortedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestAbortedError)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InformationalError)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestContentLengthMismatchError)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ResponseContentLengthMismatchError)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass TrailerMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, TrailerMismatchError)\n    this.name = 'TrailerMismatchError'\n    this.message = message || 'Trailers does not match trailer header'\n    this.code = 'UND_ERR_TRAILER_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientDestroyedError)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientClosedError)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    Error.captureStackTrace(this, SocketError)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    Error.captureStackTrace(this, HTTPParserError)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/core/errors.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/core/request.js":
/*!********************************************************!*\
  !*** ../../../node_modules/undici/lib/core/request.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst kHandler = Symbol('handler')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\n  channels.create = diagnosticsChannel.channel('undici:request:create')\n  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent')\n  channels.headers = diagnosticsChannel.channel('undici:request:headers')\n  channels.trailers = diagnosticsChannel.channel('undici:request:trailers')\n  channels.error = diagnosticsChannel.channel('undici:request:error')\n} catch {\n  channels.create = { hasSubscribers: false }\n  channels.bodySent = { hasSubscribers: false }\n  channels.headers = { hasSubscribers: false }\n  channels.trailers = { hasSubscribers: false }\n  channels.error = { hasSubscribers: false }\n}\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (path[0] !== '/' && !(path.startsWith('http://') || path.startsWith('https://'))) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.method = method\n\n    if (body == null) {\n      this.body = null\n    } else if (util.isStream(body)) {\n      this.body = body\n    } else if (body instanceof DataView) {\n      // TODO: Why is DataView special?\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer) : null\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (util.isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (util.isIterable(body) || util.isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = ''\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(this, key, headers[key])\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    if (util.isBlobLike(body) && this.contentType == null && body.type) {\n      this.contentType = body.type\n      this.headers += `content-type: ${body.type}\\r\\n`\n    }\n\n    util.validateHandler(handler, method, upgrade)\n\n    this.servername = util.getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.onError(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onConnect(abort)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onData(chunk)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n    return this[kHandler].onComplete(trailers)\n  }\n\n  onError (error) {\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n    return this[kHandler].onError(error)\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  if (\n    request.host === null &&\n    key.length === 4 &&\n    key.toLowerCase() === 'host'\n  ) {\n    // Consumed by Client\n    request.host = val\n  } else if (\n    request.contentLength === null &&\n    key.length === 14 &&\n    key.toLowerCase() === 'content-length'\n  ) {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (\n    request.contentType === null &&\n    key.length === 12 &&\n    key.toLowerCase() === 'content-type'\n  ) {\n    request.contentType = val\n    request.headers += `${key}: ${val}\\r\\n`\n  } else if (\n    key.length === 17 &&\n    key.toLowerCase() === 'transfer-encoding'\n  ) {\n    throw new InvalidArgumentError('invalid transfer-encoding header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'connection'\n  ) {\n    throw new InvalidArgumentError('invalid connection header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'keep-alive'\n  ) {\n    throw new InvalidArgumentError('invalid keep-alive header')\n  } else if (\n    key.length === 7 &&\n    key.toLowerCase() === 'upgrade'\n  ) {\n    throw new InvalidArgumentError('invalid upgrade header')\n  } else if (\n    key.length === 6 &&\n    key.toLowerCase() === 'expect'\n  ) {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers += `${key}: ${val}\\r\\n`\n  }\n}\n\nmodule.exports = Request\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/core/request.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/core/symbols.js":
/*!********************************************************!*\
  !*** ../../../node_modules/undici/lib/core/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = {\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kHeadersList: Symbol('headers list'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol('destroyed'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelinig'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter')\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/core/symbols.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/core/util.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/undici/lib/core/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! http */ \"http\")\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst net = __webpack_require__(/*! net */ \"net\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\nconst nodeUtil = __webpack_require__(/*! util */ \"util\")\n\nfunction nop () {}\n\nfunction isStream (obj) {\n  return obj && typeof obj.pipe === 'function'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  return (Blob && object instanceof Blob) || (\n    object &&\n    typeof object === 'object' &&\n    (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n    /^(Blob|File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {\n    throw new InvalidArgumentError('invalid port')\n  }\n\n  if (url.path != null && typeof url.path !== 'string') {\n    throw new InvalidArgumentError('invalid path')\n  }\n\n  if (url.pathname != null && typeof url.pathname !== 'string') {\n    throw new InvalidArgumentError('invalid pathname')\n  }\n\n  if (url.hostname != null && typeof url.hostname !== 'string') {\n    throw new InvalidArgumentError('invalid hostname')\n  }\n\n  if (url.origin != null && typeof url.origin !== 'string') {\n    throw new InvalidArgumentError('invalid origin')\n  }\n\n  if (!/^https?:/.test(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('invalid protocol')\n  }\n\n  if (!(url instanceof URL)) {\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    const origin = url.origin != null\n      ? url.origin\n      : `${url.protocol}//${url.hostname}:${port}`\n    const path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    url = new URL(path, origin)\n  }\n\n  return url\n}\n\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substr(1, idx - 1)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substr(0, idx)\n}\n\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert.strictEqual(typeof host, 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\nfunction isDestroyed (stream) {\n  return !stream || !!(stream.destroyed || stream[kDestroyed])\n}\n\nfunction isReadableAborted (stream) {\n  const state = stream && stream._readableState\n  return isDestroyed(stream) && state && !state.endEmitted\n}\n\nfunction destroy (stream, err) {\n  if (!isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n    stream.destroy(err)\n  } else if (err) {\n    process.nextTick((stream, err) => {\n      stream.emit('error', err)\n    }, stream, err)\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\nfunction parseHeaders (headers, obj = {}) {\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headers[i].toString().toLowerCase()\n    let val = obj[key]\n    if (!val) {\n      obj[key] = headers[i + 1].toString()\n    } else {\n      if (!Array.isArray(val)) {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString())\n    }\n  }\n  return obj\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction validateHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed (body) {\n  return !!(body && (\n    stream.isDisturbed\n      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n      : body[kBodyUsed] ||\n        body.readableDidRead ||\n        (body._readableState && body._readableState.dataEmitted) ||\n        isReadableAborted(body)\n  ))\n}\n\nfunction isErrored (body) {\n  return !!(body && (\n    stream.isErrored\n      ? stream.isErrored(body)\n      : /state: 'errored'/.test(nodeUtil.inspect(body)\n  )))\n}\n\nfunction isReadable (body) {\n  return !!(body && (\n    stream.isReadable\n      ? stream.isReadable(body)\n      : /state: 'readable'/.test(nodeUtil.inspect(body)\n  )))\n}\n\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\nlet ReadableStream\nfunction ReadableStreamFrom (iterable) {\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  if (ReadableStream.from) {\n    // https://github.com/whatwg/streams/pull/1083\n    return ReadableStream.from(iterable)\n  }\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          controller.enqueue(new Uint8Array(buf))\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    },\n    0\n  )\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nmodule.exports = {\n  kEnumerableProperty,\n  nop,\n  isDisturbed,\n  isErrored,\n  isReadable,\n  toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),\n  isReadableAborted,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  validateHandler,\n  getSocketInfo\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/core/util.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/dispatcher.js":
/*!******************************************************!*\
  !*** ../../../node_modules/undici/lib/dispatcher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\")\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n}\n\nmodule.exports = Dispatcher\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/dispatcher.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/body.js":
/*!******************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/body.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/fetch/util.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"../../../node_modules/undici/lib/fetch/formdata.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst nodeUtil = __webpack_require__(/*! util */ \"util\")\nconst { NotSupportedError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst { isErrored } = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  if (blob.stream) {\n    yield * blob.stream()\n  } else {\n    // istanbul ignore next: node < 16.7\n    yield await blob.arrayBuffer()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {\n    // BufferSource\n\n    if (object instanceof DataView) {\n      // TODO: Blob doesn't seem to work with DataView?\n      object = object.buffer\n    }\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object)\n  } else if (object instanceof FormData) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed')\n    // istanbul ignore next\n    assert(!object.locked, 'locked')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nconst methods = {\n  async blob () {\n    const chunks = []\n\n    if (this[kState].body) {\n      const stream = this[kState].body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('disturbed')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('locked')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      for await (const chunk of stream) {\n        chunks.push(chunk)\n      }\n    }\n\n    return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n  },\n\n  async arrayBuffer () {\n    const blob = await this.blob()\n    return await blob.arrayBuffer()\n  },\n\n  async text () {\n    const blob = await this.blob()\n    return toUSVString(await blob.text())\n  },\n\n  async json () {\n    return JSON.parse(await this.text())\n  },\n\n  async formData () {\n    const contentType = this.headers.get('Content-Type')\n\n    // If mimeType’s essence is \"multipart/form-data\", then:\n    if (/multipart\\/form-data/.test(contentType)) {\n      throw new NotSupportedError('multipart/form-data not supported')\n    } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n      // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n      // 1. Let entries be the result of parsing bytes.\n      let entries\n      try {\n        entries = new URLSearchParams(await this.text())\n      } catch (err) {\n        // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n        // 2. If entries is failure, then throw a TypeError.\n        throw Object.assign(new TypeError(), { cause: err })\n      }\n\n      // 3. Return a new FormData object whose entries are entries.\n      const formData = new FormData()\n      for (const [name, value] of entries) {\n        formData.append(name, value)\n      }\n      return formData\n    } else {\n      // Otherwise, throw a TypeError.\n      throw new TypeError()\n    }\n  }\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      return this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype, methods)\n  Object.defineProperties(prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/body.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/constants.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/constants.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst forbiddenHeaderNames = [\n  'accept-charset',\n  'accept-encoding',\n  'access-control-request-headers',\n  'access-control-request-method',\n  'connection',\n  'content-length',\n  'cookie',\n  'cookie2',\n  'date',\n  'dnt',\n  'expect',\n  'host',\n  'keep-alive',\n  'origin',\n  'referer',\n  'te',\n  'trailer',\n  'transfer-encoding',\n  'upgrade',\n  'via'\n]\n\nconst corsSafeListedMethods = ['GET', 'HEAD', 'POST']\n\nconst nullBodyStatus = [101, 204, 205, 304]\n\nconst redirectStatus = [301, 302, 303, 307, 308]\n\nconst referrerPolicy = [\n  '',\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n]\n\nconst requestRedirect = ['follow', 'manual', 'error']\n\nconst safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']\n\nconst requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']\n\nconst requestCredentials = ['omit', 'same-origin', 'include']\n\nconst requestCache = [\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n]\n\n// https://fetch.spec.whatwg.org/#forbidden-response-header-name\nconst forbiddenResponseHeaderNames = ['set-cookie', 'set-cookie2']\n\nconst requestBodyHeader = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type'\n]\n\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']\n\nconst subresource = [\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n]\n\nmodule.exports = {\n  subresource,\n  forbiddenResponseHeaderNames,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  forbiddenHeaderNames,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/constants.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/file.js":
/*!******************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/file.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\n\nclass File extends Blob {\n  constructor (fileBits, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    super(fileBits, { type: t })\n    this[kState] = {\n      name: n,\n      lastModified: d\n    }\n  }\n\n  get name () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n}\n\nclass FileLike {\n  constructor (blobLike, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    this[kState] = {\n      blobLike,\n      name: n,\n      type: t,\n      lastModified: d\n    }\n  }\n\n  stream (...args) {\n    return this[kState].blobLike.stream(...args)\n  }\n\n  arrayBuffer (...args) {\n    return this[kState].blobLike.arrayBuffer(...args)\n  }\n\n  slice (...args) {\n    return this[kState].blobLike.slice(...args)\n  }\n\n  text (...args) {\n    return this[kState].blobLike.text(...args)\n  }\n\n  get size () {\n    return this[kState].blobLike.size\n  }\n\n  get type () {\n    return this[kState].blobLike.type\n  }\n\n  get name () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n}\n\nmodule.exports = { File: globalThis.File ?? File, FileLike }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/file.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/formdata.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/formdata.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isBlobLike, isFileLike, toUSVString } = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/fetch/util.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { File, FileLike } = __webpack_require__(/*! ./file */ \"../../../node_modules/undici/lib/fetch/file.js\")\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\n\nclass FormData {\n  constructor (...args) {\n    if (args.length > 0 && !(args[0]?.constructor?.name === 'HTMLFormElement')) {\n      throw new TypeError(\n        \"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'\"\n      )\n    }\n\n    this[kState] = []\n  }\n\n  append (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    const next = []\n    for (const entry of this[kState]) {\n      if (entry.name !== name) {\n        next.push(entry)\n      }\n    }\n\n    this[kState] = next\n  }\n\n  get (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  * entries () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const pair of this) {\n      yield pair\n    }\n  }\n\n  * keys () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [key] of this) {\n      yield key\n    }\n  }\n\n  * values () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [, value] of this) {\n      yield value\n    }\n  }\n\n  * [Symbol.iterator] () {\n    // The value pairs to iterate over are this’s entry list’s entries with\n    // the key being the name and the value being the value.\n    for (const { name, value } of this[kState]) {\n      yield [name, value]\n    }\n  }\n}\n\nfunction makeEntry (name, value, filename) {\n  // To create an entry for name, value, and optionally a filename, run these\n  // steps:\n\n  // 1. Let entry be a new entry.\n  const entry = {\n    name: null,\n    value: null\n  }\n\n  // 2. Set entry’s name to name.\n  entry.name = name\n\n  // 3. If value is a Blob object and not a File object, then set value to a new File\n  // object, representing the same bytes, whose name attribute value is \"blob\".\n  if (isBlobLike(value) && !isFileLike(value)) {\n    value = value instanceof Blob\n      ? new File([value], 'blob')\n      : new FileLike(value, 'blob')\n  }\n\n  // 4. If value is (now) a File object and filename is given, then set value to a\n  // new File object, representing the same bytes, whose name attribute value is\n  // filename.\n  // TODO: This is a bit weird... What if passed value is a File?\n  // Do we just override the name attribute? Since it says \"if value is (now)\"\n  // does that mean that this lives inside the previous condition? In which case\n  // creating one more File instance doesn't make much sense....\n  if (isFileLike(value) && filename != null) {\n    value = value instanceof File\n      ? new File([value], filename)\n      : new FileLike(value, filename)\n  }\n\n  // 5. Set entry’s value to value.\n  entry.value = value\n\n  // 6. Return entry.\n  return entry\n}\n\nmodule.exports = { FormData: globalThis.FormData ?? FormData }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/formdata.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/headers.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/headers.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { validateHeaderName, validateHeaderValue } = __webpack_require__(/*! http */ \"http\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst { kGuard } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/undici/lib/fetch/constants.js\")\n\nfunction binarySearch (arr, val) {\n  let low = 0\n  let high = Math.floor(arr.length / 2)\n\n  while (high > low) {\n    const mid = (high + low) >>> 1\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n\n  return low * 2\n}\n\nfunction normalizeAndValidateHeaderName (name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`)\n  }\n  const normalizedHeaderName = name.toLocaleLowerCase()\n  validateHeaderName(normalizedHeaderName)\n  return normalizedHeaderName\n}\n\nfunction normalizeAndValidateHeaderValue (name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name)\n  }\n  const normalizedHeaderValue = `${value}`.replace(\n    /^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g,\n    ''\n  )\n  validateHeaderValue(name, normalizedHeaderValue)\n  return normalizedHeaderValue\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header]\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError()\n      }\n\n      // 2. Append header’s first item/header’s second item to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1])\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError()\n  }\n}\n\n// TODO: Composition over inheritence? Or helper methods?\nclass HeadersList extends Array {\n  append (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n\n  delete (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2)\n    }\n  }\n\n  get (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      return this[index + 1]\n    }\n\n    return null\n  }\n\n  has (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    return this[index] === normalizedName\n  }\n\n  set (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n}\n\nclass Headers {\n  constructor (...args) {\n    if (\n      args[0] !== undefined &&\n      !(typeof args[0] === 'object' && args[0] != null) &&\n      !Array.isArray(args[0])\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\"\n      )\n    }\n    const init = args.length >= 1 ? args[0] ?? {} : {}\n\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    fill(this, init)\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  toString () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return Object.prototype.toString.call(this)\n  }\n\n  append (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].append(String(args[0]), String(args[1]))\n  }\n\n  delete (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].delete(String(args[0]))\n  }\n\n  get (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].get(String(args[0]))\n  }\n\n  has (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].has(String(args[0]))\n  }\n\n  set (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].set(String(args[0]), String(args[1]))\n  }\n\n  * keys () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * values () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * entries () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]]\n    }\n  }\n\n  forEach (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (typeof args[0] !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n    const callback = args[0]\n    const thisArg = args[1]\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(\n        thisArg,\n        this[kHeadersList][index + 1],\n        this[kHeadersList][index],\n        this\n      )\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n})\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/headers.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  Response,\n  makeNetworkError,\n  filterResponse,\n  makeResponse\n} = __webpack_require__(/*! ./response */ \"../../../node_modules/undici/lib/fetch/response.js\")\nconst { Headers } = __webpack_require__(/*! ./headers */ \"../../../node_modules/undici/lib/fetch/headers.js\")\nconst { Request, makeRequest } = __webpack_require__(/*! ./request */ \"../../../node_modules/undici/lib/fetch/request.js\")\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\")\nconst {\n  ServiceWorkerGlobalScope,\n  Window,\n  matchRequestIntegrity,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  sameOrigin\n} = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/fetch/util.js\")\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { AbortError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { safelyExtractBody } = __webpack_require__(/*! ./body */ \"../../../node_modules/undici/lib/fetch/body.js\")\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/undici/lib/fetch/constants.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst { PassThrough, pipeline } = __webpack_require__(/*! stream */ \"stream\")\nconst { isErrored, isReadable } = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { kIsMockActive } = __webpack_require__(/*! ../mock/mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\n\nlet ReadableStream\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.terminated = null\n    this.connection = null\n    this.dump = false\n  }\n\n  terminate ({ reason, aborted } = {}) {\n    if (this.terminated) {\n      return\n    }\n    this.terminated = { aborted, reason }\n\n    this.connection?.destroy(reason)\n\n    this.emit('terminated', reason)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nasync function fetch (...args) {\n  if (args.length < 1) {\n    throw new TypeError(\n      `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${args.length} present.`\n    )\n  }\n  if (\n    args.length >= 1 &&\n    typeof args[1] !== 'object' &&\n    args[1] !== undefined\n  ) {\n    throw new TypeError(\n      \"Failed to execute 'fetch' on 'Window': cannot convert to dictionary.\"\n    )\n  }\n\n  const resource = args[0]\n  const init = args.length >= 1 ? args[1] ?? {} : {}\n\n  const context = new Fetch(this)\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  const requestObject = new Request(resource, init)\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch.call(context, p, request, null)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  // TODO: What if request.client is null?\n  const globalObject = request.client?.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject instanceof ServiceWorkerGlobalScope) {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Add the following abort steps to requestObject’s signal:\n  requestObject.signal.addEventListener(\n    'abort',\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Abort fetch with p, request, and responseObject.\n      abortFetch.call(context, p, request, responseObject)\n\n      // 3. Terminate the ongoing fetch with the aborted flag set.\n      context.terminate({ aborted: true })\n    },\n    { once: true }\n  )\n\n  // 11. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 12. Fetch request with processResponseEndOfBody set to handleFetchDone,\n  // and processResponse given response being these substeps:\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n    if (response.aborted) {\n      abortFetch.call(context, p, request, responseObject)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  fetching\n    .call(context, {\n      request,\n      processResponseEndOfBody: handleFetchDone,\n      processResponse\n    })\n    .catch((err) => {\n      p.reject(err)\n    })\n\n  // 13. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  response.timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming () {\n  // TODO\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new AbortError()\n\n  // 2. Reject promise with error.\n  p.reject(error)\n\n  // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 4. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 5. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject instanceof Window\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 11. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 12. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 13. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 14. If request is a subresource request, then:\n  if (subresource.includes(request.destination)) {\n    // 1. Let record be a new fetch record consisting of request and this\n    // instance of the fetch algorithm.\n    // TODO\n    // 2. Append record to request’s client’s fetch group list of fetch\n    // records.\n    // TODO\n  }\n\n  // 15. Run main fetch given fetchParams.\n  return mainFetch.call(this, fetchParams)\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (\n    request.localURLsOnly &&\n    !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)\n  ) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      // - request’s current URL’s origin is same origin with request’s origin,\n      // and request’s response tainting is \"basic\"\n      // - request’s current URL’s scheme is \"data\"\n      // - request’s mode is \"navigate\" or \"websocket\"\n      //    1. Set request’s response tainting to \"basic\".\n      //    2. Return the result of running scheme fetch given fetchParams.\n      // TODO\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect cmode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Let noCorsResponse be the result of running scheme fetch given\n        // fetchParams.\n        // TODO\n\n        // 4. If noCorsResponse is a filtered response or the CORB check with\n        // request and noCorsResponse returns allowed, then return noCorsResponse.\n        // TODO\n\n        // 5. Return a new response whose status is noCorsResponse’s status.\n        // TODO\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch\n        .call(this, fetchParams)\n        .catch((err) => makeNetworkError(err))\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.has('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    context.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale.call(context, fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!matchRequestIntegrity(request, bytes)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale.call(context, fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    try {\n      processBody(await response.arrayBuffer())\n    } catch (err) {\n      processBodyError(err)\n    }\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale.call(context, fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    fetchParams.processResponseDone(response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  const context = this\n\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  // TODO\n\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    fetchParams.processResponse(response)\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  // TODO\n\n  // 5. If response’s body is null, then run processResponseEndOfBody.\n  // TODO\n\n  // 6. Otherwise:\n  // TODO\n\n  // 7. If fetchParams’s process response consume body is non-null, then:\n  // TODO\n\n  // TODO: This is a workaround. Until the above has been implemented, i.e.\n  // we need to either fully consume the body or terminate the fetch.\n  if (response.type === 'error') {\n    context.terminate({ reason: response.error })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams\n    )\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    context.connection.destroy()\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError()\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      response = filterResponse(actualResponse, 'opaqueredirect')\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch.call(this, fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nasync function httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err)\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n  }\n\n  // 7. If request’s redirect count is twenty, return a network error.\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded')\n  }\n\n  // 8. Increase request’s redirect count by one.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"')\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    )\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return makeNetworkError()\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !['GET', 'HEADER'].includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 14. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 17. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 19. Return the result of running main fetch given fetchParams and true.\n  return mainFetch.call(this, fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    10 .If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href)\n  }\n\n  //    11. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    12. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    13. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici')\n  }\n\n  //    14. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.has('if-modified-since') ||\n      httpRequest.headersList.has('if-none-match') ||\n      httpRequest.headersList.has('if-unmodified-since') ||\n      httpRequest.headersList.has('if-match') ||\n      httpRequest.headersList.has('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    15. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.has('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    17. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    18. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  //    19. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    20. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    21. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    22. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    23. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then:\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch.call(\n      this,\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethods.includes(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 14. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 15. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    context.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 16. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 17. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nfunction httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  const context = this\n\n  return new Promise((resolve) => {\n    assert(!context.connection || context.connection.destroyed)\n\n    context.connection = {\n      abort: null,\n      destroyed: false,\n      destroy (err) {\n        if (!this.destroyed) {\n          this.destroyed = true\n          this.abort?.(err ?? new AbortError())\n        }\n      }\n    }\n\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request\n\n    // 2. Let response be null.\n    let response = null\n\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo\n\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null\n\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) {\n      request.cache = 'no-store'\n    }\n\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n\n    // 7. Switch on request’s mode:\n    if (request.mode === 'websocket') {\n      // Let connection be the result of obtaining a WebSocket connection,\n      // given request’s current URL.\n      // TODO\n    } else {\n      // Let connection be the result of obtaining a connection, given\n      // networkPartitionKey, request’s current URL’s origin,\n      // includeCredentials, and forceNewConnection.\n      // TODO\n    }\n\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO: When do we cleanup this listener?\n    context.on('terminated', onRequestAborted)\n\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n\n    //    Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //    [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n    //    If request’s body is non-null, and request’s body’s source is null,\n    //    then the user agent may have a buffer of up to 64 kibibytes and store\n    //    a part of request’s body in that buffer. If the user agent reads from\n    //    request’s body beyond that buffer’s size and the user agent needs to\n    //    resend request, then instead return a network error.\n    //    TODO\n\n    //    Set timingInfo’s final network-response start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated capability,\n    //    immediately after the user agent’s HTTP parser receives the first byte\n    //    of the response (e.g., frame header bytes for HTTP/2 or response status\n    //    line for HTTP/1.x).\n    //    TODO\n\n    //    Wait until all the headers are transmitted.\n\n    //    Any responses whose status is in the range 100 to 199, inclusive,\n    //    and is not 101, are to be ignored, except for the purposes of setting\n    //    timingInfo’s final network-response start time above.\n\n    //    If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n\n    //    If the HTTP request results in a TLS client certificate dialog, then:\n\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n\n    //        2. Otherwise, return a network error.\n\n    // To transmit request’s body body, run these steps:\n    const body = (async function * () {\n      try {\n        // 1. If body is null and fetchParams’s process request end-of-body is\n        // non-null, then queue a fetch task given fetchParams’s process request\n        // end-of-body and fetchParams’s task destination.\n        if (request.body === null) {\n          fetchParams.processEndOfBody?.()\n          return\n        }\n\n        // 2. Otherwise, if body is non-null:\n\n        //    1. Let processBodyChunk given bytes be these steps:\n        for await (const bytes of request.body.stream) {\n          // 1. If the ongoing fetch is terminated, then abort these steps.\n          if (context.terminated) {\n            return\n          }\n\n          // 2. Run this step in parallel: transmit bytes.\n          yield bytes\n\n          // 3. If fetchParams’s process request body is non-null, then run\n          // fetchParams’s process request body given bytes’s length.\n          fetchParams.processRequestBody?.(bytes.byteLength)\n        }\n\n        // 2. Let processEndOfBody be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If fetchParams’s process request end-of-body is non-null,\n        //    then run fetchParams’s process request end-of-body.\n        fetchParams.processRequestEndOfBody?.()\n      } catch (e) {\n        // 3. Let processBodyError given e be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If e is an \"AbortError\" DOMException, then terminate the ongoing fetch with the aborted flag set.\n        //    3. Otherwise, terminate the ongoing fetch.\n        context.terminate({\n          aborted: e.name === 'AbortError',\n          reason: e\n        })\n      }\n    })()\n\n    // 9. If aborted, then:\n    function onRequestAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      this.connection.destroy()\n\n      // 3. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return resolve(makeNetworkError(new AbortError()))\n      }\n\n      // 4. Return a network error.\n      return resolve(makeNetworkError(this.terminated.reason))\n    }\n\n    // 10. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    let pullAlgorithm\n\n    // 11. Let cancelAlgorithm be an action that terminates the ongoing\n    // fetch with the aborted flag set.\n    const cancelAlgorithm = () => {\n      context.terminate({ aborted: true })\n    }\n\n    // 12. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    const highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n\n    // 13. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n\n    // 14. Let stream be a new ReadableStream.\n    // 15. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n      ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n    }\n\n    let pullResolve\n\n    const stream = new ReadableStream(\n      {\n        async start (controller) {\n          context.controller = controller\n        },\n        async pull (controller) {\n          if (!pullAlgorithm) {\n            await new Promise((resolve) => {\n              pullResolve = resolve\n            })\n          }\n          await pullAlgorithm(controller)\n        },\n        async cancel (reason) {\n          await cancelAlgorithm(reason)\n        }\n      },\n      { highWaterMark }\n    )\n\n    // 16. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO\n\n    // 17. If aborted, then:\n    // TODO: How can this happen? The steps above are not async?\n\n    // 18. Run these steps in parallel:\n    //    1. Run these steps, but abort when the ongoing fetch is terminated:\n    //        1. While true:\n    //            1. If one or more bytes have been transmitted from response’s\n    //            message body, then:\n    //            NOTE: See onHeaders\n    //            2. Otherwise, if the bytes transmission for response’s message\n    //            body is done normally and stream is readable, then close stream,\n    //            finalize response for fetchParams and response, and abort these\n    //            in-parallel steps.\n    //            NOTE: See onHeaders\n\n    //    2. If aborted, then:\n    function onResponseAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If aborted is set, then:\n      if (aborted) {\n        // 1. Set response’s aborted flag.\n        response.aborted = true\n\n        // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n        if (isReadable(stream)) {\n          this.controller.error(new AbortError())\n        }\n      } else {\n        // 3. Otherwise, if stream is readable, error stream with a TypeError.\n        if (isReadable(stream)) {\n          this.controller.error(new TypeError('terminated'))\n        }\n      }\n\n      // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n      this.connection.destroy()\n    }\n\n    // 19. Return response.\n    // NOTE: See onHeaders\n\n    // Implementation\n    const url = requestCurrentURL(request)\n    context.dispatcher.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: context.dispatcher[kIsMockActive] ? request.body && request.body.source : body,\n        headers: request.headersList,\n        maxRedirections: 0\n      },\n      {\n        decoder: null,\n        abort: null,\n        context,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = this.context\n\n          if (connection.destroyed) {\n            abort(new AbortError())\n          } else {\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          const headers = new Headers()\n          for (let n = 0; n < headersList.length; n += 2) {\n            headers.append(\n              headersList[n + 0].toString(),\n              headersList[n + 1].toString()\n            )\n          }\n\n          response = makeResponse({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: { stream }\n          })\n\n          this.context.on('terminated', onResponseAborted)\n\n          const codings =\n            headers\n              .get('content-encoding')\n              ?.toLowerCase()\n              .split(',')\n              .map((x) => x.trim()) ?? []\n\n          const decoders = []\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          for (const coding of codings) {\n            if (/(x-)?gzip/.test(coding)) {\n              decoders.push(zlib.createGunzip())\n            } else if (/(x-)?deflate/.test(coding)) {\n              decoders.push(zlib.createInflate())\n            } else if (coding === 'br') {\n              decoders.push(zlib.createBrotliDecompress())\n            } else {\n              decoders.length = 0\n              break\n            }\n          }\n\n          if (decoders.length > 1) {\n            pipeline(...decoders, () => {})\n          } else if (decoders.length === 0) {\n            // TODO (perf): Avoid intermediate.\n            decoders.push(new PassThrough())\n          }\n\n          this.decoder = decoders[0].on('drain', resume)\n\n          const iterator = decoders[decoders.length - 1][Symbol.asyncIterator]()\n\n          pullAlgorithm = async (controller) => {\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes\n            try {\n              const { done, value } = await iterator.next()\n              bytes = done ? undefined : value\n            } catch (err) {\n              if (this.decoder.writableEnded && !timingInfo.encodedBodySize) {\n                // zlib doesn't like empty streams.\n                bytes = undefined\n              } else {\n                bytes = err\n              }\n            }\n\n            if (bytes === undefined) {\n              // 2. Otherwise, if the bytes transmission for response’s message\n              // body is done normally and stream is readable, then close\n              // stream, finalize response for fetchParams and response, and\n              // abort these in-parallel steps.\n              finalizeResponse(fetchParams, response)\n\n              controller.close()\n\n              return\n            }\n\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n            // 6. If bytes is failure, then terminate the ongoing fetch.\n            if (bytes instanceof Error) {\n              this.context.terminate({ reason: bytes })\n              return\n            }\n\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            controller.enqueue(new Uint8Array(bytes))\n\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n              this.context.terminate()\n              return\n            }\n\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            return controller.desiredSize > 0\n          }\n\n          if (pullResolve) {\n            pullResolve()\n            pullResolve = null\n          }\n\n          resolve(response)\n\n          return true\n        },\n\n        onData (chunk) {\n          if (this.context.dump) {\n            return\n          }\n\n          //  1. If one or more bytes have been transmitted from response’s\n          //  message body, then:\n\n          // 1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          // 2. Let codings be the result of extracting header list values\n          // given `Content-Encoding` and response’s header list.\n          // See pullAlgorithm.\n\n          // 3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          // 4. See pullAlgorithm...\n\n          return this.decoder.write(bytes)\n        },\n\n        onComplete () {\n          this.decoder.end()\n        },\n\n        onError (error) {\n          this.decoder?.destroy(error)\n\n          this.context.terminate({ reason: error })\n\n          if (!response) {\n            resolve(makeNetworkError(error))\n          }\n        }\n      }\n    )\n  })\n}\n\nmodule.exports = fetch\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/index.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/request.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/request.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"../../../node_modules/undici/lib/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ \"../../../node_modules/undici/lib/fetch/headers.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/fetch/util.js\")\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/undici/lib/fetch/constants.js\")\nconst { kEnumerableProperty } = util\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nlet TransformStream\n\nconst kInit = Symbol('init')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (...args) {\n    if (args[0] === kInit) {\n      return\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to construct 'Request': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n    const input = args[0] instanceof Request ? args[0] : toUSVString(args[0])\n    const init = args.length >= 1 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = this[kRealm].settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input)\n        error.cause = err\n        throw error\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = this[kRealm].settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window instanceof EnvironmentSettingsObject &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if ('window' in init && window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method. \n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set. \n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: request.client,\n      // window window.\n      window,\n      // priority request’s priority. \n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different \n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer, \n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode, \n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect, \n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      // undici implementation note: urlList is cloned in makeRequest\n      urlList: request.urlList\n    })\n\n    // 13. If init is not empty, then:\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if ('referrer' in init) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          const error = new TypeError(\n            `Referrer \"${referrer}\" is not a valid URL.`\n          )\n          error.cause = err\n          throw error\n        }\n\n        // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n        request.referrer = parsedReferrer\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if ('referrerPolicy' in init) {\n      request.referrerPolicy = init.referrerPolicy\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n        )\n      }\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if ('mode' in init) {\n      mode = init.mode\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`\n        )\n      }\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw new TypeError()\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if ('credentials' in init) {\n      request.credentials = init.credentials\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`\n        )\n      }\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if ('cache' in init) {\n      request.cache = init.cache\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`\n        )\n      }\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if ('redirect' in init) {\n      request.redirect = init.redirect\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`\n        )\n      }\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if ('integrity' in init) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if ('keepalive' in init) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if ('method' in init) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`)\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`)\n      }\n\n      // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n      method = init.method.toUpperCase()\n\n      // 4. Set request’s method to method.\n      request.method = method\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if ('signal' in init) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n    this[kSignal][kRealm] = this[kRealm]\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort()\n      } else {\n        const abort = () => ac.abort()\n        signal.addEventListener('abort', abort, { once: true })\n        requestFinalizer.register(this, { signal, abort })\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'request'\n    this[kHeaders][kHeadersList] = request.headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      this[kHeaders][kGuard] = 'request-no-cors'\n    }\n\n    // 32. If init is not empty, then:\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers)\n\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      if ('headers' in init) {\n        headers = init.headers\n      }\n\n      // 3. Empty this’s headers’s header list.\n      this[kState].headersList = new HeadersList()\n      this[kHeaders][kHeadersList] = this[kState].headersList\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList])\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (('body' in init && init.body != null) || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if ('body' in init && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 2. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      if (!TransformStream) {\n        TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream)\n      }\n\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return this[kState].url.toString()\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n  get isHistoryNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  // Returns a clone of request.\n  clone () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    const clonedRequestObject = new Request(kInit)\n    clonedRequestObject[kState] = clonedRequest\n    clonedRequestObject[kRealm] = this[kRealm]\n    clonedRequestObject[kHeaders] = new Headers()\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort()\n    } else {\n      this.signal.addEventListener(\n        'abort',\n        function () {\n          ac.abort()\n        },\n        { once: true }\n      )\n    }\n    clonedRequestObject[kSignal] = ac.signal\n\n    // 4. Return clonedRequestObject.\n    return clonedRequestObject\n  }\n}\n\nmixinBody(Request.prototype)\n\nfunction makeRequest (init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map((url) => new URL(url))] : []\n  }\n  request.url = request.urlList[0]\n  return request\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n})\n\nmodule.exports = { Request, makeRequest }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/request.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/response.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/response.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ \"../../../node_modules/undici/lib/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"../../../node_modules/undici/lib/fetch/body.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { kEnumerableProperty } = util\nconst { responseURL, isValidReasonPhrase, toUSVString } = __webpack_require__(/*! ./util */ \"../../../node_modules/undici/lib/fetch/util.js\")\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenResponseHeaderNames\n} = __webpack_require__(/*! ./constants */ \"../../../node_modules/undici/lib/fetch/constants.js\")\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/undici/lib/fetch/symbols.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (...args) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const status = args.length >= 2 ? args[1] : 302\n    const url = toUSVString(args[0])\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url)\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.push('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (...args) {\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n\n    const body = args.length >= 1 ? args[0] : null\n    const init = args.length >= 2 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError()\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(\n          `Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`\n        )\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText')\n      }\n    }\n\n    // 3. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 5. Set this’s response’s status to init[\"status\"].\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status\n    }\n\n    // 6. Set this’s response’s status message to init[\"statusText\"].\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText)\n    }\n\n    // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers)\n    }\n\n    // 8. If body is non-null, then:\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body')\n      }\n\n      // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n      const [extractedBody, contentType] = extractBody(body)\n      this[kState].body = extractedBody\n\n      // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType)\n      }\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError()\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\nmixinBody(Response.prototype)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error:\n      reason instanceof Error\n        ? reason\n        : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    const headers = []\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenResponseHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1])\n      }\n    }\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // TODO: This is not correct...\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'cors'\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\nmodule.exports = { makeNetworkError, makeResponse, filterResponse, Response }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/response.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/symbols.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/symbols.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kUrl: Symbol('url'),\n  kHeaders: Symbol('headers'),\n  kSignal: Symbol('signal'),\n  kState: Symbol('state'),\n  kGuard: Symbol('guard'),\n  kRealm: Symbol('realm')\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/symbols.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/fetch/util.js":
/*!******************************************************!*\
  !*** ../../../node_modules/undici/lib/fetch/util.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { redirectStatus } = __webpack_require__(/*! ./constants */ \"../../../node_modules/undici/lib/fetch/constants.js\")\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\")\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\n\nlet File\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^http?s/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isFileLike (object) {\n  if (!File) {\n    File = (__webpack_require__(/*! ./file */ \"../../../node_modules/undici/lib/fetch/file.js\").File)\n  }\n  return object instanceof File || (\n    object &&\n    (typeof object.stream === 'function' ||\n     typeof object.arrayBuffer === 'function') &&\n    /^(File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.append('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // TODO\n  return 'no-referrer'\n}\n\nfunction matchRequestIntegrity (request, bytes) {\n  return false\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\n function sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes, \n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nclass ServiceWorkerGlobalScope {} // dummy\nclass Window {} // dummy\nclass EnvironmentSettingsObject {} // dummy\n\nmodule.exports = {\n  ServiceWorkerGlobalScope,\n  Window,\n  EnvironmentSettingsObject,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  matchRequestIntegrity,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isFileLike,\n  isValidReasonPhrase,\n  sameOrigin\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/fetch/util.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/handler/redirect.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/handler/redirect.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatcher, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatcher = dispatcher\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatcher.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].toString().toLowerCase() === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  return (\n    (header.length === 4 && header.toString().toLowerCase() === 'host') ||\n    (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||\n    (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization')\n  )\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/handler/redirect.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/llhttp/constants.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/llhttp/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"../../../node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function (ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function (TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function (FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function (LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function (METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */\n    METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */\n    METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */\n    METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */\n    METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */\n    METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */\n    METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */\n    METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */\n    METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */\n    METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */\n    METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */\n    METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE,\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST,\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key) => {\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function (FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR\n    .concat(['\\t', '\\f']);\n// All characters with 0x80 bit set to 1\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.STRICT_TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([' ']);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function (HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/llhttp/constants.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/llhttp/utils.js":
/*!********************************************************!*\
  !*** ../../../node_modules/undici/lib/llhttp/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/llhttp/utils.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-agent.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../agent */ \"../../../node_modules/undici/lib/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = __webpack_require__(/*! ./mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"../../../node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"../../../node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"../../../node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst { WeakRef } = __webpack_require__(/*! ../compat/dispatcher-weakref */ \"../../../node_modules/undici/lib/compat/dispatcher-weakref.js\")()\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new WeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n}\n\nmodule.exports = MockAgent\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-agent.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-client.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-client.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! util */ \"util\")\nconst Client = __webpack_require__(/*! ../client */ \"../../../node_modules/undici/lib/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"../../../node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"../../../node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-client.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-errors.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-errors.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, MockNotMatchedError)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-errors.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-interceptor.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-interceptor.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"../../../node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = __webpack_require__(/*! ./mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\n/**\n * Defines the scope API for a interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      throw new InvalidArgumentError('opts.method must be defined')\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (statusCode, data, responseOptions = {}) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined')\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { statusCode, data, headers, trailers })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-interceptor.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-pool.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-pool.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! util */ \"util\")\nconst Pool = __webpack_require__(/*! ../pool */ \"../../../node_modules/undici/lib/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"../../../node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"../../../node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-pool.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-symbols.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-symbols.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected')\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-symbols.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/mock/mock-utils.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/undici/lib/mock/mock-utils.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"../../../node_modules/undici/lib/mock/mock-errors.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kIsMockActive,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"../../../node_modules/undici/lib/mock/mock-symbols.js\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const header = typeof headers.get === 'function' ? headers.get(matchHeaderName) : headers[matchHeaderName]\n\n    if (!matchValue(matchHeaderValue, header)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(path, key.path))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${key.path}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { times: null, persist: false, consumed: false }\n  const newMockDispatch = { ...baseData, ...key, data: { error: null, ...data } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers } = opts\n  return {\n    path,\n    method,\n    body,\n    headers\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], [])\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  let { times } = mockDispatch\n  if (typeof times === 'number' && times > 0) {\n    times = --mockDispatch.times\n  }\n\n  // If persist is true, skip\n  // Or if times is a number and > 0, skip\n  // Otherwise, mark as consumed\n\n  if (!(persist === true || (typeof times === 'number' && times > 0))) {\n    mockDispatch.consumed = true\n  }\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches) {\n    const responseData = getResponseData(data)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onHeaders(statusCode, responseHeaders, resume)\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent[kIsMockActive]) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/mock/mock-utils.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/node/fixed-queue.js":
/*!************************************************************!*\
  !*** ../../../node_modules/undici/lib/node/fixed-queue.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */\n\n\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/node/fixed-queue.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/pool-base.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/undici/lib/pool-base.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ \"../../../node_modules/undici/lib/node/fixed-queue.js\")\nconst { kSize, kRunning, kPending, kBusy, kUrl } = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kDestroyed = Symbol('destroyed')\nconst kClosedPromise = Symbol('closed promise')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kQueued = Symbol('queued')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\n\nclass PoolBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClosedPromise] = null\n    this[kClosedResolve] = null\n    this[kDestroyed] = false\n    this[kClients] = []\n    this[kNeedDrain] = false\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosedPromise] != null\n  }\n\n  close (cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()))\n        } else {\n          this[kClosedPromise] = new Promise((resolve) => {\n            this[kClosedResolve] = resolve\n          })\n        }\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true\n        })\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null))\n      } else {\n        return this[kClosedPromise]\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err)\n      } else {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  destroy (err, cb) {\n    this[kDestroyed] = true\n\n    if (typeof err === 'function') {\n      cb = err\n      err = null\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)))\n    if (cb) {\n      promise.then(() => cb(null, null))\n    } else {\n      return promise\n    }\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError()\n      }\n\n      const dispatcher = this[kGetDispatcher]()\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true\n        this[kQueue].push({ opts, handler })\n        this[kQueued]++\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true\n        this[kNeedDrain] = !this[kGetDispatcher]()\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/pool-base.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/pool.js":
/*!************************************************!*\
  !*** ../../../node_modules/undici/lib/pool.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"../../../node_modules/undici/lib/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"../../../node_modules/undici/lib/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./core/util */ \"../../../node_modules/undici/lib/core/util.js\")\nconst { kUrl } = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"../../../node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout == null ? 10e3 : connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kFactory] = factory\n  }\n\n  [kGetDispatcher] () {\n    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain])\n\n    if (dispatcher) {\n      return dispatcher\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n    }\n\n    return dispatcher\n  }\n}\n\nmodule.exports = Pool\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/pool.js?");

/***/ }),

/***/ "../../../node_modules/undici/lib/proxy-agent.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/undici/lib/proxy-agent.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kProxy } = __webpack_require__(/*! ./core/symbols */ \"../../../node_modules/undici/lib/core/symbols.js\")\nconst url = __webpack_require__(/*! url */ \"url\")\nconst Agent = __webpack_require__(/*! ./agent */ \"../../../node_modules/undici/lib/agent.js\")\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"../../../node_modules/undici/lib/dispatcher.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"../../../node_modules/undici/lib/core/errors.js\")\n\nconst kAgent = Symbol('proxy agent')\n\nclass ProxyAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n    this[kProxy] = buildProxyOptions(opts)\n    this[kAgent] = new Agent(opts)\n  }\n\n  dispatch (opts, handler) {\n    const { host } = url.parse(opts.origin)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        origin: this[kProxy].uri,\n        path: opts.origin + opts.path,\n        headers: {\n          ...opts.headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async close () {\n    await this[kAgent].close()\n  }\n}\n\nfunction buildProxyOptions (opts) {\n  if (typeof opts === 'string') {\n    opts = { uri: opts }\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  }\n}\n\nmodule.exports = ProxyAgent\n\n\n//# sourceURL=webpack://qui/../../../node_modules/undici/lib/proxy-agent.js?");

/***/ }),

/***/ "../../../node_modules/uri-js/dist/es5/uri.all.js":
/*!********************************************************!*\
  !*** ../../../node_modules/uri-js/dist/es5/uri.all.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n\n\n//# sourceURL=webpack://qui/../../../node_modules/uri-js/dist/es5/uri.all.js?");

/***/ }),

/***/ "../../../node_modules/util-deprecate/node.js":
/*!****************************************************!*\
  !*** ../../../node_modules/util-deprecate/node.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = __webpack_require__(/*! util */ \"util\").deprecate;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/util-deprecate/node.js?");

/***/ }),

/***/ "../../../node_modules/vary/index.js":
/*!*******************************************!*\
  !*** ../../../node_modules/vary/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n */\n\nmodule.exports = vary\nmodule.exports.append = append\n\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/\n\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append (header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required')\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required')\n  }\n\n  // get fields array\n  var fields = !Array.isArray(field)\n    ? parse(String(field))\n    : field\n\n  // assert on invalid field names\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name')\n    }\n  }\n\n  // existing, unspecified vary\n  if (header === '*') {\n    return header\n  }\n\n  // enumerate current values\n  var val = header\n  var vals = parse(header.toLowerCase())\n\n  // unspecified vary\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*'\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase()\n\n    // append value (case-preserving)\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld)\n      val = val\n        ? val + ', ' + fields[i]\n        : fields[i]\n    }\n  }\n\n  return val\n}\n\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\nfunction parse (header) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(header.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(header.substring(start, end))\n\n  return list\n}\n\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\nfunction vary (res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required')\n  }\n\n  // get existing header\n  var val = res.getHeader('Vary') || ''\n  var header = Array.isArray(val)\n    ? val.join(', ')\n    : String(val)\n\n  // set new header\n  if ((val = append(header, field))) {\n    res.setHeader('Vary', val)\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/vary/index.js?");

/***/ }),

/***/ "../../../node_modules/wrappy/wrappy.js":
/*!**********************************************!*\
  !*** ../../../node_modules/wrappy/wrappy.js ***!
  \**********************************************/
/***/ ((module) => {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/wrappy/wrappy.js?");

/***/ }),

/***/ "../../../node_modules/yocto-queue/index.js":
/*!**************************************************!*\
  !*** ../../../node_modules/yocto-queue/index.js ***!
  \**************************************************/
/***/ ((module) => {

eval("class Node {\n\t/// value;\n\t/// next;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\n\t\t// TODO: Remove this when targeting Node.js 12.\n\t\tthis.next = undefined;\n\t}\n}\n\nclass Queue {\n\t// TODO: Use private class fields when targeting Node.js 12.\n\t// #_head;\n\t// #_tail;\n\t// #_size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this._head) {\n\t\t\tthis._tail.next = node;\n\t\t\tthis._tail = node;\n\t\t} else {\n\t\t\tthis._head = node;\n\t\t\tthis._tail = node;\n\t\t}\n\n\t\tthis._size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this._head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._head = this._head.next;\n\t\tthis._size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this._head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack://qui/../../../node_modules/yocto-queue/index.js?");

/***/ }),

/***/ "./fastifyServerAdaptor.ts":
/*!*********************************!*\
  !*** ./fastifyServerAdaptor.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FastifyServerAdaptor = void 0;\nvar fastify_1 = __webpack_require__(/*! fastify */ \"../../../node_modules/fastify/fastify.js\");\nvar fastify_static_1 = __importDefault(__webpack_require__(/*! fastify-static */ \"../../../node_modules/fastify-static/index.js\"));\nvar fastify_cors_1 = __importDefault(__webpack_require__(/*! fastify-cors */ \"../../../node_modules/fastify-cors/index.js\"));\nvar interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./interfaces.ts\");\nvar path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nvar RouteParser_1 = __webpack_require__(/*! @stechquick/symphony-nanoserver/dist/src/RouteParser */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/src/RouteParser.js\");\nvar fastify_http_proxy_1 = __importDefault(__webpack_require__(/*! fastify-http-proxy */ \"../../../node_modules/fastify-http-proxy/index.js\"));\nvar FastifyServerAdaptor = /** @class */ (function () {\n    function FastifyServerAdaptor() {\n    }\n    FastifyServerAdaptor.prototype.Run = function (settings, proxyObject, httpsSettings) {\n        var server;\n        var serverhttps;\n        var root = path_1.default.join(__dirname, \"../client\");\n        var serveStatic = function (srv) { return srv.register(fastify_static_1.default, {\n            root: root,\n            index: [\"index.html\"],\n            list: true,\n        }); };\n        var notFoundHandler = function (srv) {\n            srv.register(function (instance, options, done) {\n                instance.setNotFoundHandler(function (request, reply) {\n                    var _a;\n                    if (!request.url) {\n                        return null;\n                    }\n                    var dir = request.url.toLowerCase();\n                    var lastShashIndex = dir.lastIndexOf(\"/\");\n                    if (dir.indexOf(\"/\") == lastShashIndex || lastShashIndex <= -1) {\n                        return null;\n                    }\n                    if (dir.substring(lastShashIndex).endsWith(\".qjson\")) {\n                        return null;\n                    }\n                    reply.redirect(302, \"/index.html?q=\".concat((_a = request.url) === null || _a === void 0 ? void 0 : _a.replace(\"?\", \"&\")));\n                });\n                done();\n            });\n        };\n        var manageCors = function (srv) { return srv.register(fastify_cors_1.default, {\n            origin: \"*\",\n            allowedHeaders: [\"X-PINGOTHER\", \"Content-Type\", \"Cookie\", \"Set-Cookie\"],\n            methods: [\"POST\", \"GET\", \"OPTIONS\"],\n        }); };\n        var manageProxy = function (srv) {\n            if (!proxyObject) {\n                return;\n            }\n            Object.keys(proxyObject).forEach(function (proxyKey) {\n                if (!interfaces_1.FileHelper.IsRelativePath(proxyObject[proxyKey])) {\n                    console.log(proxyKey, proxyObject[proxyKey]);\n                    srv.register(fastify_http_proxy_1.default, {\n                        upstream: proxyObject[proxyKey],\n                        prefix: proxyKey,\n                        beforeHandler: function (request, reply, done) { console.log(\"proxy for: \" + request.url + \" key: \" + proxyKey); done(); },\n                        http2: false, // optional\n                    });\n                }\n                else {\n                    srv.all(proxyKey + \"*\", function (request, reply) {\n                        var sourceUrl = proxyKey;\n                        var targetUrl = proxyObject[proxyKey];\n                        var leftOver = request.url.substring(request.url.indexOf(proxyKey) + proxyKey.length);\n                        var targetPath = path_1.default.join(targetUrl, leftOver || \"\");\n                        if (interfaces_1.FileHelper.IsRelativePath(targetPath)) {\n                            targetPath = path_1.default.join(__dirname, targetPath);\n                        }\n                        console.log(\"disk redirect: \".concat(sourceUrl, \" --> \").concat(targetPath));\n                        var parsedPath = RouteParser_1.RouteParser.ParseUrl(targetPath);\n                        reply.sendFile(parsedPath.base, parsedPath.dir);\n                    });\n                }\n            });\n        };\n        if (proxyObject) {\n            Object.keys(proxyObject).filter(function (proxyKey) { return interfaces_1.FileHelper.IsRelativePath(proxyObject[proxyKey]); }).forEach(function (proxyKey) {\n                proxyObject[proxyKey] = path_1.default.join(\"../../\", proxyObject[proxyKey]);\n            });\n        }\n        if (settings.localport) {\n            console.log(\"HTTP server is starting...\");\n            server = (0, fastify_1.fastify)({});\n            server.listen(settings.localport, \"0.0.0.0\", function (err, address) { if (err) {\n                console.log(err);\n                return;\n            } console.log(\"HTTP server started at: \".concat(address)); });\n            serveStatic(server);\n            notFoundHandler(server);\n            manageCors(server);\n            manageProxy(server);\n        }\n        if (settings.localhttpsport && httpsSettings) {\n            console.log(\"HTTP server is starting...\");\n            serverhttps = (0, fastify_1.fastify)({ https: { key: httpsSettings.privateKey, cert: httpsSettings.certificate } });\n            serverhttps.listen(settings.localhttpsport, \"0.0.0.0\", function (err, address) { if (err) {\n                console.log(err);\n                return;\n            } console.log(\"HTTPS server started at: \".concat(address)); });\n            serveStatic(serverhttps);\n            notFoundHandler(serverhttps);\n            manageCors(serverhttps);\n            manageProxy(serverhttps);\n        }\n        process.on('SIGINT', function () {\n            console.warn(\"shutting down\");\n            server === null || server === void 0 ? void 0 : server.close();\n            serverhttps === null || serverhttps === void 0 ? void 0 : serverhttps.close();\n        });\n    };\n    return FastifyServerAdaptor;\n}());\nexports.FastifyServerAdaptor = FastifyServerAdaptor;\n\n\n//# sourceURL=webpack://qui/./fastifyServerAdaptor.ts?");

/***/ }),

/***/ "./interfaces.ts":
/*!***********************!*\
  !*** ./interfaces.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileHelper = void 0;\n;\n// TODO - Move to Quick_Shrimp\nvar FileHelper = /** @class */ (function () {\n    function FileHelper() {\n    }\n    FileHelper.IsRelativePath = function (path) {\n        return path.startsWith(\".\");\n    };\n    return FileHelper;\n}());\nexports.FileHelper = FileHelper;\n\n\n//# sourceURL=webpack://qui/./interfaces.ts?");

/***/ }),

/***/ "./nanoServerAdaptor.ts":
/*!******************************!*\
  !*** ./nanoServerAdaptor.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NanoServerAdaptor = void 0;\nvar interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./interfaces.ts\");\nvar symphony_nanoserver_1 = __webpack_require__(/*! @stechquick/symphony-nanoserver */ \"../../../node_modules/@stechquick/symphony-nanoserver/dist/nanoServer.js\");\nvar path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nvar NanoServerAdaptor = /** @class */ (function () {\n    function NanoServerAdaptor() {\n    }\n    NanoServerAdaptor.prototype.Run = function (settings, proxyObject, httpsSettings) {\n        console.log(\"go nano\");\n        var nano = new symphony_nanoserver_1.NanoServer({\n            bindHost: \"0.0.0.0\", rootDiskPath: \"./dist/client\", manageCors: {}, portSeekOffset: 100, statusCodeRedirects: {\n                404: function (request, curPath, curResp) {\n                    var _a;\n                    if (!request.url) {\n                        return null;\n                    }\n                    var dir = request.url.toLowerCase();\n                    var lastShashIndex = dir.lastIndexOf(\"/\");\n                    if (dir.indexOf(\"/\") == lastShashIndex || lastShashIndex <= -1) {\n                        return null;\n                    }\n                    if (dir.substring(lastShashIndex).endsWith(\".qjson\")) {\n                        return null;\n                    }\n                    return { status: 302, headers: { Location: \"/index.html?q=\".concat((_a = request.url) === null || _a === void 0 ? void 0 : _a.replace(\"?\", \"&\")) }, content: null };\n                }\n            }\n        });\n        if (proxyObject) {\n            Object.keys(proxyObject).filter(function (proxyKey) { return interfaces_1.FileHelper.IsRelativePath(proxyObject[proxyKey]); }).forEach(function (proxyKey) {\n                proxyObject[proxyKey] = path_1.default.join(\"../../\", proxyObject[proxyKey]);\n            });\n            nano.AddProxy(proxyObject);\n        }\n        if (settings.localport) {\n            console.log(\"HTTP server is starting...\");\n            nano.Start({\n                port: settings.localport, successCb: function () { return console.log(\"HTTP server started at: \".concat(nano.GetServerUrl())); }\n            });\n        }\n        if (settings.localhttpsport && httpsSettings) {\n            console.log(\"HTTPS server is starting...\");\n            nano.StartHttps({\n                port: settings.localhttpsport,\n                privateKey: httpsSettings.privateKey,\n                certificate: httpsSettings.certificate,\n                successCb: function () { return console.log(\"HTTPS server started at: \".concat(nano.GetServerUrl())); }\n            });\n        }\n        process.on('SIGINT', function () {\n            console.warn(\"shutting down\");\n            nano.Stop();\n        });\n    };\n    return NanoServerAdaptor;\n}());\nexports.NanoServerAdaptor = NanoServerAdaptor;\n\n\n//# sourceURL=webpack://qui/./nanoServerAdaptor.ts?");

/***/ }),

/***/ "./server.ts":
/*!*******************!*\
  !*** ./server.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar js_yaml_1 = __importDefault(__webpack_require__(/*! js-yaml */ \"../../../node_modules/js-yaml/index.js\"));\nvar fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nvar nanoServerAdaptor_1 = __webpack_require__(/*! ./nanoServerAdaptor */ \"./nanoServerAdaptor.ts\");\nvar fastifyServerAdaptor_1 = __webpack_require__(/*! ./fastifyServerAdaptor */ \"./fastifyServerAdaptor.ts\");\nvar searchRootCa_1 = __importDefault(__webpack_require__(/*! @stechquick/algae/lib/helpers/searchRootCa */ \"../../../node_modules/@stechquick/algae/lib/helpers/searchRootCa.js\"));\nvar Server = /** @class */ (function () {\n    function Server() {\n    }\n    Server.prototype.Run = function () {\n        var settings = this.getSettings();\n        var proxyObject = this.getProxyObject();\n        var server = settings.server == \"fastify\" ? new fastifyServerAdaptor_1.FastifyServerAdaptor() : new nanoServerAdaptor_1.NanoServerAdaptor();\n        var httpsSettings;\n        var caCerts = searchRootCa_1.default.getAllFiles(\"./dist/server/settings/server/certificates/ca\");\n        searchRootCa_1.default.registerCaCerts(caCerts);\n        if (!settings.localport && !settings.localhttpsport) {\n            settings.localport = 3002;\n        }\n        if (settings.localhttpsport) {\n            var certFolder = \"./dist/server/settings/server/certificates/\";\n            var privateKey = undefined;\n            var certificate = undefined;\n            if (fs_1.default.existsSync(\"\".concat(certFolder, \"key.pem\"))) {\n                console.log(\"key certificate is found\");\n                privateKey = fs_1.default.readFileSync(\"\".concat(certFolder, \"key.pem\"), { encoding: \"utf-8\" });\n            }\n            if (fs_1.default.existsSync(\"\".concat(certFolder, \"cert.pem\"))) {\n                console.log(\"cert certificate is found\");\n                certificate = fs_1.default.readFileSync(\"\".concat(certFolder, \"cert.pem\"), { encoding: \"utf-8\" });\n            }\n            httpsSettings = { privateKey: privateKey, certificate: certificate };\n        }\n        if (settings.verifyServerCertificate === false) {\n            process.env[\"NODE_TLS_REJECT_UNAUTHORIZED\"] = \"0\";\n        }\n        server.Run(settings, proxyObject, httpsSettings);\n    };\n    Server.prototype.getSettings = function () {\n        var settingsYamlDefault = { verifyServerCertificate: true };\n        var settingsYaml = js_yaml_1.default.load(fs_1.default.readFileSync(\"./dist/server/settings/settings.yaml\", { encoding: \"utf-8\" }));\n        if (typeof (settingsYaml) != \"object\") {\n            settingsYaml = {};\n        }\n        return __assign(__assign({}, settingsYamlDefault), settingsYaml);\n    };\n    Server.prototype.getProxyObject = function () {\n        if (!fs_1.default.existsSync(\"./dist/server/settings/localProxy.yaml\")) {\n            return undefined;\n        }\n        var configYaml = js_yaml_1.default.load(fs_1.default.readFileSync(\"./dist/server/settings/localProxy.yaml\", { encoding: \"utf-8\" }));\n        if (typeof (configYaml) != \"object\") {\n            return undefined;\n        }\n        return Object.keys(configYaml).reduce(function (prev, curKey) {\n            var curVal = configYaml[curKey];\n            prev[curKey] = curVal;\n            return prev;\n        }, {});\n    };\n    return Server;\n}());\nnew Server().Run();\n\n\n//# sourceURL=webpack://qui/./server.ts?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "diagnostics_channel":
/*!**************************************!*\
  !*** external "diagnostics_channel" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("diagnostics_channel");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "http2":
/*!************************!*\
  !*** external "http2" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "stream/web":
/*!*****************************!*\
  !*** external "stream/web" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream/web");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vm":
/*!*********************!*\
  !*** external "vm" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("vm");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../../node_modules/fastify/fastify.js":
/*!************************************************!*\
  !*** ../../../node_modules/fastify/fastify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst VERSION = '3.27.1'\n\nconst Avvio = __webpack_require__(/*! avvio */ \"../../../node_modules/avvio/boot.js\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\")\nlet lightMyRequest\n\nconst {\n  kAvvioBoot,\n  kChildren,\n  kBodyLimit,\n  kRoutePrefix,\n  kLogLevel,\n  kLogSerializers,\n  kHooks,\n  kSchemaController,\n  kRequestAcceptVersion,\n  kReplySerializerDefault,\n  kContentTypeParser,\n  kReply,\n  kRequest,\n  kFourOhFour,\n  kState,\n  kOptions,\n  kPluginNameChain,\n  kSchemaErrorFormatter,\n  kErrorHandler,\n  kKeepAliveConnections\n} = __webpack_require__(/*! ./lib/symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst { createServer } = __webpack_require__(/*! ./lib/server */ \"../../../node_modules/fastify/lib/server.js\")\nconst Reply = __webpack_require__(/*! ./lib/reply */ \"../../../node_modules/fastify/lib/reply.js\")\nconst Request = __webpack_require__(/*! ./lib/request */ \"../../../node_modules/fastify/lib/request.js\")\nconst supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS']\nconst decorator = __webpack_require__(/*! ./lib/decorate */ \"../../../node_modules/fastify/lib/decorate.js\")\nconst ContentTypeParser = __webpack_require__(/*! ./lib/contentTypeParser */ \"../../../node_modules/fastify/lib/contentTypeParser.js\")\nconst SchemaController = __webpack_require__(/*! ./lib/schema-controller */ \"../../../node_modules/fastify/lib/schema-controller.js\")\nconst { Hooks, hookRunnerApplication, supportedHooks } = __webpack_require__(/*! ./lib/hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\nconst { createLogger } = __webpack_require__(/*! ./lib/logger */ \"../../../node_modules/fastify/lib/logger.js\")\nconst pluginUtils = __webpack_require__(/*! ./lib/pluginUtils */ \"../../../node_modules/fastify/lib/pluginUtils.js\")\nconst reqIdGenFactory = __webpack_require__(/*! ./lib/reqIdGenFactory */ \"../../../node_modules/fastify/lib/reqIdGenFactory.js\")\nconst { buildRouting, validateBodyLimitOption } = __webpack_require__(/*! ./lib/route */ \"../../../node_modules/fastify/lib/route.js\")\nconst build404 = __webpack_require__(/*! ./lib/fourOhFour */ \"../../../node_modules/fastify/lib/fourOhFour.js\")\nconst getSecuredInitialConfig = __webpack_require__(/*! ./lib/initialConfigValidation */ \"../../../node_modules/fastify/lib/initialConfigValidation.js\")\nconst override = __webpack_require__(/*! ./lib/pluginOverride */ \"../../../node_modules/fastify/lib/pluginOverride.js\")\nconst warning = __webpack_require__(/*! ./lib/warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\nconst noopSet = __webpack_require__(/*! ./lib/noop-set */ \"../../../node_modules/fastify/lib/noop-set.js\")\nconst { defaultInitOptions } = getSecuredInitialConfig\n\nconst {\n  FST_ERR_BAD_URL,\n  FST_ERR_MISSING_MIDDLEWARE\n} = __webpack_require__(/*! ./lib/errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nconst onBadUrlContext = {\n  config: {\n  },\n  onSend: [],\n  onError: []\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // return a shallow copy of route's sanitized context\n\n  const cleanKeys = {}\n  const allowedProps = ['errorHandler', 'logLevel', 'logSerializers']\n\n  allowedProps.concat(supportedHooks).forEach(k => {\n    cleanKeys[k] = route.store[k]\n  })\n\n  return Object.assign({}, cleanKeys)\n}\n\nfunction defaultErrorHandler (error, request, reply) {\n  if (reply.statusCode < 500) {\n    reply.log.info(\n      { res: reply, err: error },\n      error && error.message\n    )\n  } else {\n    reply.log.error(\n      { req: request, res: reply, err: error },\n      error && error.message\n    )\n  }\n  reply.send(error)\n}\n\nfunction fastify (options) {\n  // Options validations\n  options = options || {}\n\n  if (typeof options !== 'object') {\n    throw new TypeError('Options must be an object')\n  }\n\n  if (options.querystringParser && typeof options.querystringParser !== 'function') {\n    throw new Error(`querystringParser option should be a function, instead got '${typeof options.querystringParser}'`)\n  }\n\n  if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== 'function') {\n    throw new Error(`schemaController.bucket option should be a function, instead got '${typeof options.schemaController.bucket}'`)\n  }\n\n  validateBodyLimitOption(options.bodyLimit)\n\n  const requestIdHeader = options.requestIdHeader || defaultInitOptions.requestIdHeader\n  const querystringParser = options.querystringParser || querystring.parse\n  const genReqId = options.genReqId || reqIdGenFactory()\n  const requestIdLogLabel = options.requestIdLogLabel || 'reqId'\n  const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit\n  const disableRequestLogging = options.disableRequestLogging || false\n  const exposeHeadRoutes = options.exposeHeadRoutes != null ? options.exposeHeadRoutes : false\n\n  const ajvOptions = Object.assign({\n    customOptions: {},\n    plugins: []\n  }, options.ajv)\n  const frameworkErrors = options.frameworkErrors\n\n  // Ajv options\n  if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== '[object Object]') {\n    throw new Error(`ajv.customOptions option should be an object, instead got '${typeof ajvOptions.customOptions}'`)\n  }\n  if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {\n    throw new Error(`ajv.plugins option should be an array, instead got '${typeof ajvOptions.plugins}'`)\n  }\n\n  // Instance Fastify components\n  const { logger, hasLogger } = createLogger(options)\n\n  // Update the options with the fixed values\n  options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout\n  options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout\n  options.forceCloseConnections = typeof options.forceCloseConnections === 'boolean' ? options.forceCloseConnections : defaultInitOptions.forceCloseConnections\n  options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket\n  options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout\n  options.logger = logger\n  options.genReqId = genReqId\n  options.requestIdHeader = requestIdHeader\n  options.querystringParser = querystringParser\n  options.requestIdLogLabel = requestIdLogLabel\n  options.disableRequestLogging = disableRequestLogging\n  options.ajv = ajvOptions\n  options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler\n  options.exposeHeadRoutes = exposeHeadRoutes\n\n  const initialConfig = getSecuredInitialConfig(options)\n  const keepAliveConnections = options.forceCloseConnections === true ? new Set() : noopSet()\n\n  let constraints = options.constraints\n  if (options.versioning) {\n    warning.emit('FSTDEP009')\n    constraints = {\n      ...constraints,\n      version: {\n        name: 'version',\n        mustMatchWhenDerived: true,\n        storage: options.versioning.storage,\n        deriveConstraint: options.versioning.deriveVersion,\n        validate (value) {\n          if (typeof value !== 'string') {\n            throw new Error('Version constraint should be a string.')\n          }\n        }\n      }\n    }\n  }\n\n  // Default router\n  const router = buildRouting({\n    config: {\n      defaultRoute: defaultRoute,\n      onBadUrl: onBadUrl,\n      constraints: constraints,\n      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,\n      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,\n      caseSensitive: options.caseSensitive,\n      buildPrettyMeta: defaultBuildPrettyMeta\n    },\n    keepAliveConnections\n  })\n\n  // 404 router, used for handling encapsulated 404 handlers\n  const fourOhFour = build404(options)\n\n  // HTTP server and its handler\n  const httpHandler = wrapRouting(router.routing, options)\n\n  // we need to set this before calling createServer\n  options.http2SessionTimeout = initialConfig.http2SessionTimeout\n  const { server, listen } = createServer(options, httpHandler)\n\n  const setupResponseListeners = Reply.setupResponseListeners\n  const schemaController = SchemaController.buildSchemaController(null, options.schemaController)\n\n  // Public API\n  const fastify = {\n    // Fastify internals\n    [kState]: {\n      listening: false,\n      closing: false,\n      started: false\n    },\n    [kKeepAliveConnections]: keepAliveConnections,\n    [kOptions]: options,\n    [kChildren]: [],\n    [kBodyLimit]: bodyLimit,\n    [kRoutePrefix]: '',\n    [kLogLevel]: '',\n    [kLogSerializers]: null,\n    [kHooks]: new Hooks(),\n    [kSchemaController]: schemaController,\n    [kSchemaErrorFormatter]: null,\n    [kErrorHandler]: defaultErrorHandler,\n    [kReplySerializerDefault]: null,\n    [kContentTypeParser]: new ContentTypeParser(\n      bodyLimit,\n      (options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning),\n      (options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning)\n    ),\n    [kReply]: Reply.buildReply(Reply),\n    [kRequest]: Request.buildRequest(Request, options.trustProxy),\n    [kFourOhFour]: fourOhFour,\n    [pluginUtils.registeredPlugins]: [],\n    [kPluginNameChain]: [],\n    [kAvvioBoot]: null,\n    // routing method\n    routing: httpHandler,\n    getDefaultRoute: router.getDefaultRoute.bind(router),\n    setDefaultRoute: router.setDefaultRoute.bind(router),\n    // routes shorthand methods\n    delete: function _delete (url, opts, handler) {\n      return router.prepareRoute.call(this, 'DELETE', url, opts, handler)\n    },\n    get: function _get (url, opts, handler) {\n      return router.prepareRoute.call(this, 'GET', url, opts, handler)\n    },\n    head: function _head (url, opts, handler) {\n      return router.prepareRoute.call(this, 'HEAD', url, opts, handler)\n    },\n    patch: function _patch (url, opts, handler) {\n      return router.prepareRoute.call(this, 'PATCH', url, opts, handler)\n    },\n    post: function _post (url, opts, handler) {\n      return router.prepareRoute.call(this, 'POST', url, opts, handler)\n    },\n    put: function _put (url, opts, handler) {\n      return router.prepareRoute.call(this, 'PUT', url, opts, handler)\n    },\n    options: function _options (url, opts, handler) {\n      return router.prepareRoute.call(this, 'OPTIONS', url, opts, handler)\n    },\n    all: function _all (url, opts, handler) {\n      return router.prepareRoute.call(this, supportedMethods, url, opts, handler)\n    },\n    // extended route\n    route: function _route (opts) {\n      // we need the fastify object that we are producing so we apply a lazy loading of the function,\n      // otherwise we should bind it after the declaration\n      return router.route.call(this, opts)\n    },\n    // expose logger instance\n    log: logger,\n    // hooks\n    addHook: addHook,\n    // schemas\n    addSchema: addSchema,\n    getSchema: schemaController.getSchema.bind(schemaController),\n    getSchemas: schemaController.getSchemas.bind(schemaController),\n    setValidatorCompiler: setValidatorCompiler,\n    setSerializerCompiler: setSerializerCompiler,\n    setSchemaController: setSchemaController,\n    setReplySerializer: setReplySerializer,\n    setSchemaErrorFormatter: setSchemaErrorFormatter,\n    // custom parsers\n    addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,\n    hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,\n    getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,\n    defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,\n    removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,\n    removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,\n    // Fastify architecture methods (initialized by Avvio)\n    register: null,\n    after: null,\n    ready: null,\n    onClose: null,\n    close: null,\n    printPlugins: null,\n    // http server\n    listen: listen,\n    server: server,\n    // extend fastify objects\n    decorate: decorator.add,\n    hasDecorator: decorator.exist,\n    decorateReply: decorator.decorateReply,\n    decorateRequest: decorator.decorateRequest,\n    hasRequestDecorator: decorator.existRequest,\n    hasReplyDecorator: decorator.existReply,\n    // fake http injection\n    inject: inject,\n    // pretty print of the registered routes\n    printRoutes,\n    // custom error handling\n    setNotFoundHandler: setNotFoundHandler,\n    setErrorHandler: setErrorHandler,\n    // Set fastify initial configuration options read-only object\n    initialConfig\n  }\n\n  fastify[kReply].prototype.server = fastify\n  fastify[kRequest].prototype.server = fastify\n\n  Object.defineProperties(fastify, {\n    pluginName: {\n      get () {\n        if (this[kPluginNameChain].length > 1) {\n          return this[kPluginNameChain].join(' -> ')\n        }\n        return this[kPluginNameChain][0]\n      }\n    },\n    prefix: {\n      get () { return this[kRoutePrefix] }\n    },\n    validatorCompiler: {\n      get () { return this[kSchemaController].getValidatorCompiler() }\n    },\n    serializerCompiler: {\n      get () { return this[kSchemaController].getSerializerCompiler() }\n    },\n    version: {\n      get () { return VERSION }\n    },\n    errorHandler: {\n      get () {\n        return this[kErrorHandler]\n      }\n    }\n  })\n\n  // We are adding `use` to the fastify prototype so the user\n  // can still access it (and get the expected error), but `decorate`\n  // will not detect it, and allow the user to override it.\n  Object.setPrototypeOf(fastify, { use })\n\n  if (options.schemaErrorFormatter) {\n    validateSchemaErrorFormatter(options.schemaErrorFormatter)\n    fastify[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify)\n  }\n\n  // Install and configure Avvio\n  // Avvio will update the following Fastify methods:\n  // - register\n  // - after\n  // - ready\n  // - onClose\n  // - close\n  const avvio = Avvio(fastify, {\n    autostart: false,\n    timeout: Number(options.pluginTimeout) || defaultInitOptions.pluginTimeout,\n    expose: {\n      use: 'register'\n    }\n  })\n  // Override to allow the plugin encapsulation\n  avvio.override = override\n  avvio.on('start', () => (fastify[kState].started = true))\n  fastify[kAvvioBoot] = fastify.ready // the avvio ready function\n  fastify.ready = ready // overwrite the avvio ready function\n  fastify.printPlugins = avvio.prettyPrint.bind(avvio)\n\n  // cache the closing value, since we are checking it in an hot path\n  avvio.once('preReady', () => {\n    fastify.onClose((instance, done) => {\n      fastify[kState].closing = true\n      router.closeRoutes()\n      if (fastify[kState].listening) {\n        // No new TCP connections are accepted\n        instance.server.close(done)\n\n        for (const conn of fastify[kKeepAliveConnections]) {\n          // We must invoke the destroy method instead of merely unreffing\n          // the sockets. If we only unref, then the callback passed to\n          // `fastify.close` will never be invoked; nor will any of the\n          // registered `onClose` hooks.\n          conn.destroy()\n          fastify[kKeepAliveConnections].delete(conn)\n        }\n      } else {\n        done(null)\n      }\n    })\n  })\n\n  // Set the default 404 handler\n  fastify.setNotFoundHandler()\n  fourOhFour.arrange404(fastify)\n\n  router.setup(options, {\n    avvio,\n    fourOhFour,\n    logger,\n    hasLogger,\n    setupResponseListeners,\n    throwIfAlreadyStarted\n  })\n\n  // Delay configuring clientError handler so that it can access fastify state.\n  server.on('clientError', options.clientErrorHandler.bind(fastify))\n\n  try {\n    const dc = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\n    const initChannel = dc.channel('fastify.initialization')\n    if (initChannel.hasSubscribers) {\n      initChannel.publish({ fastify })\n    }\n  } catch (e) {\n    // This only happens if `diagnostics_channel` isn't available, i.e. earlier\n    // versions of Node.js. In that event, we don't care, so ignore the error.\n  }\n\n  return fastify\n\n  function throwIfAlreadyStarted (msg) {\n    if (fastify[kState].started) throw new Error(msg)\n  }\n\n  // HTTP injection handling\n  // If the server is not ready yet, this\n  // utility will automatically force it.\n  function inject (opts, cb) {\n    // lightMyRequest is dynamically loaded as it seems very expensive\n    // because of Ajv\n    if (lightMyRequest === undefined) {\n      lightMyRequest = __webpack_require__(/*! light-my-request */ \"../../../node_modules/light-my-request/index.js\")\n    }\n\n    if (fastify[kState].started) {\n      if (fastify[kState].closing) {\n        // Force to return an error\n        const error = new Error('Server is closed')\n        if (cb) {\n          cb(error)\n          return\n        } else {\n          return Promise.reject(error)\n        }\n      }\n      return lightMyRequest(httpHandler, opts, cb)\n    }\n\n    if (cb) {\n      this.ready(err => {\n        if (err) cb(err, null)\n        else lightMyRequest(httpHandler, opts, cb)\n      })\n    } else {\n      return lightMyRequest((req, res) => {\n        this.ready(function (err) {\n          if (err) {\n            res.emit('error', err)\n            return\n          }\n          httpHandler(req, res)\n        })\n      }, opts)\n    }\n  }\n\n  function ready (cb) {\n    let resolveReady\n    let rejectReady\n\n    // run the hooks after returning the promise\n    process.nextTick(runHooks)\n\n    if (!cb) {\n      return new Promise(function (resolve, reject) {\n        resolveReady = resolve\n        rejectReady = reject\n      })\n    }\n\n    function runHooks () {\n      // start loading\n      fastify[kAvvioBoot]((err, done) => {\n        if (err || fastify[kState].started) {\n          manageErr(err)\n        } else {\n          hookRunnerApplication('onReady', fastify[kAvvioBoot], fastify, manageErr)\n        }\n        done()\n      })\n    }\n\n    function manageErr (err) {\n      if (cb) {\n        if (err) {\n          cb(err)\n        } else {\n          cb(undefined, fastify)\n        }\n      } else {\n        if (err) {\n          return rejectReady(err)\n        }\n        resolveReady(fastify)\n      }\n    }\n  }\n\n  function use () {\n    throw new FST_ERR_MISSING_MIDDLEWARE()\n  }\n\n  // wrapper that we expose to the user for hooks handling\n  function addHook (name, fn) {\n    throwIfAlreadyStarted('Cannot call \"addHook\" when fastify instance is already started!')\n\n    if (name === 'onSend' || name === 'preSerialization' || name === 'onError') {\n      if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {\n        throw new Error('Async function has too many arguments. Async hooks should not use the \\'done\\' argument.')\n      }\n    } else if (name === 'onReady') {\n      if (fn.constructor.name === 'AsyncFunction' && fn.length !== 0) {\n        throw new Error('Async function has too many arguments. Async hooks should not use the \\'done\\' argument.')\n      }\n    } else if (name !== 'preParsing') {\n      if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {\n        throw new Error('Async function has too many arguments. Async hooks should not use the \\'done\\' argument.')\n      }\n    }\n\n    if (name === 'onClose') {\n      this.onClose(fn)\n    } else if (name === 'onReady') {\n      this[kHooks].add(name, fn)\n    } else {\n      this.after((err, done) => {\n        _addHook.call(this, name, fn)\n        done(err)\n      })\n    }\n    return this\n\n    function _addHook (name, fn) {\n      this[kHooks].add(name, fn)\n      this[kChildren].forEach(child => _addHook.call(child, name, fn))\n    }\n  }\n\n  // wrapper that we expose to the user for schemas handling\n  function addSchema (schema) {\n    throwIfAlreadyStarted('Cannot call \"addSchema\" when fastify instance is already started!')\n    this[kSchemaController].add(schema)\n    this[kChildren].forEach(child => child.addSchema(schema))\n    return this\n  }\n\n  function defaultClientErrorHandler (err, socket) {\n    // In case of a connection reset, the socket has been destroyed and there is nothing that needs to be done.\n    // https://nodejs.org/api/http.html#http_event_clienterror\n    if (err.code === 'ECONNRESET' || socket.destroyed) {\n      return\n    }\n\n    const body = JSON.stringify({\n      error: http.STATUS_CODES['400'],\n      message: 'Client Error',\n      statusCode: 400\n    })\n\n    // Most devs do not know what to do with this error.\n    // In the vast majority of cases, it's a network error and/or some\n    // config issue on the load balancer side.\n    this.log.trace({ err }, 'client error')\n    // Copying standard node behaviour\n    // https://github.com/nodejs/node/blob/6ca23d7846cb47e84fd344543e394e50938540be/lib/_http_server.js#L666\n\n    // If the socket is not writable, there is no reason to try to send data.\n    if (socket.writable && socket.bytesWritten === 0) {\n      socket.write(`HTTP/1.1 400 Bad Request\\r\\nContent-Length: ${body.length}\\r\\nContent-Type: application/json\\r\\n\\r\\n${body}`)\n    }\n    socket.destroy(err)\n  }\n\n  // If the router does not match any route, every request will land here\n  // req and res are Node.js core objects\n  function defaultRoute (req, res) {\n    if (req.headers['accept-version'] !== undefined) {\n      // we remove the accept-version header for performance result\n      // because we do not want to go through the constraint checking\n      // the usage of symbol here to prevent any colision on custom header name\n      req.headers[kRequestAcceptVersion] = req.headers['accept-version']\n      req.headers['accept-version'] = undefined\n    }\n    fourOhFour.router.lookup(req, res)\n  }\n\n  function onBadUrl (path, req, res) {\n    if (frameworkErrors) {\n      const id = genReqId(req)\n      const childLogger = logger.child({ reqId: id })\n\n      childLogger.info({ req }, 'incoming request')\n\n      const request = new Request(id, null, req, null, childLogger, onBadUrlContext)\n      const reply = new Reply(res, request, childLogger)\n      return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply)\n    }\n    const body = `{\"error\":\"Bad Request\",\"message\":\"'${path}' is not a valid url component\",\"statusCode\":400}`\n    res.writeHead(400, {\n      'Content-Type': 'application/json',\n      'Content-Length': body.length\n    })\n    res.end(body)\n  }\n\n  function setNotFoundHandler (opts, handler) {\n    throwIfAlreadyStarted('Cannot call \"setNotFoundHandler\" when fastify instance is already started!')\n\n    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler)\n    return this\n  }\n\n  function setValidatorCompiler (validatorCompiler) {\n    throwIfAlreadyStarted('Cannot call \"setValidatorCompiler\" when fastify instance is already started!')\n    this[kSchemaController].setValidatorCompiler(validatorCompiler)\n    return this\n  }\n\n  function setSchemaErrorFormatter (errorFormatter) {\n    throwIfAlreadyStarted('Cannot call \"setSchemaErrorFormatter\" when fastify instance is already started!')\n    validateSchemaErrorFormatter(errorFormatter)\n    this[kSchemaErrorFormatter] = errorFormatter.bind(this)\n    return this\n  }\n\n  function setSerializerCompiler (serializerCompiler) {\n    throwIfAlreadyStarted('Cannot call \"setSerializerCompiler\" when fastify instance is already started!')\n    this[kSchemaController].setSerializerCompiler(serializerCompiler)\n    return this\n  }\n\n  function setSchemaController (schemaControllerOpts) {\n    throwIfAlreadyStarted('Cannot call \"setSchemaController\" when fastify instance is already started!')\n    const old = this[kSchemaController]\n    const schemaController = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts))\n    this[kSchemaController] = schemaController\n    this.getSchema = schemaController.getSchema.bind(schemaController)\n    this.getSchemas = schemaController.getSchemas.bind(schemaController)\n    return this\n  }\n\n  function setReplySerializer (replySerializer) {\n    throwIfAlreadyStarted('Cannot call \"setReplySerializer\" when fastify instance is already started!')\n\n    this[kReplySerializerDefault] = replySerializer\n    return this\n  }\n\n  // wrapper that we expose to the user for configure the custom error handler\n  function setErrorHandler (func) {\n    throwIfAlreadyStarted('Cannot call \"setErrorHandler\" when fastify instance is already started!')\n\n    this[kErrorHandler] = func.bind(this)\n    return this\n  }\n\n  function printRoutes (opts = {}) {\n    // includeHooks:true - shortcut to include all supported hooks exported by fastify.Hooks\n    opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta\n    return router.printRoutes(opts)\n  }\n}\n\nfunction validateSchemaErrorFormatter (schemaErrorFormatter) {\n  if (typeof schemaErrorFormatter !== 'function') {\n    throw new Error(`schemaErrorFormatter option should be a function, instead got ${typeof schemaErrorFormatter}`)\n  } else if (schemaErrorFormatter.constructor.name === 'AsyncFunction') {\n    throw new Error('schemaErrorFormatter option should not be an async function')\n  }\n}\n\nfunction wrapRouting (httpHandler, { rewriteUrl, logger }) {\n  if (!rewriteUrl) {\n    return httpHandler\n  }\n  return function preRouting (req, res) {\n    const originalUrl = req.url\n    const url = rewriteUrl(req)\n    if (originalUrl !== url) {\n      logger.debug({ originalUrl, url }, 'rewrite url')\n      if (typeof url === 'string') {\n        req.url = url\n      } else {\n        req.destroy(new Error(`Rewrite url for \"${req.url}\" needs to be of type \"string\" but received \"${typeof url}\"`))\n      }\n    }\n    httpHandler(req, res)\n  }\n}\n\n/**\n * These export configurations enable JS and TS developers\n * to consumer fastify in whatever way best suits their needs.\n * Some examples of supported import syntax includes:\n * - `const fastify = require('fastify')`\n * - `const { fastify } = require('fastify')`\n * - `import * as Fastify from 'fastify'`\n * - `import { fastify, TSC_definition } from 'fastify'`\n * - `import fastify from 'fastify'`\n * - `import fastify, { TSC_definition } from 'fastify'`\n */\nmodule.exports = fastify\nmodule.exports.fastify = fastify\nmodule.exports[\"default\"] = fastify\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/fastify.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/configValidator.js":
/*!************************************************************!*\
  !*** ../../../node_modules/fastify/lib/configValidator.js ***!
  \************************************************************/
/***/ ((module) => {

eval("// This file is autogenerated by build/build-validation.js, do not edit\n/* istanbul ignore file */\n// constant needed for customRule0 to work\nconst self = {}\n\n'use strict';\nvar validate = (function() {\n  var refVal = [];\n  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {\n    'use strict';\n    var vErrors = null;\n    var errors = 0;\n    if (rootData === undefined) rootData = data;\n    if ((data && typeof data === \"object\" && !Array.isArray(data))) {\n      if (data.connectionTimeout === undefined) data.connectionTimeout = 0;\n      if (data.keepAliveTimeout === undefined) data.keepAliveTimeout = 5000;\n      if (data.maxRequestsPerSocket === undefined) data.maxRequestsPerSocket = 0;\n      if (data.requestTimeout === undefined) data.requestTimeout = 0;\n      if (data.bodyLimit === undefined) data.bodyLimit = 1048576;\n      if (data.caseSensitive === undefined) data.caseSensitive = true;\n      if (data.ignoreTrailingSlash === undefined) data.ignoreTrailingSlash = false;\n      if (data.disableRequestLogging === undefined) data.disableRequestLogging = false;\n      if (data.jsonShorthand === undefined) data.jsonShorthand = true;\n      if (data.maxParamLength === undefined) data.maxParamLength = 100;\n      if (data.onProtoPoisoning === undefined) data.onProtoPoisoning = \"error\";\n      if (data.onConstructorPoisoning === undefined) data.onConstructorPoisoning = \"error\";\n      if (data.pluginTimeout === undefined) data.pluginTimeout = 10000;\n      if (data.requestIdHeader === undefined) data.requestIdHeader = \"request-id\";\n      if (data.requestIdLogLabel === undefined) data.requestIdLogLabel = \"reqId\";\n      if (data.http2SessionTimeout === undefined) data.http2SessionTimeout = 5000;\n      var errs__0 = errors;\n      var valid1 = true;\n      for (var key0 in data) {\n        var isAdditional0 = !( false || validate.schema.properties.hasOwnProperty(key0));\n        if (isAdditional0) {\n          delete data[key0];\n        }\n      }\n      if (valid1) {\n        var data1 = data.connectionTimeout;\n        var errs_1 = errors;\n        if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n          var dataType1 = typeof data1;\n          var coerced1 = undefined;\n          if (coerced1 !== undefined);\n          else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n          else {\n            validate.errors = [{\n              keyword: 'type',\n              dataPath: (dataPath || '') + '.connectionTimeout',\n              schemaPath: '#/properties/connectionTimeout/type',\n              params: {\n                type: 'integer'\n              },\n              message: 'should be integer'\n            }];\n            return false;\n          }\n          if (coerced1 !== undefined) {\n            data1 = coerced1;\n            data['connectionTimeout'] = coerced1;\n          }\n        }\n        var valid1 = errors === errs_1;\n        if (valid1) {\n          var data1 = data.keepAliveTimeout;\n          var errs_1 = errors;\n          if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n            var dataType1 = typeof data1;\n            var coerced1 = undefined;\n            if (coerced1 !== undefined);\n            else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n            else {\n              validate.errors = [{\n                keyword: 'type',\n                dataPath: (dataPath || '') + '.keepAliveTimeout',\n                schemaPath: '#/properties/keepAliveTimeout/type',\n                params: {\n                  type: 'integer'\n                },\n                message: 'should be integer'\n              }];\n              return false;\n            }\n            if (coerced1 !== undefined) {\n              data1 = coerced1;\n              data['keepAliveTimeout'] = coerced1;\n            }\n          }\n          var valid1 = errors === errs_1;\n          if (valid1) {\n            var data1 = data.maxRequestsPerSocket;\n            var errs_1 = errors;\n            if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n              var dataType1 = typeof data1;\n              var coerced1 = undefined;\n              if (coerced1 !== undefined);\n              else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n              else {\n                validate.errors = [{\n                  keyword: 'type',\n                  dataPath: (dataPath || '') + '.maxRequestsPerSocket',\n                  schemaPath: '#/properties/maxRequestsPerSocket/type',\n                  params: {\n                    type: 'integer'\n                  },\n                  message: 'should be integer'\n                }];\n                return false;\n              }\n              if (coerced1 !== undefined) {\n                data1 = coerced1;\n                data['maxRequestsPerSocket'] = coerced1;\n              }\n            }\n            var valid1 = errors === errs_1;\n            if (valid1) {\n              var data1 = data.requestTimeout;\n              var errs_1 = errors;\n              if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                var dataType1 = typeof data1;\n                var coerced1 = undefined;\n                if (coerced1 !== undefined);\n                else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n                else {\n                  validate.errors = [{\n                    keyword: 'type',\n                    dataPath: (dataPath || '') + '.requestTimeout',\n                    schemaPath: '#/properties/requestTimeout/type',\n                    params: {\n                      type: 'integer'\n                    },\n                    message: 'should be integer'\n                  }];\n                  return false;\n                }\n                if (coerced1 !== undefined) {\n                  data1 = coerced1;\n                  data['requestTimeout'] = coerced1;\n                }\n              }\n              var valid1 = errors === errs_1;\n              if (valid1) {\n                var data1 = data.bodyLimit;\n                var errs_1 = errors;\n                if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                  var dataType1 = typeof data1;\n                  var coerced1 = undefined;\n                  if (coerced1 !== undefined);\n                  else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n                  else {\n                    validate.errors = [{\n                      keyword: 'type',\n                      dataPath: (dataPath || '') + '.bodyLimit',\n                      schemaPath: '#/properties/bodyLimit/type',\n                      params: {\n                        type: 'integer'\n                      },\n                      message: 'should be integer'\n                    }];\n                    return false;\n                  }\n                  if (coerced1 !== undefined) {\n                    data1 = coerced1;\n                    data['bodyLimit'] = coerced1;\n                  }\n                }\n                var valid1 = errors === errs_1;\n                if (valid1) {\n                  var data1 = data.caseSensitive;\n                  var errs_1 = errors;\n                  if (typeof data1 !== \"boolean\") {\n                    var dataType1 = typeof data1;\n                    var coerced1 = undefined;\n                    if (coerced1 !== undefined);\n                    else if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;\n                    else if (data1 === 'true' || data1 === 1) coerced1 = true;\n                    else {\n                      validate.errors = [{\n                        keyword: 'type',\n                        dataPath: (dataPath || '') + '.caseSensitive',\n                        schemaPath: '#/properties/caseSensitive/type',\n                        params: {\n                          type: 'boolean'\n                        },\n                        message: 'should be boolean'\n                      }];\n                      return false;\n                    }\n                    if (coerced1 !== undefined) {\n                      data1 = coerced1;\n                      data['caseSensitive'] = coerced1;\n                    }\n                  }\n                  var valid1 = errors === errs_1;\n                  if (valid1) {\n                    var data1 = data.http2;\n                    if (data1 === undefined) {\n                      valid1 = true;\n                    } else {\n                      var errs_1 = errors;\n                      if (typeof data1 !== \"boolean\") {\n                        var dataType1 = typeof data1;\n                        var coerced1 = undefined;\n                        if (coerced1 !== undefined);\n                        else if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;\n                        else if (data1 === 'true' || data1 === 1) coerced1 = true;\n                        else {\n                          validate.errors = [{\n                            keyword: 'type',\n                            dataPath: (dataPath || '') + '.http2',\n                            schemaPath: '#/properties/http2/type',\n                            params: {\n                              type: 'boolean'\n                            },\n                            message: 'should be boolean'\n                          }];\n                          return false;\n                        }\n                        if (coerced1 !== undefined) {\n                          data1 = coerced1;\n                          data['http2'] = coerced1;\n                        }\n                      }\n                      var valid1 = errors === errs_1;\n                    }\n                    if (valid1) {\n                      var data1 = data.https;\n                      if (data1 === undefined) {\n                        valid1 = true;\n                      } else {\n                        var errs_1 = errors;\n                        var errs__1 = errors;\n                        var valid1 = true;\n                        var errs_2 = errors;\n                        var errs__2 = errors;\n                        var errs_3 = errors;\n                        var errs__3 = errors,\n                          prevValid3 = false,\n                          valid3 = false,\n                          passingSchemas3 = null;\n                        var errs_4 = errors;\n                        if (typeof data1 !== \"boolean\") {\n                          var dataType4 = typeof data1;\n                          var coerced4 = undefined;\n                          if (coerced4 !== undefined);\n                          else if (data1 === 'false' || data1 === 0 || data1 === null) coerced4 = false;\n                          else if (data1 === 'true' || data1 === 1) coerced4 = true;\n                          else {\n                            var err = {};\n                            if (vErrors === null) vErrors = [err];\n                            else vErrors.push(err);\n                            errors++;\n                          }\n                          if (coerced4 !== undefined) {\n                            data1 = coerced4;\n                            data['https'] = coerced4;\n                          }\n                        }\n                        var valid4 = errors === errs_4;\n                        if (valid4) {\n                          valid3 = prevValid3 = true;\n                          passingSchemas3 = 0;\n                        }\n                        var errs_4 = errors;\n                        if (data1 !== null) {\n                          var dataType4 = typeof data1;\n                          var coerced4 = undefined;\n                          if (coerced4 !== undefined);\n                          else if (data1 === '' || data1 === 0 || data1 === false) coerced4 = null;\n                          else {\n                            var err = {};\n                            if (vErrors === null) vErrors = [err];\n                            else vErrors.push(err);\n                            errors++;\n                          }\n                          if (coerced4 !== undefined) {\n                            data1 = coerced4;\n                            data['https'] = coerced4;\n                          }\n                        }\n                        var valid4 = errors === errs_4;\n                        if (valid4 && prevValid3) {\n                          valid3 = false;\n                          passingSchemas3 = [passingSchemas3, 1];\n                        } else {\n                          if (valid4) {\n                            valid3 = prevValid3 = true;\n                            passingSchemas3 = 1;\n                          }\n                          var errs_4 = errors;\n                          if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                            if (true) {\n                              var errs__4 = errors;\n                              var valid5 = true;\n                              for (var key4 in data1) {\n                                var isAdditional4 = !( false || key4 == 'allowHTTP1');\n                                if (isAdditional4) {\n                                  delete data1[key4];\n                                }\n                              }\n                              if (valid5) {\n                                var data2 = data1.allowHTTP1;\n                                if (data2 === undefined) {\n                                  valid5 = false;\n                                  var err = {};\n                                  if (vErrors === null) vErrors = [err];\n                                  else vErrors.push(err);\n                                  errors++;\n                                } else {\n                                  var errs_5 = errors;\n                                  if (typeof data2 !== \"boolean\") {\n                                    var dataType5 = typeof data2;\n                                    var coerced5 = undefined;\n                                    if (coerced5 !== undefined);\n                                    else if (data2 === 'false' || data2 === 0 || data2 === null) coerced5 = false;\n                                    else if (data2 === 'true' || data2 === 1) coerced5 = true;\n                                    else {\n                                      var err = {};\n                                      if (vErrors === null) vErrors = [err];\n                                      else vErrors.push(err);\n                                      errors++;\n                                    }\n                                    if (coerced5 !== undefined) {\n                                      data2 = coerced5;\n                                      data1['allowHTTP1'] = coerced5;\n                                    }\n                                  }\n                                  var valid5 = errors === errs_5;\n                                }\n                                if (valid5) {}\n                              }\n                              if (errs__4 == errors) {}\n                            }\n                          } else {\n                            var err = {};\n                            if (vErrors === null) vErrors = [err];\n                            else vErrors.push(err);\n                            errors++;\n                          }\n                          if (errors === errs_4) {}\n                          var valid4 = errors === errs_4;\n                          if (valid4 && prevValid3) {\n                            valid3 = false;\n                            passingSchemas3 = [passingSchemas3, 2];\n                          } else {\n                            if (valid4) {\n                              valid3 = prevValid3 = true;\n                              passingSchemas3 = 2;\n                            }\n                          }\n                        }\n                        if (!valid3) {\n                          var err = {};\n                          if (vErrors === null) vErrors = [err];\n                          else vErrors.push(err);\n                          errors++;\n                        } else {\n                          errors = errs__3;\n                          if (vErrors !== null) {\n                            if (errs__3) vErrors.length = errs__3;\n                            else vErrors = null;\n                          }\n                        }\n                        if (errors === errs_3) {}\n                        var valid3 = errors === errs_3;\n                        if (valid3) {\n                          var err = {};\n                          if (vErrors === null) vErrors = [err];\n                          else vErrors.push(err);\n                          errors++;\n                        } else {\n                          errors = errs__2;\n                          if (vErrors !== null) {\n                            if (errs__2) vErrors.length = errs__2;\n                            else vErrors = null;\n                          }\n                        }\n                        if (errors === errs_2) {}\n                        var valid2 = errors === errs_2;\n                        errors = errs__1;\n                        if (vErrors !== null) {\n                          if (errs__1) vErrors.length = errs__1;\n                          else vErrors = null;\n                        }\n                        if (valid2) {\n                          var errs_2 = errors;\n                          customRule0.errors = null;\n                          var errs__2 = errors;\n                          var valid2;\n                          valid2 = customRule0.call(self, validate.schema.properties.https.then.setDefaultValue, data1, validate.schema.properties.https.then, (dataPath || '') + '.https', data, 'https', rootData);\n                          if (data) data1 = data['https'];\n                          if (!valid2) {\n                            validate.errors = [{\n                              keyword: 'setDefaultValue',\n                              dataPath: (dataPath || '') + '.https',\n                              schemaPath: '#/properties/https/then/setDefaultValue',\n                              params: {\n                                keyword: 'setDefaultValue'\n                              },\n                              message: 'should pass \"setDefaultValue\" keyword validation'\n                            }];\n                            return false;\n                          } else {}\n                          if (errors === errs_2) {}\n                          var valid2 = errors === errs_2;\n                          valid1 = valid2;\n                        }\n                        if (!valid1) {\n                          var err = {\n                            keyword: 'if',\n                            dataPath: (dataPath || '') + '.https',\n                            schemaPath: '#/properties/https/if',\n                            params: {\n                              failingKeyword: 'then'\n                            },\n                            message: 'should match \"' + 'then' + '\" schema'\n                          };\n                          if (vErrors === null) vErrors = [err];\n                          else vErrors.push(err);\n                          errors++;\n                          validate.errors = vErrors;\n                          return false;\n                        } else {}\n                        if (errors === errs_1) {}\n                        var valid1 = errors === errs_1;\n                      }\n                      if (valid1) {\n                        var data1 = data.ignoreTrailingSlash;\n                        var errs_1 = errors;\n                        if (typeof data1 !== \"boolean\") {\n                          var dataType1 = typeof data1;\n                          var coerced1 = undefined;\n                          if (coerced1 !== undefined);\n                          else if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;\n                          else if (data1 === 'true' || data1 === 1) coerced1 = true;\n                          else {\n                            validate.errors = [{\n                              keyword: 'type',\n                              dataPath: (dataPath || '') + '.ignoreTrailingSlash',\n                              schemaPath: '#/properties/ignoreTrailingSlash/type',\n                              params: {\n                                type: 'boolean'\n                              },\n                              message: 'should be boolean'\n                            }];\n                            return false;\n                          }\n                          if (coerced1 !== undefined) {\n                            data1 = coerced1;\n                            data['ignoreTrailingSlash'] = coerced1;\n                          }\n                        }\n                        var valid1 = errors === errs_1;\n                        if (valid1) {\n                          var data1 = data.disableRequestLogging;\n                          var errs_1 = errors;\n                          if (typeof data1 !== \"boolean\") {\n                            var dataType1 = typeof data1;\n                            var coerced1 = undefined;\n                            if (coerced1 !== undefined);\n                            else if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;\n                            else if (data1 === 'true' || data1 === 1) coerced1 = true;\n                            else {\n                              validate.errors = [{\n                                keyword: 'type',\n                                dataPath: (dataPath || '') + '.disableRequestLogging',\n                                schemaPath: '#/properties/disableRequestLogging/type',\n                                params: {\n                                  type: 'boolean'\n                                },\n                                message: 'should be boolean'\n                              }];\n                              return false;\n                            }\n                            if (coerced1 !== undefined) {\n                              data1 = coerced1;\n                              data['disableRequestLogging'] = coerced1;\n                            }\n                          }\n                          var valid1 = errors === errs_1;\n                          if (valid1) {\n                            var data1 = data.jsonShorthand;\n                            var errs_1 = errors;\n                            if (typeof data1 !== \"boolean\") {\n                              var dataType1 = typeof data1;\n                              var coerced1 = undefined;\n                              if (coerced1 !== undefined);\n                              else if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;\n                              else if (data1 === 'true' || data1 === 1) coerced1 = true;\n                              else {\n                                validate.errors = [{\n                                  keyword: 'type',\n                                  dataPath: (dataPath || '') + '.jsonShorthand',\n                                  schemaPath: '#/properties/jsonShorthand/type',\n                                  params: {\n                                    type: 'boolean'\n                                  },\n                                  message: 'should be boolean'\n                                }];\n                                return false;\n                              }\n                              if (coerced1 !== undefined) {\n                                data1 = coerced1;\n                                data['jsonShorthand'] = coerced1;\n                              }\n                            }\n                            var valid1 = errors === errs_1;\n                            if (valid1) {\n                              var data1 = data.maxParamLength;\n                              var errs_1 = errors;\n                              if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                var dataType1 = typeof data1;\n                                var coerced1 = undefined;\n                                if (coerced1 !== undefined);\n                                else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n                                else {\n                                  validate.errors = [{\n                                    keyword: 'type',\n                                    dataPath: (dataPath || '') + '.maxParamLength',\n                                    schemaPath: '#/properties/maxParamLength/type',\n                                    params: {\n                                      type: 'integer'\n                                    },\n                                    message: 'should be integer'\n                                  }];\n                                  return false;\n                                }\n                                if (coerced1 !== undefined) {\n                                  data1 = coerced1;\n                                  data['maxParamLength'] = coerced1;\n                                }\n                              }\n                              var valid1 = errors === errs_1;\n                              if (valid1) {\n                                var data1 = data.onProtoPoisoning;\n                                var errs_1 = errors;\n                                if (typeof data1 !== \"string\") {\n                                  var dataType1 = typeof data1;\n                                  var coerced1 = undefined;\n                                  if (coerced1 !== undefined);\n                                  else if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;\n                                  else if (data1 === null) coerced1 = '';\n                                  else {\n                                    validate.errors = [{\n                                      keyword: 'type',\n                                      dataPath: (dataPath || '') + '.onProtoPoisoning',\n                                      schemaPath: '#/properties/onProtoPoisoning/type',\n                                      params: {\n                                        type: 'string'\n                                      },\n                                      message: 'should be string'\n                                    }];\n                                    return false;\n                                  }\n                                  if (coerced1 !== undefined) {\n                                    data1 = coerced1;\n                                    data['onProtoPoisoning'] = coerced1;\n                                  }\n                                }\n                                var valid1 = errors === errs_1;\n                                if (valid1) {\n                                  var data1 = data.onConstructorPoisoning;\n                                  var errs_1 = errors;\n                                  if (typeof data1 !== \"string\") {\n                                    var dataType1 = typeof data1;\n                                    var coerced1 = undefined;\n                                    if (coerced1 !== undefined);\n                                    else if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;\n                                    else if (data1 === null) coerced1 = '';\n                                    else {\n                                      validate.errors = [{\n                                        keyword: 'type',\n                                        dataPath: (dataPath || '') + '.onConstructorPoisoning',\n                                        schemaPath: '#/properties/onConstructorPoisoning/type',\n                                        params: {\n                                          type: 'string'\n                                        },\n                                        message: 'should be string'\n                                      }];\n                                      return false;\n                                    }\n                                    if (coerced1 !== undefined) {\n                                      data1 = coerced1;\n                                      data['onConstructorPoisoning'] = coerced1;\n                                    }\n                                  }\n                                  var valid1 = errors === errs_1;\n                                  if (valid1) {\n                                    var data1 = data.pluginTimeout;\n                                    var errs_1 = errors;\n                                    if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                      var dataType1 = typeof data1;\n                                      var coerced1 = undefined;\n                                      if (coerced1 !== undefined);\n                                      else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n                                      else {\n                                        validate.errors = [{\n                                          keyword: 'type',\n                                          dataPath: (dataPath || '') + '.pluginTimeout',\n                                          schemaPath: '#/properties/pluginTimeout/type',\n                                          params: {\n                                            type: 'integer'\n                                          },\n                                          message: 'should be integer'\n                                        }];\n                                        return false;\n                                      }\n                                      if (coerced1 !== undefined) {\n                                        data1 = coerced1;\n                                        data['pluginTimeout'] = coerced1;\n                                      }\n                                    }\n                                    var valid1 = errors === errs_1;\n                                    if (valid1) {\n                                      var data1 = data.requestIdHeader;\n                                      var errs_1 = errors;\n                                      if (typeof data1 !== \"string\") {\n                                        var dataType1 = typeof data1;\n                                        var coerced1 = undefined;\n                                        if (coerced1 !== undefined);\n                                        else if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;\n                                        else if (data1 === null) coerced1 = '';\n                                        else {\n                                          validate.errors = [{\n                                            keyword: 'type',\n                                            dataPath: (dataPath || '') + '.requestIdHeader',\n                                            schemaPath: '#/properties/requestIdHeader/type',\n                                            params: {\n                                              type: 'string'\n                                            },\n                                            message: 'should be string'\n                                          }];\n                                          return false;\n                                        }\n                                        if (coerced1 !== undefined) {\n                                          data1 = coerced1;\n                                          data['requestIdHeader'] = coerced1;\n                                        }\n                                      }\n                                      var valid1 = errors === errs_1;\n                                      if (valid1) {\n                                        var data1 = data.requestIdLogLabel;\n                                        var errs_1 = errors;\n                                        if (typeof data1 !== \"string\") {\n                                          var dataType1 = typeof data1;\n                                          var coerced1 = undefined;\n                                          if (coerced1 !== undefined);\n                                          else if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;\n                                          else if (data1 === null) coerced1 = '';\n                                          else {\n                                            validate.errors = [{\n                                              keyword: 'type',\n                                              dataPath: (dataPath || '') + '.requestIdLogLabel',\n                                              schemaPath: '#/properties/requestIdLogLabel/type',\n                                              params: {\n                                                type: 'string'\n                                              },\n                                              message: 'should be string'\n                                            }];\n                                            return false;\n                                          }\n                                          if (coerced1 !== undefined) {\n                                            data1 = coerced1;\n                                            data['requestIdLogLabel'] = coerced1;\n                                          }\n                                        }\n                                        var valid1 = errors === errs_1;\n                                        if (valid1) {\n                                          var data1 = data.http2SessionTimeout;\n                                          var errs_1 = errors;\n                                          if ((typeof data1 !== \"number\" || (data1 % 1) || data1 !== data1)) {\n                                            var dataType1 = typeof data1;\n                                            var coerced1 = undefined;\n                                            if (coerced1 !== undefined);\n                                            else if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;\n                                            else {\n                                              validate.errors = [{\n                                                keyword: 'type',\n                                                dataPath: (dataPath || '') + '.http2SessionTimeout',\n                                                schemaPath: '#/properties/http2SessionTimeout/type',\n                                                params: {\n                                                  type: 'integer'\n                                                },\n                                                message: 'should be integer'\n                                              }];\n                                              return false;\n                                            }\n                                            if (coerced1 !== undefined) {\n                                              data1 = coerced1;\n                                              data['http2SessionTimeout'] = coerced1;\n                                            }\n                                          }\n                                          var valid1 = errors === errs_1;\n                                          if (valid1) {\n                                            var data1 = data.versioning;\n                                            if (data1 === undefined) {\n                                              valid1 = true;\n                                            } else {\n                                              var errs_1 = errors;\n                                              if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                var missing1;\n                                                if (((data1.storage === undefined) && (missing1 = '.storage')) || ((data1.deriveVersion === undefined) && (missing1 = '.deriveVersion'))) {\n                                                  validate.errors = [{\n                                                    keyword: 'required',\n                                                    dataPath: (dataPath || '') + '.versioning',\n                                                    schemaPath: '#/properties/versioning/required',\n                                                    params: {\n                                                      missingProperty: '' + missing1 + ''\n                                                    },\n                                                    message: 'should have required property \\'' + missing1 + '\\''\n                                                  }];\n                                                  return false;\n                                                } else {\n                                                  var errs__1 = errors;\n                                                  var valid2 = true;\n                                                  for (var key1 in data1) {\n                                                    var isAdditional1 = !( false || key1 == 'storage' || key1 == 'deriveVersion');\n                                                    if (isAdditional1) {}\n                                                  }\n                                                  if (valid2) {\n                                                    if (valid2) {\n                                                      if (valid2) {}\n                                                    }\n                                                  }\n                                                  if (errs__1 == errors) {}\n                                                }\n                                              } else {\n                                                validate.errors = [{\n                                                  keyword: 'type',\n                                                  dataPath: (dataPath || '') + '.versioning',\n                                                  schemaPath: '#/properties/versioning/type',\n                                                  params: {\n                                                    type: 'object'\n                                                  },\n                                                  message: 'should be object'\n                                                }];\n                                                return false;\n                                              }\n                                              if (errors === errs_1) {}\n                                              var valid1 = errors === errs_1;\n                                            }\n                                            if (valid1) {\n                                              var data1 = data.constraints;\n                                              if (data1 === undefined) {\n                                                valid1 = true;\n                                              } else {\n                                                var errs_1 = errors;\n                                                if ((data1 && typeof data1 === \"object\" && !Array.isArray(data1))) {\n                                                  var errs__1 = errors;\n                                                  var valid2 = true;\n                                                  for (var key1 in data1) {\n                                                    var data2 = data1[key1];\n                                                    var errs_2 = errors;\n                                                    if ((data2 && typeof data2 === \"object\" && !Array.isArray(data2))) {\n                                                      var missing2;\n                                                      if (((data2.storage === undefined) && (missing2 = '.storage')) || ((data2.validate === undefined) && (missing2 = '.validate')) || ((data2.deriveConstraint === undefined) && (missing2 = '.deriveConstraint'))) {\n                                                        validate.errors = [{\n                                                          keyword: 'required',\n                                                          dataPath: (dataPath || '') + '.constraints[\\'' + key1 + '\\']',\n                                                          schemaPath: '#/properties/constraints/additionalProperties/required',\n                                                          params: {\n                                                            missingProperty: '' + missing2 + ''\n                                                          },\n                                                          message: 'should have required property \\'' + missing2 + '\\''\n                                                        }];\n                                                        return false;\n                                                      } else {\n                                                        var errs__2 = errors;\n                                                        var valid3 = true;\n                                                        for (var key2 in data2) {\n                                                          var isAdditional2 = !( false || key2 == 'name' || key2 == 'storage' || key2 == 'validate' || key2 == 'deriveConstraint');\n                                                          if (isAdditional2) {}\n                                                        }\n                                                        if (valid3) {\n                                                          var data3 = data2.name;\n                                                          if (data3 === undefined) {\n                                                            valid3 = false;\n                                                            validate.errors = [{\n                                                              keyword: 'required',\n                                                              dataPath: (dataPath || '') + '.constraints[\\'' + key1 + '\\']',\n                                                              schemaPath: '#/properties/constraints/additionalProperties/required',\n                                                              params: {\n                                                                missingProperty: 'name'\n                                                              },\n                                                              message: 'should have required property \\'name\\''\n                                                            }];\n                                                            return false;\n                                                          } else {\n                                                            var errs_3 = errors;\n                                                            if (typeof data3 !== \"string\") {\n                                                              var dataType3 = typeof data3;\n                                                              var coerced3 = undefined;\n                                                              if (coerced3 !== undefined);\n                                                              else if (dataType3 == 'number' || dataType3 == 'boolean') coerced3 = '' + data3;\n                                                              else if (data3 === null) coerced3 = '';\n                                                              else {\n                                                                validate.errors = [{\n                                                                  keyword: 'type',\n                                                                  dataPath: (dataPath || '') + '.constraints[\\'' + key1 + '\\'].name',\n                                                                  schemaPath: '#/properties/constraints/additionalProperties/properties/name/type',\n                                                                  params: {\n                                                                    type: 'string'\n                                                                  },\n                                                                  message: 'should be string'\n                                                                }];\n                                                                return false;\n                                                              }\n                                                              if (coerced3 !== undefined) {\n                                                                data3 = coerced3;\n                                                                data2['name'] = coerced3;\n                                                              }\n                                                            }\n                                                            var valid3 = errors === errs_3;\n                                                          }\n                                                          if (valid3) {\n                                                            if (valid3) {\n                                                              if (valid3) {\n                                                                if (valid3) {}\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                        if (errs__2 == errors) {}\n                                                      }\n                                                    } else {\n                                                      validate.errors = [{\n                                                        keyword: 'type',\n                                                        dataPath: (dataPath || '') + '.constraints[\\'' + key1 + '\\']',\n                                                        schemaPath: '#/properties/constraints/additionalProperties/type',\n                                                        params: {\n                                                          type: 'object'\n                                                        },\n                                                        message: 'should be object'\n                                                      }];\n                                                      return false;\n                                                    }\n                                                    if (errors === errs_2) {}\n                                                    var valid2 = errors === errs_2;\n                                                    if (!valid2) break;\n                                                  }\n                                                  if (valid2) {}\n                                                  if (errs__1 == errors) {}\n                                                } else {\n                                                  validate.errors = [{\n                                                    keyword: 'type',\n                                                    dataPath: (dataPath || '') + '.constraints',\n                                                    schemaPath: '#/properties/constraints/type',\n                                                    params: {\n                                                      type: 'object'\n                                                    },\n                                                    message: 'should be object'\n                                                  }];\n                                                  return false;\n                                                }\n                                                if (errors === errs_1) {}\n                                                var valid1 = errors === errs_1;\n                                              }\n                                              if (valid1) {}\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (errs__0 == errors) {}\n    } else {\n      validate.errors = [{\n        keyword: 'type',\n        dataPath: (dataPath || '') + \"\",\n        schemaPath: '#/type',\n        params: {\n          type: 'object'\n        },\n        message: 'should be object'\n      }];\n      return false;\n    }\n    if (errors === 0) {}\n    validate.errors = vErrors;\n    return errors === 0;\n  };\n})();\nvalidate.schema = {\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"connectionTimeout\": {\n      \"type\": \"integer\",\n      \"default\": 0\n    },\n    \"keepAliveTimeout\": {\n      \"type\": \"integer\",\n      \"default\": 5000\n    },\n    \"maxRequestsPerSocket\": {\n      \"type\": \"integer\",\n      \"default\": 0,\n      \"nullable\": true\n    },\n    \"requestTimeout\": {\n      \"type\": \"integer\",\n      \"default\": 0\n    },\n    \"bodyLimit\": {\n      \"type\": \"integer\",\n      \"default\": 1048576\n    },\n    \"caseSensitive\": {\n      \"type\": \"boolean\",\n      \"default\": true\n    },\n    \"http2\": {\n      \"type\": \"boolean\"\n    },\n    \"https\": {\n      \"if\": {\n        \"not\": {\n          \"oneOf\": [{\n            \"type\": \"boolean\"\n          }, {\n            \"type\": \"null\"\n          }, {\n            \"type\": \"object\",\n            \"additionalProperties\": false,\n            \"required\": [\"allowHTTP1\"],\n            \"properties\": {\n              \"allowHTTP1\": {\n                \"type\": \"boolean\"\n              }\n            }\n          }]\n        }\n      },\n      \"then\": {\n        \"setDefaultValue\": true\n      }\n    },\n    \"ignoreTrailingSlash\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"disableRequestLogging\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"jsonShorthand\": {\n      \"type\": \"boolean\",\n      \"default\": true\n    },\n    \"maxParamLength\": {\n      \"type\": \"integer\",\n      \"default\": 100\n    },\n    \"onProtoPoisoning\": {\n      \"type\": \"string\",\n      \"default\": \"error\"\n    },\n    \"onConstructorPoisoning\": {\n      \"type\": \"string\",\n      \"default\": \"error\"\n    },\n    \"pluginTimeout\": {\n      \"type\": \"integer\",\n      \"default\": 10000\n    },\n    \"requestIdHeader\": {\n      \"type\": \"string\",\n      \"default\": \"request-id\"\n    },\n    \"requestIdLogLabel\": {\n      \"type\": \"string\",\n      \"default\": \"reqId\"\n    },\n    \"http2SessionTimeout\": {\n      \"type\": \"integer\",\n      \"default\": 5000\n    },\n    \"versioning\": {\n      \"type\": \"object\",\n      \"additionalProperties\": true,\n      \"required\": [\"storage\", \"deriveVersion\"],\n      \"properties\": {\n        \"storage\": {},\n        \"deriveVersion\": {}\n      }\n    },\n    \"constraints\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"required\": [\"name\", \"storage\", \"validate\", \"deriveConstraint\"],\n        \"additionalProperties\": true,\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"storage\": {},\n          \"validate\": {},\n          \"deriveConstraint\": {}\n        }\n      }\n    }\n  }\n};\nvalidate.errors = null;\nmodule.exports = validate;\n\nfunction customRule0 (schemaParamValue, validatedParamValue, validationSchemaObject, currentDataPath, validatedParamObject, validatedParam) {\n  validatedParamObject[validatedParam] = schemaParamValue\n  return true\n}\n\nmodule.exports.defaultInitOptions = {\"connectionTimeout\":0,\"keepAliveTimeout\":5000,\"maxRequestsPerSocket\":0,\"requestTimeout\":0,\"bodyLimit\":1048576,\"caseSensitive\":true,\"disableRequestLogging\":false,\"jsonShorthand\":true,\"ignoreTrailingSlash\":false,\"maxParamLength\":100,\"onProtoPoisoning\":\"error\",\"onConstructorPoisoning\":\"error\",\"pluginTimeout\":10000,\"requestIdHeader\":\"request-id\",\"requestIdLogLabel\":\"reqId\",\"http2SessionTimeout\":5000}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/configValidator.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/contentTypeParser.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/fastify/lib/contentTypeParser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nlet lru = __webpack_require__(/*! tiny-lru */ \"../../../node_modules/tiny-lru/lib/tiny-lru.cjs.js\")\n// Needed to handle Webpack and faux modules\n// See https://github.com/fastify/fastify/issues/2356\n// and https://github.com/fastify/fastify/discussions/2907.\nlru = typeof lru === 'function' ? lru : lru.default\n\nconst secureJson = __webpack_require__(/*! secure-json-parse */ \"../../../node_modules/secure-json-parse/index.js\")\nconst {\n  kDefaultJsonParse,\n  kContentTypeParser,\n  kBodyLimit,\n  kRequestPayloadStream,\n  kState,\n  kTestInternals\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst {\n  FST_ERR_CTP_INVALID_TYPE,\n  FST_ERR_CTP_EMPTY_TYPE,\n  FST_ERR_CTP_ALREADY_PRESENT,\n  FST_ERR_CTP_INVALID_HANDLER,\n  FST_ERR_CTP_INVALID_PARSE_TYPE,\n  FST_ERR_CTP_BODY_TOO_LARGE,\n  FST_ERR_CTP_INVALID_MEDIA_TYPE,\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH,\n  FST_ERR_CTP_EMPTY_JSON_BODY\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\nconst warning = __webpack_require__(/*! ./warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\n\nfunction ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {\n  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)\n  this.customParsers = {}\n  this.customParsers['application/json'] = new Parser(true, false, bodyLimit, this[kDefaultJsonParse])\n  this.customParsers['text/plain'] = new Parser(true, false, bodyLimit, defaultPlainTextParser)\n  this.parserList = ['application/json', 'text/plain']\n  this.parserRegExpList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.add = function (contentType, opts, parserFn) {\n  const contentTypeIsString = typeof contentType === 'string'\n\n  if (!contentTypeIsString && !(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n  if (contentTypeIsString && contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()\n  if (typeof parserFn !== 'function') throw new FST_ERR_CTP_INVALID_HANDLER()\n\n  if (this.existingParser(contentType)) {\n    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)\n  }\n\n  if (opts.parseAs !== undefined) {\n    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {\n      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)\n    }\n  }\n\n  const parser = new Parser(\n    opts.parseAs === 'string',\n    opts.parseAs === 'buffer',\n    opts.bodyLimit,\n    parserFn\n  )\n\n  if (contentTypeIsString && contentType === '*') {\n    this.customParsers[''] = parser\n  } else {\n    if (contentTypeIsString) {\n      this.parserList.unshift(contentType)\n    } else {\n      this.parserRegExpList.unshift(contentType)\n    }\n    this.customParsers[contentType] = parser\n  }\n}\n\nContentTypeParser.prototype.hasParser = function (contentType) {\n  return contentType in this.customParsers\n}\n\nContentTypeParser.prototype.existingParser = function (contentType) {\n  if (contentType === 'application/json') {\n    return this.customParsers['application/json'] && this.customParsers['application/json'].fn !== this[kDefaultJsonParse]\n  }\n  if (contentType === 'text/plain') {\n    return this.customParsers['text/plain'] && this.customParsers['text/plain'].fn !== defaultPlainTextParser\n  }\n\n  return contentType in this.customParsers\n}\n\nContentTypeParser.prototype.getParser = function (contentType) {\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== this.parserList.length; ++i) {\n    const parserName = this.parserList[i]\n    if (contentType.indexOf(parserName) > -1) {\n      const parser = this.customParsers[parserName]\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  // eslint-disable-next-line no-var\n  for (var j = 0; j !== this.parserRegExpList.length; ++j) {\n    const parserRegExp = this.parserRegExpList[j]\n    if (parserRegExp.test(contentType)) {\n      const parser = this.customParsers[parserRegExp]\n      this.cache.set(contentType, parser)\n      return parser\n    }\n  }\n\n  return this.customParsers['']\n}\n\nContentTypeParser.prototype.removeAll = function () {\n  this.customParsers = {}\n  this.parserRegExpList = []\n  this.parserList = []\n  this.cache = lru(100)\n}\n\nContentTypeParser.prototype.remove = function (contentType) {\n  if (!(typeof contentType === 'string' || contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()\n\n  delete this.customParsers[contentType]\n\n  const parsers = typeof contentType === 'string' ? this.parserList : this.parserRegExpList\n\n  const idx = parsers.findIndex(ct => ct.toString() === contentType.toString())\n\n  if (idx > -1) {\n    parsers.splice(idx, 1)\n  }\n}\n\nContentTypeParser.prototype.run = function (contentType, handler, request, reply) {\n  const parser = this.cache.get(contentType) || this.getParser(contentType)\n  const resource = new AsyncResource('content-type-parser:run', request)\n\n  if (parser === undefined) {\n    reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType))\n  } else if (parser.asString === true || parser.asBuffer === true) {\n    rawBody(\n      request,\n      reply,\n      reply.context._parserOptions,\n      parser,\n      done\n    )\n  } else {\n    let result\n\n    if (parser.isDeprecatedSignature) {\n      result = parser.fn(request[kRequestPayloadStream], done)\n    } else {\n      result = parser.fn(request, request[kRequestPayloadStream], done)\n    }\n\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n\n  function done (error, body) {\n    // We cannot use resource.bind() because it is broken in node v12.\n    resource.runInAsyncScope(() => {\n      if (error) {\n        reply.send(error)\n      } else {\n        request.body = body\n        handler(request, reply)\n      }\n    })\n  }\n}\n\nfunction rawBody (request, reply, options, parser, done) {\n  const asString = parser.asString\n  const limit = options.limit === null ? parser.bodyLimit : options.limit\n  const contentLength = request.headers['content-length'] === undefined\n    ? NaN\n    : Number.parseInt(request.headers['content-length'], 10)\n\n  if (contentLength > limit) {\n    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n    return\n  }\n\n  let receivedLength = 0\n  let body = asString === true ? '' : []\n\n  const payload = request[kRequestPayloadStream] || request.raw\n\n  if (asString === true) {\n    payload.setEncoding('utf8')\n  }\n\n  payload.on('data', onData)\n  payload.on('end', onEnd)\n  payload.on('error', onEnd)\n  payload.resume()\n\n  function onData (chunk) {\n    receivedLength += chunk.length\n\n    if ((payload.receivedEncodedLength || receivedLength) > limit) {\n      payload.removeListener('data', onData)\n      payload.removeListener('end', onEnd)\n      payload.removeListener('error', onEnd)\n      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE())\n      return\n    }\n\n    if (asString === true) {\n      body += chunk\n    } else {\n      body.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    payload.removeListener('data', onData)\n    payload.removeListener('end', onEnd)\n    payload.removeListener('error', onEnd)\n\n    if (err !== undefined) {\n      err.statusCode = 400\n      reply.code(err.statusCode).send(err)\n      return\n    }\n\n    if (asString === true) {\n      receivedLength = Buffer.byteLength(body)\n    }\n\n    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {\n      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH())\n      return\n    }\n\n    if (asString === false) {\n      body = Buffer.concat(body)\n    }\n\n    const result = parser.fn(request, body, done)\n    if (result && typeof result.then === 'function') {\n      result.then(body => done(null, body), done)\n    }\n  }\n}\n\nfunction getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {\n  return defaultJsonParser\n\n  function defaultJsonParser (req, body, done) {\n    if (body === '' || body == null) {\n      return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined)\n    }\n    let json\n    try {\n      json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })\n    } catch (err) {\n      err.statusCode = 400\n      return done(err, undefined)\n    }\n    done(null, json)\n  }\n}\n\nfunction defaultPlainTextParser (req, body, done) {\n  done(null, body)\n}\n\nfunction Parser (asString, asBuffer, bodyLimit, fn) {\n  this.asString = asString\n  this.asBuffer = asBuffer\n  this.bodyLimit = bodyLimit\n  this.fn = fn\n\n  // Check for deprecation syntax\n  if (fn.length === (fn.constructor.name === 'AsyncFunction' ? 1 : 2)) {\n    warning.emit('FSTDEP003')\n    this.isDeprecatedSignature = true\n  }\n}\n\nfunction buildContentTypeParser (c) {\n  const contentTypeParser = new ContentTypeParser()\n  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse]\n  Object.assign(contentTypeParser.customParsers, c.customParsers)\n  contentTypeParser.parserList = c.parserList.slice()\n  return contentTypeParser\n}\n\nfunction addContentTypeParser (contentType, opts, parser) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"addContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (typeof opts === 'function') {\n    parser = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit]\n\n  if (Array.isArray(contentType)) {\n    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser))\n  } else {\n    this[kContentTypeParser].add(contentType, opts, parser)\n  }\n\n  return this\n}\n\nfunction hasContentTypeParser (contentType) {\n  return this[kContentTypeParser].hasParser(contentType)\n}\n\nfunction removeContentTypeParser (contentType) {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeContentTypeParser\" when fastify instance is already started!')\n  }\n\n  if (Array.isArray(contentType)) {\n    for (const type of contentType) {\n      this[kContentTypeParser].remove(type)\n    }\n  } else {\n    this[kContentTypeParser].remove(contentType)\n  }\n}\n\nfunction removeAllContentTypeParsers () {\n  if (this[kState].started) {\n    throw new Error('Cannot call \"removeAllContentTypeParsers\" when fastify instance is already started!')\n  }\n\n  this[kContentTypeParser].removeAll()\n}\n\nmodule.exports = ContentTypeParser\nmodule.exports.helpers = {\n  buildContentTypeParser,\n  addContentTypeParser,\n  hasContentTypeParser,\n  removeContentTypeParser,\n  removeAllContentTypeParsers\n}\nmodule.exports.defaultParsers = {\n  getDefaultJsonParser,\n  defaultTextParser: defaultPlainTextParser\n}\nmodule.exports[kTestInternals] = { rawBody }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/contentTypeParser.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/context.js":
/*!****************************************************!*\
  !*** ../../../node_modules/fastify/lib/context.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kFourOhFourContext, kReplySerializerDefault } = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\n\n// Objects that holds the context of every request\n// Every route holds an instance of this object.\nfunction Context (schema, handler, Reply, Request, contentTypeParser, config, errorHandler, bodyLimit, logLevel, logSerializers, attachValidation, replySerializer, schemaErrorFormatter) {\n  this.schema = schema\n  this.handler = handler\n  this.Reply = Reply\n  this.Request = Request\n  this.contentTypeParser = contentTypeParser\n  this.onRequest = null\n  this.onSend = null\n  this.onError = null\n  this.onTimeout = null\n  this.preHandler = null\n  this.onResponse = null\n  this.config = config\n  this.errorHandler = errorHandler\n  this._middie = null\n  this._parserOptions = { limit: bodyLimit || null }\n  this.logLevel = logLevel\n  this.logSerializers = logSerializers\n  this[kFourOhFourContext] = null\n  this.attachValidation = attachValidation\n  this[kReplySerializerDefault] = replySerializer\n  this.schemaErrorFormatter = schemaErrorFormatter || defaultSchemaErrorFormatter\n}\n\nfunction defaultSchemaErrorFormatter (errors, dataVar) {\n  let text = ''\n  const separator = ', '\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== errors.length; ++i) {\n    const e = errors[i]\n    text += dataVar + (e.dataPath || '') + ' ' + e.message + separator\n  }\n  return new Error(text.slice(0, -separator.length))\n}\n\nmodule.exports = Context\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/context.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/decorate.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/fastify/lib/decorate.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst {\n  kReply,\n  kRequest,\n  kState\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst {\n  FST_ERR_DEC_ALREADY_PRESENT,\n  FST_ERR_DEC_MISSING_DEPENDENCY,\n  FST_ERR_DEC_AFTER_START,\n  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nconst warning = __webpack_require__(/*! ./warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\n\nfunction decorate (instance, name, fn, dependencies) {\n  if (instance.hasOwnProperty(name)) {\n    throw new FST_ERR_DEC_ALREADY_PRESENT(name)\n  }\n\n  checkDependencies(instance, name, dependencies)\n\n  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {\n    Object.defineProperty(instance, name, {\n      get: fn.getter,\n      set: fn.setter\n    })\n  } else {\n    instance[name] = fn\n  }\n}\n\nfunction decorateConstructor (konstructor, name, fn, dependencies) {\n  const instance = konstructor.prototype\n  if (instance.hasOwnProperty(name) || hasKey(konstructor, name)) {\n    throw new FST_ERR_DEC_ALREADY_PRESENT(name)\n  }\n\n  checkDependencies(konstructor, name, dependencies)\n\n  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {\n    Object.defineProperty(instance, name, {\n      get: fn.getter,\n      set: fn.setter\n    })\n  } else if (typeof fn === 'function') {\n    instance[name] = fn\n  } else {\n    konstructor.props.push({ key: name, value: fn })\n  }\n}\n\nfunction checkReferenceType (name, fn) {\n  if (typeof fn === 'object' && fn && !(typeof fn.getter === 'function' || typeof fn.setter === 'function')) {\n    warning.emit('FSTDEP006', name)\n  }\n}\n\nfunction decorateFastify (name, fn, dependencies) {\n  assertNotStarted(this, name)\n  decorate(this, name, fn, dependencies)\n  return this\n}\n\nfunction checkExistence (instance, name) {\n  if (name) {\n    return name in instance || (instance.prototype && name in instance.prototype) || hasKey(instance, name)\n  }\n\n  return instance in this\n}\n\nfunction hasKey (fn, name) {\n  if (fn.props) {\n    return fn.props.find(({ key }) => key === name)\n  }\n  return false\n}\n\nfunction checkRequestExistence (name) {\n  if (name && hasKey(this[kRequest], name)) return true\n  return checkExistence(this[kRequest].prototype, name)\n}\n\nfunction checkReplyExistence (name) {\n  if (name && hasKey(this[kReply], name)) return true\n  return checkExistence(this[kReply].prototype, name)\n}\n\nfunction checkDependencies (instance, name, deps) {\n  if (deps === undefined || deps === null) {\n    return\n  }\n\n  if (!Array.isArray(deps)) {\n    throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name)\n  }\n\n  // eslint-disable-next-line no-var\n  for (var i = 0; i !== deps.length; ++i) {\n    if (!checkExistence(instance, deps[i])) {\n      throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i])\n    }\n  }\n}\n\nfunction decorateReply (name, fn, dependencies) {\n  assertNotStarted(this, name)\n  checkReferenceType(name, fn)\n  decorateConstructor(this[kReply], name, fn, dependencies)\n  return this\n}\n\nfunction decorateRequest (name, fn, dependencies) {\n  assertNotStarted(this, name)\n  checkReferenceType(name, fn)\n  decorateConstructor(this[kRequest], name, fn, dependencies)\n  return this\n}\n\nfunction assertNotStarted (instance, name) {\n  if (instance[kState].started) {\n    throw new FST_ERR_DEC_AFTER_START(name)\n  }\n}\n\nmodule.exports = {\n  add: decorateFastify,\n  exist: checkExistence,\n  existRequest: checkRequestExistence,\n  existReply: checkReplyExistence,\n  dependencies: checkDependencies,\n  decorateReply: decorateReply,\n  decorateRequest: decorateRequest\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/decorate.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/errors.js":
/*!***************************************************!*\
  !*** ../../../node_modules/fastify/lib/errors.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst createError = __webpack_require__(/*! fastify-error */ \"../../../node_modules/fastify-error/index.js\")\nconst codes = {\n  /**\n   * Basic\n   */\n  FST_ERR_NOT_FOUND: createError(\n    'FST_ERR_NOT_FOUND',\n    'Not Found',\n    404\n  ),\n\n  /**\n   * ContentTypeParser\n  */\n  FST_ERR_CTP_ALREADY_PRESENT: createError(\n    'FST_ERR_CTP_ALREADY_PRESENT',\n    \"Content type parser '%s' already present.\"\n  ),\n  FST_ERR_CTP_INVALID_TYPE: createError(\n    'FST_ERR_CTP_INVALID_TYPE',\n    'The content type should be a string or a RegExp',\n    500,\n    TypeError\n  ),\n  FST_ERR_CTP_EMPTY_TYPE: createError(\n    'FST_ERR_CTP_EMPTY_TYPE',\n    'The content type cannot be an empty string',\n    500,\n    TypeError\n  ),\n  FST_ERR_CTP_INVALID_HANDLER: createError(\n    'FST_ERR_CTP_INVALID_HANDLER',\n    'The content type handler should be a function',\n    500,\n    TypeError\n  ),\n  FST_ERR_CTP_INVALID_PARSE_TYPE: createError(\n    'FST_ERR_CTP_INVALID_PARSE_TYPE',\n    \"The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.\",\n    500,\n    TypeError\n  ),\n  FST_ERR_CTP_BODY_TOO_LARGE: createError(\n    'FST_ERR_CTP_BODY_TOO_LARGE',\n    'Request body is too large',\n    413,\n    RangeError\n  ),\n  FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(\n    'FST_ERR_CTP_INVALID_MEDIA_TYPE',\n    'Unsupported Media Type: %s',\n    415\n  ),\n  FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(\n    'FST_ERR_CTP_INVALID_CONTENT_LENGTH',\n    'Request body size did not match Content-Length',\n    400,\n    RangeError\n  ),\n  FST_ERR_CTP_EMPTY_JSON_BODY: createError(\n    'FST_ERR_CTP_EMPTY_JSON_BODY',\n    \"Body cannot be empty when content-type is set to 'application/json'\",\n    400\n  ),\n\n  /**\n   * decorate\n  */\n  FST_ERR_DEC_ALREADY_PRESENT: createError(\n    'FST_ERR_DEC_ALREADY_PRESENT',\n    \"The decorator '%s' has already been added!\"\n  ),\n  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(\n    'FST_ERR_DEC_DEPENDENCY_INVALID_TYPE',\n    \"The dependencies of decorator '%s' must be of type Array.\"\n  ),\n  FST_ERR_DEC_MISSING_DEPENDENCY: createError(\n    'FST_ERR_DEC_MISSING_DEPENDENCY',\n    \"The decorator is missing dependency '%s'.\"\n  ),\n  FST_ERR_DEC_AFTER_START: createError(\n    'FST_ERR_DEC_AFTER_START',\n    \"The decorator '%s' has been added after start!\"\n  ),\n\n  /**\n   * hooks\n  */\n  FST_ERR_HOOK_INVALID_TYPE: createError(\n    'FST_ERR_HOOK_INVALID_TYPE',\n    'The hook name must be a string',\n    500,\n    TypeError\n  ),\n  FST_ERR_HOOK_INVALID_HANDLER: createError(\n    'FST_ERR_HOOK_INVALID_HANDLER',\n    'The hook callback must be a function',\n    500,\n    TypeError\n  ),\n\n  /**\n   * Middlewares\n   */\n  FST_ERR_MISSING_MIDDLEWARE: createError(\n    'FST_ERR_MISSING_MIDDLEWARE',\n    'You must register a plugin for handling middlewares, visit fastify.io/docs/latest/Middleware/ for more info.',\n    500\n  ),\n\n  /**\n   * logger\n  */\n  FST_ERR_LOG_INVALID_DESTINATION: createError(\n    'FST_ERR_LOG_INVALID_DESTINATION',\n    'Cannot specify both logger.stream and logger.file options'\n  ),\n\n  /**\n   * reply\n  */\n  FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(\n    'FST_ERR_REP_INVALID_PAYLOAD_TYPE',\n    \"Attempted to send payload of invalid type '%s'. Expected a string or Buffer.\",\n    500,\n    TypeError\n  ),\n  FST_ERR_REP_ALREADY_SENT: createError(\n    'FST_ERR_REP_ALREADY_SENT',\n    'Reply was already sent.'\n  ),\n  FST_ERR_REP_SENT_VALUE: createError(\n    'FST_ERR_REP_SENT_VALUE',\n    'The only possible value for reply.sent is true.'\n  ),\n  FST_ERR_SEND_INSIDE_ONERR: createError(\n    'FST_ERR_SEND_INSIDE_ONERR',\n    'You cannot use `send` inside the `onError` hook'\n  ),\n  FST_ERR_SEND_UNDEFINED_ERR: createError(\n    'FST_ERR_SEND_UNDEFINED_ERR',\n    'Undefined error has occurred'\n  ),\n  FST_ERR_BAD_STATUS_CODE: createError(\n    'FST_ERR_BAD_STATUS_CODE',\n    'Called reply with an invalid status code: %s'\n  ),\n\n  /**\n   * schemas\n  */\n  FST_ERR_SCH_MISSING_ID: createError(\n    'FST_ERR_SCH_MISSING_ID',\n    'Missing schema $id property'\n  ),\n  FST_ERR_SCH_ALREADY_PRESENT: createError(\n    'FST_ERR_SCH_ALREADY_PRESENT',\n    \"Schema with id '%s' already declared!\"\n  ),\n  FST_ERR_SCH_DUPLICATE: createError(\n    'FST_ERR_SCH_DUPLICATE',\n    \"Schema with '%s' already present!\"\n  ),\n  FST_ERR_SCH_VALIDATION_BUILD: createError(\n    'FST_ERR_SCH_VALIDATION_BUILD',\n    'Failed building the validation schema for %s: %s, due to error %s'\n  ),\n  FST_ERR_SCH_SERIALIZATION_BUILD: createError(\n    'FST_ERR_SCH_SERIALIZATION_BUILD',\n    'Failed building the serialization schema for %s: %s, due to error %s'\n  ),\n\n  /**\n   * wrapThenable\n   */\n  FST_ERR_PROMISE_NOT_FULFILLED: createError(\n    'FST_ERR_PROMISE_NOT_FULFILLED',\n    \"Promise may not be fulfilled with 'undefined' when statusCode is not 204\"\n  ),\n\n  /**\n   * http2\n   */\n  FST_ERR_HTTP2_INVALID_VERSION: createError(\n    'FST_ERR_HTTP2_INVALID_VERSION',\n    'HTTP2 is available only from node >= 8.8.1'\n  ),\n\n  /**\n   * initialConfig\n   */\n  FST_ERR_INIT_OPTS_INVALID: createError(\n    'FST_ERR_INIT_OPTS_INVALID',\n    \"Invalid initialization options: '%s'\"\n  ),\n\n  /**\n   * router\n   */\n  FST_ERR_BAD_URL: createError(\n    'FST_ERR_BAD_URL',\n    \"'%s' is not a valid url component\",\n    400\n  ),\n  FST_ERR_DEFAULT_ROUTE_INVALID_TYPE: createError(\n    'FST_ERR_DEFAULT_ROUTE_INVALID_TYPE',\n    'The defaultRoute type should be a function',\n    500,\n    TypeError\n  ),\n  FST_ERR_INVALID_URL: createError(\n    'FST_ERR_INVALID_URL',\n    \"URL must be a string. Received '%s'\",\n    400\n  ),\n\n  /**\n   *  again listen when close server\n   */\n  FST_ERR_REOPENED_CLOSE_SERVER: createError(\n    'FST_ERR_REOPENED_CLOSE_SERVER',\n    'Fastify has already been closed and cannot be reopened'\n  ),\n  FST_ERR_REOPENED_SERVER: createError(\n    'FST_ERR_REOPENED_SERVER',\n    'Fastify is already listening'\n  ),\n\n  /**\n   * plugin\n   */\n  FST_ERR_PLUGIN_VERSION_MISMATCH: createError(\n    'FST_ERR_PLUGIN_VERSION_MISMATCH',\n    \"fastify-plugin: %s - expected '%s' fastify version, '%s' is installed\"\n  )\n}\n\nmodule.exports = codes\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/errors.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/fourOhFour.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/fastify/lib/fourOhFour.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst FindMyWay = __webpack_require__(/*! find-my-way */ \"../../../node_modules/find-my-way/index.js\")\n\nconst Reply = __webpack_require__(/*! ./reply */ \"../../../node_modules/fastify/lib/reply.js\")\nconst Request = __webpack_require__(/*! ./request */ \"../../../node_modules/fastify/lib/request.js\")\nconst Context = __webpack_require__(/*! ./context */ \"../../../node_modules/fastify/lib/context.js\")\nconst {\n  kRoutePrefix,\n  kCanSetNotFoundHandler,\n  kFourOhFourLevelInstance,\n  kReply,\n  kRequest,\n  kContentTypeParser,\n  kBodyLimit,\n  kLogLevel,\n  kFourOhFourContext,\n  kHooks,\n  kErrorHandler\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\nconst { lifecycleHooks } = __webpack_require__(/*! ./hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\nconst fourOhFourContext = {\n  config: {\n  },\n  onSend: [],\n  onError: []\n}\n\n/**\n * Each fastify instance have a:\n * kFourOhFourLevelInstance: point to a fastify instance that has the 404 handler setted\n * kCanSetNotFoundHandler: bool to track if the 404 handler has already been set\n * kFourOhFour: the singleton instance of this 404 module\n * kFourOhFourContext: the context in the reply object where the handler will be executed\n */\nfunction fourOhFour (options) {\n  const { logger, genReqId } = options\n\n  // 404 router, used for handling encapsulated 404 handlers\n  const router = FindMyWay({ defaultRoute: fourOhFourFallBack })\n\n  return { router, setNotFoundHandler, setContext, arrange404 }\n\n  function arrange404 (instance) {\n    // Change the pointer of the fastify instance to itself, so register + prefix can add new 404 handler\n    instance[kFourOhFourLevelInstance] = instance\n    instance[kCanSetNotFoundHandler] = true\n  }\n\n  function basic404 (request, reply) {\n    const { url, method } = request.raw\n    const message = `Route ${method}:${url} not found`\n    request.log.info(message)\n    reply.code(404).send({\n      message,\n      error: 'Not Found',\n      statusCode: 404\n    })\n  }\n\n  function setContext (instance, context) {\n    const _404Context = Object.assign({}, instance[kFourOhFourContext])\n    _404Context.onSend = context.onSend\n    context[kFourOhFourContext] = _404Context\n  }\n\n  function setNotFoundHandler (opts, handler, avvio, routeHandler) {\n    // First initialization of the fastify root instance\n    if (this[kCanSetNotFoundHandler] === undefined) {\n      this[kCanSetNotFoundHandler] = true\n    }\n    if (this[kFourOhFourContext] === undefined) {\n      this[kFourOhFourContext] = null\n    }\n\n    const _fastify = this\n    const prefix = this[kRoutePrefix] || '/'\n\n    if (this[kCanSetNotFoundHandler] === false) {\n      throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`)\n    }\n\n    if (typeof opts === 'object') {\n      if (opts.preHandler) {\n        if (Array.isArray(opts.preHandler)) {\n          opts.preHandler = opts.preHandler.map(hook => hook.bind(_fastify))\n        } else {\n          opts.preHandler = opts.preHandler.bind(_fastify)\n        }\n      }\n\n      if (opts.preValidation) {\n        if (Array.isArray(opts.preValidation)) {\n          opts.preValidation = opts.preValidation.map(hook => hook.bind(_fastify))\n        } else {\n          opts.preValidation = opts.preValidation.bind(_fastify)\n        }\n      }\n    }\n\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = undefined\n    }\n    opts = opts || {}\n\n    if (handler) {\n      this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false\n      handler = handler.bind(this)\n    } else {\n      handler = basic404\n    }\n\n    this.after((notHandledErr, done) => {\n      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler)\n      done(notHandledErr)\n    })\n  }\n\n  function _setNotFoundHandler (prefix, opts, handler, avvio, routeHandler) {\n    const context = new Context(\n      opts.schema,\n      handler,\n      this[kReply],\n      this[kRequest],\n      this[kContentTypeParser],\n      opts.config || {},\n      this[kErrorHandler],\n      this[kBodyLimit],\n      this[kLogLevel]\n    )\n\n    avvio.once('preReady', () => {\n      const context = this[kFourOhFourContext]\n      for (const hook of lifecycleHooks) {\n        const toSet = this[kHooks][hook]\n          .concat(opts[hook] || [])\n          .map(h => h.bind(this))\n        context[hook] = toSet.length ? toSet : null\n      }\n    })\n\n    if (this[kFourOhFourContext] !== null && prefix === '/') {\n      Object.assign(this[kFourOhFourContext], context) // Replace the default 404 handler\n      return\n    }\n\n    this[kFourOhFourLevelInstance][kFourOhFourContext] = context\n\n    router.all(prefix + (prefix.endsWith('/') ? '*' : '/*'), routeHandler, context)\n    router.all(prefix, routeHandler, context)\n  }\n\n  function fourOhFourFallBack (req, res) {\n    // if this happen, we have a very bad bug\n    // we might want to do some hard debugging\n    // here, let's print out as much info as\n    // we can\n    const id = genReqId(req)\n    const childLogger = logger.child({ reqId: id })\n\n    childLogger.info({ req }, 'incoming request')\n\n    const request = new Request(id, null, req, null, childLogger, fourOhFourContext)\n    const reply = new Reply(res, request, childLogger)\n\n    request.log.warn('the default handler for 404 did not catch this, this is likely a fastify bug, please report it')\n    request.log.warn(router.prettyPrint())\n    reply.code(404).send(new Error('Not Found'))\n  }\n}\n\nmodule.exports = fourOhFour\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/fourOhFour.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/handleRequest.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/fastify/lib/handleRequest.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { validate: validateSchema } = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify/lib/validation.js\")\nconst { hookRunner, hookIterator } = __webpack_require__(/*! ./hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\nconst wrapThenable = __webpack_require__(/*! ./wrapThenable */ \"../../../node_modules/fastify/lib/wrapThenable.js\")\n\nconst { kReplyIsError } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nfunction handleRequest (err, request, reply) {\n  if (reply.sent === true) return\n  if (err != null) {\n    reply.send(err)\n    return\n  }\n\n  const method = request.raw.method\n  const headers = request.headers\n\n  if (method === 'GET' || method === 'HEAD') {\n    handler(request, reply)\n    return\n  }\n\n  const contentType = headers['content-type']\n\n  if (method === 'POST' || method === 'PUT' || method === 'PATCH') {\n    if (contentType === undefined) {\n      if (\n        headers['transfer-encoding'] === undefined &&\n        (headers['content-length'] === '0' || headers['content-length'] === undefined)\n      ) { // Request has no body to parse\n        handler(request, reply)\n      } else {\n        reply.context.contentTypeParser.run('', handler, request, reply)\n      }\n    } else {\n      reply.context.contentTypeParser.run(contentType, handler, request, reply)\n    }\n    return\n  }\n\n  if (method === 'OPTIONS' || method === 'DELETE') {\n    if (\n      contentType !== undefined &&\n      (\n        headers['transfer-encoding'] !== undefined ||\n        headers['content-length'] !== undefined\n      )\n    ) {\n      reply.context.contentTypeParser.run(contentType, handler, request, reply)\n    } else {\n      handler(request, reply)\n    }\n    return\n  }\n\n  // Return 404 instead of 405 see https://github.com/fastify/fastify/pull/862 for discussion\n  reply.code(404).send(new Error('Not Found'))\n}\n\nfunction handler (request, reply) {\n  try {\n    if (reply.context.preValidation !== null) {\n      hookRunner(\n        reply.context.preValidation,\n        hookIterator,\n        request,\n        reply,\n        preValidationCallback\n      )\n    } else {\n      preValidationCallback(null, request, reply)\n    }\n  } catch (err) {\n    preValidationCallback(err, request, reply)\n  }\n}\n\nfunction preValidationCallback (err, request, reply) {\n  if (reply.sent === true ||\n    reply.raw.writableEnded === true ||\n    reply.raw.writable === false) return\n\n  if (err != null) {\n    reply.send(err)\n    return\n  }\n\n  const result = validateSchema(reply.context, request)\n  if (result) {\n    if (reply.context.attachValidation === false) {\n      reply.code(400).send(result)\n      return\n    }\n\n    reply.request.validationError = result\n  }\n\n  // preHandler hook\n  if (reply.context.preHandler !== null) {\n    hookRunner(\n      reply.context.preHandler,\n      hookIterator,\n      request,\n      reply,\n      preHandlerCallback\n    )\n  } else {\n    preHandlerCallback(null, request, reply)\n  }\n}\n\nfunction preHandlerCallback (err, request, reply) {\n  if (reply.sent ||\n    reply.raw.writableEnded === true ||\n    reply.raw.writable === false) return\n\n  if (err != null) {\n    reply.send(err)\n    return\n  }\n\n  let result\n\n  try {\n    result = reply.context.handler(request, reply)\n  } catch (err) {\n    if (!(err instanceof Error)) {\n      reply[kReplyIsError] = true\n    }\n\n    reply.send(err)\n    return\n  }\n\n  if (result !== undefined) {\n    if (result !== null && typeof result.then === 'function') {\n      wrapThenable(result, reply)\n    } else {\n      reply.send(result)\n    }\n  }\n}\n\nmodule.exports = handleRequest\nmodule.exports[Symbol.for('internals')] = { handler, preHandlerCallback }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/handleRequest.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/headRoute.js":
/*!******************************************************!*\
  !*** ../../../node_modules/fastify/lib/headRoute.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction headRouteOnSendHandler (req, reply, payload, done) {\n  // If payload is undefined\n  if (payload === undefined) {\n    reply.header('content-length', '0')\n    return done(null, null)\n  }\n\n  if (typeof payload.resume === 'function') {\n    payload.on('error', (err) => {\n      reply.log.error({ err }, 'Error on Stream found for HEAD route')\n    })\n    payload.resume()\n    return done(null, null)\n  }\n\n  const size = '' + Buffer.byteLength(payload)\n\n  reply.header('content-length', size)\n\n  done(null, null)\n}\n\nfunction parseHeadOnSendHandlers (onSendHandlers) {\n  if (onSendHandlers == null) return headRouteOnSendHandler\n  return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler]\n}\n\nmodule.exports = {\n  parseHeadOnSendHandlers\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/headRoute.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/hooks.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fastify/lib/hooks.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst applicationHooks = [\n  'onRoute',\n  'onRegister',\n  'onReady',\n  'onClose'\n]\nconst lifecycleHooks = [\n  'onTimeout',\n  'onRequest',\n  'preParsing',\n  'preValidation',\n  'preSerialization',\n  'preHandler',\n  'onSend',\n  'onResponse',\n  'onError'\n]\nconst supportedHooks = lifecycleHooks.concat(applicationHooks)\nconst {\n  FST_ERR_HOOK_INVALID_TYPE,\n  FST_ERR_HOOK_INVALID_HANDLER,\n  FST_ERR_SEND_UNDEFINED_ERR\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nconst {\n  kReplyIsError,\n  kChildren,\n  kHooks\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nfunction Hooks () {\n  this.onRequest = []\n  this.preParsing = []\n  this.preValidation = []\n  this.preSerialization = []\n  this.preHandler = []\n  this.onResponse = []\n  this.onSend = []\n  this.onError = []\n  this.onRoute = []\n  this.onRegister = []\n  this.onReady = []\n  this.onTimeout = []\n}\n\nHooks.prototype.validate = function (hook, fn) {\n  if (typeof hook !== 'string') throw new FST_ERR_HOOK_INVALID_TYPE()\n  if (typeof fn !== 'function') throw new FST_ERR_HOOK_INVALID_HANDLER()\n  if (supportedHooks.indexOf(hook) === -1) {\n    throw new Error(`${hook} hook not supported!`)\n  }\n}\n\nHooks.prototype.add = function (hook, fn) {\n  this.validate(hook, fn)\n  this[hook].push(fn)\n}\n\nfunction buildHooks (h) {\n  const hooks = new Hooks()\n  hooks.onRequest = h.onRequest.slice()\n  hooks.preParsing = h.preParsing.slice()\n  hooks.preValidation = h.preValidation.slice()\n  hooks.preSerialization = h.preSerialization.slice()\n  hooks.preHandler = h.preHandler.slice()\n  hooks.onSend = h.onSend.slice()\n  hooks.onResponse = h.onResponse.slice()\n  hooks.onError = h.onError.slice()\n  hooks.onRoute = h.onRoute.slice()\n  hooks.onRegister = h.onRegister.slice()\n  hooks.onTimeout = h.onTimeout.slice()\n  hooks.onReady = []\n  return hooks\n}\n\nfunction hookRunnerApplication (hookName, boot, server, cb) {\n  const hooks = server[kHooks][hookName]\n  let i = 0\n  let c = 0\n\n  next()\n\n  function exit (err) {\n    if (err) {\n      cb(err)\n      return\n    }\n    cb()\n  }\n\n  function next (err) {\n    if (err) {\n      exit(err)\n      return\n    }\n\n    if (i === hooks.length && c === server[kChildren].length) {\n      if (i === 0 && c === 0) { // speed up start\n        exit()\n      } else {\n        // This is the last function executed for every fastify instance\n        boot(function manageTimeout (err, done) {\n          // this callback is needed by fastify to provide an hook interface without the error\n          // as first parameter and managing it on behalf the user\n          exit(err)\n\n          // this callback is needed by avvio to continue the loading of the next `register` plugins\n          done(err)\n        })\n      }\n      return\n    }\n\n    if (i === hooks.length && c < server[kChildren].length) {\n      const child = server[kChildren][c++]\n      hookRunnerApplication(hookName, boot, child, next)\n      return\n    }\n\n    boot(wrap(hooks[i++], server))\n    next()\n  }\n\n  function wrap (fn, server) {\n    return function (err, done) {\n      if (err) {\n        done(err)\n        return\n      }\n\n      if (fn.length === 1) {\n        try {\n          fn.call(server, done)\n        } catch (error) {\n          done(error)\n        }\n        return\n      }\n\n      const ret = fn.call(server)\n      if (ret && typeof ret.then === 'function') {\n        ret.then(done, done)\n        return\n      }\n\n      done(err) // auto done\n    }\n  }\n}\n\nfunction hookRunner (functions, runner, request, reply, cb) {\n  let i = 0\n\n  function next (err) {\n    if (err || i === functions.length) {\n      cb(err, request, reply)\n      return\n    }\n\n    let result\n    try {\n      result = runner(functions[i++], request, reply, next)\n    } catch (error) {\n      next(error)\n      return\n    }\n    if (result && typeof result.then === 'function') {\n      result.then(handleResolve, handleReject)\n    }\n  }\n\n  function handleResolve () {\n    next()\n  }\n\n  function handleReject (err) {\n    if (!err) {\n      err = new FST_ERR_SEND_UNDEFINED_ERR()\n    } else if (!(err instanceof Error)) {\n      reply[kReplyIsError] = true\n    }\n    cb(err, request, reply)\n  }\n\n  next()\n}\n\nfunction onSendHookRunner (functions, request, reply, payload, cb) {\n  let i = 0\n\n  function next (err, newPayload) {\n    if (err) {\n      cb(err, request, reply, payload)\n      return\n    }\n\n    if (newPayload !== undefined) {\n      payload = newPayload\n    }\n\n    if (i === functions.length) {\n      try {\n        cb(null, request, reply, payload)\n      } catch (err) {\n        handleReject(err)\n      }\n      return\n    }\n\n    let result\n    try {\n      result = functions[i++](request, reply, payload, next)\n    } catch (error) {\n      next(error)\n      return\n    }\n    if (result && typeof result.then === 'function') {\n      result.then(handleResolve, handleReject)\n    }\n  }\n\n  function handleResolve (newPayload) {\n    next(null, newPayload)\n  }\n\n  function handleReject (err) {\n    cb(err, request, reply, payload)\n  }\n\n  next()\n}\n\nfunction hookIterator (fn, request, reply, next) {\n  if (reply.sent === true) return undefined\n  return fn(request, reply, next)\n}\n\nmodule.exports = {\n  Hooks,\n  buildHooks,\n  hookRunner,\n  onSendHookRunner,\n  hookIterator,\n  hookRunnerApplication,\n  lifecycleHooks,\n  supportedHooks\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/hooks.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/initialConfigValidation.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/fastify/lib/initialConfigValidation.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst validate = __webpack_require__(/*! ./configValidator */ \"../../../node_modules/fastify/lib/configValidator.js\")\nconst deepClone = __webpack_require__(/*! rfdc */ \"../../../node_modules/rfdc/index.js\")({ circles: true, proto: false })\nconst { FST_ERR_INIT_OPTS_INVALID } = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nfunction validateInitialConfig (options) {\n  const opts = deepClone(options)\n\n  if (!validate(opts)) {\n    const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map(e => e.message)))\n    error.errors = validate.errors\n    throw error\n  }\n\n  return deepFreezeObject(opts)\n}\n\nfunction deepFreezeObject (object) {\n  const properties = Object.getOwnPropertyNames(object)\n\n  for (const name of properties) {\n    const value = object[name]\n\n    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {\n      continue\n    }\n\n    object[name] = value && typeof value === 'object' ? deepFreezeObject(value) : value\n  }\n\n  return Object.freeze(object)\n}\n\nmodule.exports = validateInitialConfig\nmodule.exports.defaultInitOptions = validate.defaultInitOptions\nmodule.exports.utils = { deepFreezeObject }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/initialConfigValidation.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/logger.js":
/*!***************************************************!*\
  !*** ../../../node_modules/fastify/lib/logger.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Code imported from `pino-http`\n * Repo: https://github.com/pinojs/pino-http\n * License: MIT (https://raw.githubusercontent.com/pinojs/pino-http/master/LICENSE)\n */\n\nconst nullLogger = __webpack_require__(/*! abstract-logging */ \"../../../node_modules/abstract-logging/index.js\")\nconst pino = __webpack_require__(/*! pino */ \"../../../node_modules/pino/pino.js\")\nconst { serializersSym } = pino.symbols\nconst { FST_ERR_LOG_INVALID_DESTINATION } = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nfunction createPinoLogger (opts, stream) {\n  stream = stream || opts.stream\n  delete opts.stream\n\n  if (stream && opts.file) {\n    throw new FST_ERR_LOG_INVALID_DESTINATION()\n  } else if (opts.file) {\n    // we do not have stream\n    stream = pino.destination(opts.file)\n    delete opts.file\n  }\n\n  const prevLogger = opts.logger\n  const prevGenReqId = opts.genReqId\n  let logger = null\n\n  if (prevLogger) {\n    opts.logger = undefined\n    opts.genReqId = undefined\n    // we need to tap into pino internals because in v5 it supports\n    // adding serializers in child loggers\n    if (prevLogger[serializersSym]) {\n      opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym])\n    }\n    logger = prevLogger.child({}, opts)\n    opts.logger = prevLogger\n    opts.genReqId = prevGenReqId\n  } else {\n    logger = pino(opts, stream)\n  }\n\n  return logger\n}\n\nconst serializers = {\n  req: function asReqValue (req) {\n    return {\n      method: req.method,\n      url: req.url,\n      version: req.headers && req.headers['accept-version'],\n      hostname: req.hostname,\n      remoteAddress: req.ip,\n      remotePort: req.socket ? req.socket.remotePort : undefined\n    }\n  },\n  err: pino.stdSerializers.err,\n  res: function asResValue (reply) {\n    return {\n      statusCode: reply.statusCode\n    }\n  }\n}\n\nfunction now () {\n  const ts = process.hrtime()\n  return (ts[0] * 1e3) + (ts[1] / 1e6)\n}\n\nfunction createLogger (options) {\n  if (isValidLogger(options.logger)) {\n    const logger = createPinoLogger({\n      logger: options.logger,\n      serializers: Object.assign({}, serializers, options.logger.serializers)\n    })\n    return { logger, hasLogger: true }\n  } else if (!options.logger) {\n    const logger = nullLogger\n    logger.child = () => logger\n    return { logger, hasLogger: false }\n  } else {\n    const localLoggerOptions = {}\n    if (Object.prototype.toString.call(options.logger) === '[object Object]') {\n      Reflect.ownKeys(options.logger).forEach(prop => {\n        Object.defineProperty(localLoggerOptions, prop, {\n          value: options.logger[prop],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        })\n      })\n    }\n    localLoggerOptions.level = localLoggerOptions.level || 'info'\n    localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers)\n    options.logger = localLoggerOptions\n    const logger = createPinoLogger(options.logger)\n    return { logger, hasLogger: true }\n  }\n}\n\nfunction isValidLogger (logger) {\n  if (!logger) {\n    return false\n  }\n\n  let result = true\n  const methods = ['info', 'error', 'debug', 'fatal', 'warn', 'trace', 'child']\n  for (let i = 0; i < methods.length; i += 1) {\n    if (!logger[methods[i]] || typeof logger[methods[i]] !== 'function') {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\nmodule.exports = {\n  createLogger,\n  serializers,\n  now\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/logger.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/noop-set.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/fastify/lib/noop-set.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function noopSet () {\n  return {\n    [Symbol.iterator]: function * () {},\n    add () {},\n    delete () {},\n    has () { return true }\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/noop-set.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/pluginOverride.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/fastify/lib/pluginOverride.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kAvvioBoot,\n  kChildren,\n  kRoutePrefix,\n  kLogLevel,\n  kLogSerializers,\n  kHooks,\n  kSchemaController,\n  kContentTypeParser,\n  kReply,\n  kRequest,\n  kFourOhFour,\n  kPluginNameChain\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst Reply = __webpack_require__(/*! ./reply */ \"../../../node_modules/fastify/lib/reply.js\")\nconst Request = __webpack_require__(/*! ./request */ \"../../../node_modules/fastify/lib/request.js\")\nconst SchemaController = __webpack_require__(/*! ./schema-controller */ \"../../../node_modules/fastify/lib/schema-controller.js\")\nconst ContentTypeParser = __webpack_require__(/*! ./contentTypeParser */ \"../../../node_modules/fastify/lib/contentTypeParser.js\")\nconst { buildHooks } = __webpack_require__(/*! ./hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\nconst pluginUtils = __webpack_require__(/*! ./pluginUtils */ \"../../../node_modules/fastify/lib/pluginUtils.js\")\n\n// Function that runs the encapsulation magic.\n// Everything that need to be encapsulated must be handled in this function.\nmodule.exports = function override (old, fn, opts) {\n  const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn)\n\n  if (shouldSkipOverride) {\n    // after every plugin registration we will enter a new name\n    old[kPluginNameChain].push(pluginUtils.getDisplayName(fn))\n    return old\n  }\n\n  const instance = Object.create(old)\n  old[kChildren].push(instance)\n  instance.ready = old[kAvvioBoot].bind(instance)\n  instance[kChildren] = []\n\n  instance[kReply] = Reply.buildReply(instance[kReply])\n  instance[kReply].prototype.server = instance\n\n  instance[kRequest] = Request.buildRequest(instance[kRequest])\n  instance[kRequest].prototype.server = instance\n\n  instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser])\n  instance[kHooks] = buildHooks(instance[kHooks])\n  instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix)\n  instance[kLogLevel] = opts.logLevel || instance[kLogLevel]\n  instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController])\n  instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController])\n  instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController])\n  instance[pluginUtils.registeredPlugins] = Object.create(instance[pluginUtils.registeredPlugins])\n  instance[kPluginNameChain] = [pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn)]\n\n  if (instance[kLogSerializers] || opts.logSerializers) {\n    instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers)\n  }\n\n  if (opts.prefix) {\n    instance[kFourOhFour].arrange404(instance)\n  }\n\n  for (const hook of instance[kHooks].onRegister) hook.call(this, instance, opts)\n\n  return instance\n}\n\nfunction buildRoutePrefix (instancePrefix, pluginPrefix) {\n  if (!pluginPrefix) {\n    return instancePrefix\n  }\n\n  // Ensure that there is a '/' between the prefixes\n  if (instancePrefix.endsWith('/') && pluginPrefix[0] === '/') {\n    // Remove the extra '/' to avoid: '/first//second'\n    pluginPrefix = pluginPrefix.slice(1)\n  } else if (pluginPrefix[0] !== '/') {\n    pluginPrefix = '/' + pluginPrefix\n  }\n\n  return instancePrefix + pluginPrefix\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/pluginOverride.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/pluginUtils.js":
/*!********************************************************!*\
  !*** ../../../node_modules/fastify/lib/pluginUtils.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst semver = __webpack_require__(/*! semver */ \"../../../node_modules/semver/index.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst registeredPlugins = Symbol.for('registered-plugin')\nconst {\n  kTestInternals\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\nconst { exist, existReply, existRequest } = __webpack_require__(/*! ./decorate */ \"../../../node_modules/fastify/lib/decorate.js\")\nconst { FST_ERR_PLUGIN_VERSION_MISMATCH } = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nfunction getMeta (fn) {\n  return fn[Symbol.for('plugin-meta')]\n}\n\nfunction getPluginName (func) {\n  const display = getDisplayName(func)\n  if (display) {\n    return display\n  }\n\n  // let's see if this is a file, and in that case use that\n  // this is common for plugins\n  const cache = __webpack_require__.c\n  const keys = Object.keys(cache)\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    if (cache[key].exports === func) {\n      return key\n    }\n  }\n\n  // if not maybe it's a named function, so use that\n  if (func.name) {\n    return func.name\n  }\n\n  return null\n}\n\nfunction getFuncPreview (func) {\n  // takes the first two lines of the function if nothing else works\n  return func.toString().split('\\n').slice(0, 2).map(s => s.trim()).join(' -- ')\n}\n\nfunction getDisplayName (fn) {\n  return fn[Symbol.for('fastify.display-name')]\n}\n\nfunction shouldSkipOverride (fn) {\n  return !!fn[Symbol.for('skip-override')]\n}\n\nfunction checkDependencies (fn) {\n  const meta = getMeta(fn)\n  if (!meta) return\n\n  const dependencies = meta.dependencies\n  if (!dependencies) return\n  assert(Array.isArray(dependencies), 'The dependencies should be an array of strings')\n\n  dependencies.forEach(dependency => {\n    assert(\n      this[registeredPlugins].indexOf(dependency) > -1,\n      `The dependency '${dependency}' of plugin '${meta.name}' is not registered`\n    )\n  })\n}\n\nfunction checkDecorators (fn) {\n  const meta = getMeta(fn)\n  if (!meta) return\n\n  const { decorators, name } = meta\n  if (!decorators) return\n\n  if (decorators.fastify) _checkDecorators(this, 'Fastify', decorators.fastify, name)\n  if (decorators.reply) _checkDecorators(this, 'Reply', decorators.reply, name)\n  if (decorators.request) _checkDecorators(this, 'Request', decorators.request, name)\n}\n\nconst checks = {\n  Fastify: exist,\n  Request: existRequest,\n  Reply: existReply\n}\n\nfunction _checkDecorators (that, instance, decorators, name) {\n  assert(Array.isArray(decorators), 'The decorators should be an array of strings')\n\n  decorators.forEach(decorator => {\n    const withPluginName = typeof name === 'string' ? ` required by '${name}'` : ''\n    if (!checks[instance].call(that, decorator)) {\n      throw new Error(`The decorator '${decorator}'${withPluginName} is not present in ${instance}`)\n    }\n  })\n}\n\nfunction checkVersion (fn) {\n  const meta = getMeta(fn)\n  if (!meta) return\n\n  const requiredVersion = meta.fastify\n  if (!requiredVersion) return\n\n  if (!semver.satisfies(this.version, requiredVersion)) throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version)\n}\n\nfunction registerPluginName (fn) {\n  const meta = getMeta(fn)\n  if (!meta) return\n\n  const name = meta.name\n  if (!name) return\n  this[registeredPlugins].push(name)\n}\n\nfunction registerPlugin (fn) {\n  registerPluginName.call(this, fn)\n  checkVersion.call(this, fn)\n  checkDecorators.call(this, fn)\n  checkDependencies.call(this, fn)\n  return shouldSkipOverride(fn)\n}\n\nmodule.exports = {\n  getPluginName,\n  getFuncPreview,\n  registeredPlugins,\n  getDisplayName,\n  registerPlugin\n}\n\nmodule.exports[kTestInternals] = {\n  shouldSkipOverride,\n  getMeta,\n  checkDecorators,\n  checkDependencies\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/pluginUtils.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/reply.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fastify/lib/reply.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst eos = (__webpack_require__(/*! stream */ \"stream\").finished)\nconst statusCodes = (__webpack_require__(/*! http */ \"http\").STATUS_CODES)\nconst flatstr = __webpack_require__(/*! flatstr */ \"../../../node_modules/flatstr/index.js\")\nconst FJS = __webpack_require__(/*! fast-json-stringify */ \"../../../node_modules/fast-json-stringify/index.js\")\nconst {\n  kSchemaResponse,\n  kFourOhFourContext,\n  kReplyErrorHandlerCalled,\n  kReplySent,\n  kReplySentOverwritten,\n  kReplyStartTime,\n  kReplyEndTime,\n  kReplySerializer,\n  kReplySerializerDefault,\n  kReplyIsError,\n  kReplyHeaders,\n  kReplyHasStatusCode,\n  kReplyIsRunningOnErrorHook,\n  kDisableRequestLogging\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\nconst { hookRunner, hookIterator, onSendHookRunner } = __webpack_require__(/*! ./hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\n\nconst internals = __webpack_require__(/*! ./handleRequest */ \"../../../node_modules/fastify/lib/handleRequest.js\")[Symbol.for('internals')]\nconst loggerUtils = __webpack_require__(/*! ./logger */ \"../../../node_modules/fastify/lib/logger.js\")\nconst now = loggerUtils.now\nconst wrapThenable = __webpack_require__(/*! ./wrapThenable */ \"../../../node_modules/fastify/lib/wrapThenable.js\")\n\nconst serializeError = FJS({\n  type: 'object',\n  properties: {\n    statusCode: { type: 'number' },\n    code: { type: 'string' },\n    error: { type: 'string' },\n    message: { type: 'string' }\n  }\n})\n\nconst CONTENT_TYPE = {\n  JSON: 'application/json; charset=utf-8',\n  PLAIN: 'text/plain; charset=utf-8',\n  OCTET: 'application/octet-stream'\n}\nconst {\n  FST_ERR_REP_INVALID_PAYLOAD_TYPE,\n  FST_ERR_REP_ALREADY_SENT,\n  FST_ERR_REP_SENT_VALUE,\n  FST_ERR_SEND_INSIDE_ONERR,\n  FST_ERR_BAD_STATUS_CODE\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\nconst warning = __webpack_require__(/*! ./warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\n\nfunction Reply (res, request, log) {\n  this.raw = res\n  this[kReplySent] = false\n  this[kReplySerializer] = null\n  this[kReplyErrorHandlerCalled] = false\n  this[kReplyIsError] = false\n  this[kReplyIsRunningOnErrorHook] = false\n  this.request = request\n  this[kReplyHeaders] = {}\n  this[kReplyHasStatusCode] = false\n  this[kReplyStartTime] = undefined\n  this.log = log\n}\nReply.props = []\n\nObject.defineProperties(Reply.prototype, {\n  context: {\n    get () {\n      return this.request.context\n    }\n  },\n  res: {\n    get () {\n      warning.emit('FSTDEP002')\n      return this.raw\n    }\n  },\n  sent: {\n    enumerable: true,\n    get () {\n      return this[kReplySent]\n    },\n    set (value) {\n      if (value !== true) {\n        throw new FST_ERR_REP_SENT_VALUE()\n      }\n\n      if (this[kReplySent]) {\n        throw new FST_ERR_REP_ALREADY_SENT()\n      }\n\n      this[kReplySentOverwritten] = true\n      this[kReplySent] = true\n    }\n  },\n  statusCode: {\n    get () {\n      return this.raw.statusCode\n    },\n    set (value) {\n      this.code(value)\n    }\n  },\n  server: {\n    value: null,\n    writable: true\n  }\n})\n\nReply.prototype.hijack = function () {\n  this[kReplySent] = true\n  return this\n}\n\nReply.prototype.send = function (payload) {\n  if (this[kReplyIsRunningOnErrorHook] === true) {\n    throw new FST_ERR_SEND_INSIDE_ONERR()\n  }\n\n  if (this[kReplySent]) {\n    this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT() }, 'Reply already sent')\n    return this\n  }\n\n  if (payload instanceof Error || this[kReplyIsError] === true) {\n    onErrorHook(this, payload, onSendHook)\n    return this\n  }\n\n  if (payload === undefined) {\n    onSendHook(this, payload)\n    return this\n  }\n\n  const contentType = this.getHeader('content-type')\n  const hasContentType = contentType !== undefined\n\n  if (payload !== null) {\n    if (Buffer.isBuffer(payload) || typeof payload.pipe === 'function') {\n      if (hasContentType === false) {\n        this[kReplyHeaders]['content-type'] = CONTENT_TYPE.OCTET\n      }\n      onSendHook(this, payload)\n      return this\n    }\n\n    if (hasContentType === false && typeof payload === 'string') {\n      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.PLAIN\n      onSendHook(this, payload)\n      return this\n    }\n  }\n\n  if (this[kReplySerializer] !== null) {\n    if (typeof payload !== 'string') {\n      preserializeHook(this, payload)\n      return this\n    } else {\n      payload = this[kReplySerializer](payload)\n    }\n\n  // The indexOf below also matches custom json mimetypes such as 'application/hal+json' or 'application/ld+json'\n  } else if (hasContentType === false || contentType.indexOf('json') > -1) {\n    if (hasContentType === false) {\n      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON\n    } else {\n      // If hasContentType === true, we have a JSON mimetype\n      if (contentType.indexOf('charset') === -1) {\n        // If we have simply application/json instead of a custom json mimetype\n        if (contentType.indexOf('/json') > -1) {\n          this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON\n        } else {\n          const currContentType = this[kReplyHeaders]['content-type']\n          // We extract the custom mimetype part (e.g. 'hal+' from 'application/hal+json')\n          const customJsonType = currContentType.substring(\n            currContentType.indexOf('/'),\n            currContentType.indexOf('json') + 4\n          )\n\n          // We ensure we set the header to the proper JSON content-type if necessary\n          // (e.g. 'application/hal+json' instead of 'application/json')\n          this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON.replace('/json', customJsonType)\n        }\n      }\n    }\n    if (typeof payload !== 'string') {\n      preserializeHook(this, payload)\n      return this\n    }\n  }\n\n  onSendHook(this, payload)\n\n  return this\n}\n\nReply.prototype.getHeader = function (key) {\n  key = key.toLowerCase()\n  const res = this.raw\n  let value = this[kReplyHeaders][key]\n  if (value === undefined && res.hasHeader(key)) {\n    value = res.getHeader(key)\n  }\n  return value\n}\n\nReply.prototype.getHeaders = function () {\n  return {\n    ...this.raw.getHeaders(),\n    ...this[kReplyHeaders]\n  }\n}\n\nReply.prototype.hasHeader = function (key) {\n  key = key.toLowerCase()\n  if (this[kReplyHeaders][key] !== undefined) {\n    return true\n  }\n  return this.raw.hasHeader(key)\n}\n\nReply.prototype.removeHeader = function (key) {\n  // Node.js does not like headers with keys set to undefined,\n  // so we have to delete the key.\n  delete this[kReplyHeaders][key.toLowerCase()]\n  return this\n}\n\nReply.prototype.header = function (key, value) {\n  const _key = key.toLowerCase()\n\n  // default the value to ''\n  value = value === undefined ? '' : value\n\n  if (this[kReplyHeaders][_key] && _key === 'set-cookie') {\n    // https://tools.ietf.org/html/rfc7230#section-3.2.2\n    if (typeof this[kReplyHeaders][_key] === 'string') {\n      this[kReplyHeaders][_key] = [this[kReplyHeaders][_key]]\n    }\n    if (Array.isArray(value)) {\n      Array.prototype.push.apply(this[kReplyHeaders][_key], value)\n    } else {\n      this[kReplyHeaders][_key].push(value)\n    }\n  } else {\n    this[kReplyHeaders][_key] = value\n  }\n  return this\n}\n\nReply.prototype.headers = function (headers) {\n  const keys = Object.keys(headers)\n  /* eslint-disable no-var */\n  for (var i = 0; i !== keys.length; ++i) {\n    const key = keys[i]\n    this.header(key, headers[key])\n  }\n  return this\n}\n\nReply.prototype.code = function (code) {\n  const intValue = parseInt(code)\n  if (isNaN(intValue) || intValue < 100 || intValue > 600) {\n    throw new FST_ERR_BAD_STATUS_CODE(code || String(code))\n  }\n\n  this.raw.statusCode = intValue\n  this[kReplyHasStatusCode] = true\n  return this\n}\n\nReply.prototype.status = Reply.prototype.code\n\nReply.prototype.serialize = function (payload) {\n  if (this[kReplySerializer] !== null) {\n    return this[kReplySerializer](payload)\n  } else {\n    if (this.context && this.context[kReplySerializerDefault]) {\n      return this.context[kReplySerializerDefault](payload, this.raw.statusCode)\n    } else {\n      return serialize(this.context, payload, this.raw.statusCode)\n    }\n  }\n}\n\nReply.prototype.serializer = function (fn) {\n  this[kReplySerializer] = fn\n  return this\n}\n\nReply.prototype.type = function (type) {\n  this[kReplyHeaders]['content-type'] = type\n  return this\n}\n\nReply.prototype.redirect = function (code, url) {\n  if (typeof code === 'string') {\n    url = code\n    code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302\n  }\n\n  this.header('location', url).code(code).send()\n}\n\nReply.prototype.callNotFound = function () {\n  notFound(this)\n}\n\nReply.prototype.getResponseTime = function () {\n  let responseTime = 0\n\n  if (this[kReplyStartTime] !== undefined) {\n    responseTime = (this[kReplyEndTime] || now()) - this[kReplyStartTime]\n  }\n\n  return responseTime\n}\n\n// Make reply a thenable, so it could be used with async/await.\n// See\n// - https://github.com/fastify/fastify/issues/1864 for the discussions\n// - https://promisesaplus.com/ for the definition of thenable\n// - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature\nReply.prototype.then = function (fulfilled, rejected) {\n  if (this.sent) {\n    fulfilled()\n    return\n  }\n\n  eos(this.raw, (err) => {\n    // We must not treat ERR_STREAM_PREMATURE_CLOSE as\n    // an error because it is created by eos, not by the stream.\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      if (rejected) {\n        rejected(err)\n      } else {\n        this.log && this.log.warn('unhandled rejection on reply.then')\n      }\n    } else {\n      fulfilled()\n    }\n  })\n}\n\nfunction preserializeHook (reply, payload) {\n  if (reply.context.preSerialization !== null) {\n    onSendHookRunner(\n      reply.context.preSerialization,\n      reply.request,\n      reply,\n      payload,\n      preserializeHookEnd\n    )\n  } else {\n    preserializeHookEnd(null, reply.request, reply, payload)\n  }\n}\n\nfunction preserializeHookEnd (err, request, reply, payload) {\n  if (err != null) {\n    onErrorHook(reply, err)\n    return\n  }\n\n  try {\n    if (reply[kReplySerializer] !== null) {\n      payload = reply[kReplySerializer](payload)\n    } else if (reply.context && reply.context[kReplySerializerDefault]) {\n      payload = reply.context[kReplySerializerDefault](payload, reply.raw.statusCode)\n    } else {\n      payload = serialize(reply.context, payload, reply.raw.statusCode)\n    }\n  } catch (e) {\n    wrapSeralizationError(e, reply)\n    onErrorHook(reply, e)\n    return\n  }\n\n  flatstr(payload)\n\n  onSendHook(reply, payload)\n}\n\nfunction wrapSeralizationError (error, reply) {\n  error.serialization = reply.context.config\n}\n\nfunction onSendHook (reply, payload) {\n  if (reply.context.onSend !== null) {\n    reply[kReplySent] = true\n    onSendHookRunner(\n      reply.context.onSend,\n      reply.request,\n      reply,\n      payload,\n      wrapOnSendEnd\n    )\n  } else {\n    onSendEnd(reply, payload)\n  }\n}\n\nfunction wrapOnSendEnd (err, request, reply, payload) {\n  if (err != null) {\n    onErrorHook(reply, err)\n  } else {\n    onSendEnd(reply, payload)\n  }\n}\n\nfunction onSendEnd (reply, payload) {\n  const res = reply.raw\n  const req = reply.request\n  const statusCode = res.statusCode\n\n  if (payload === undefined || payload === null) {\n    reply[kReplySent] = true\n\n    // according to https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // we cannot send a content-length for 304 and 204, and all status code\n    // < 200.\n    // For HEAD we don't overwrite the `content-length`\n    if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== 'HEAD') {\n      reply[kReplyHeaders]['content-length'] = '0'\n    }\n\n    res.writeHead(statusCode, reply[kReplyHeaders])\n    // avoid ArgumentsAdaptorTrampoline from V8\n    res.end(null, null, null)\n    return\n  }\n\n  if (typeof payload.pipe === 'function') {\n    reply[kReplySent] = true\n\n    sendStream(payload, res, reply)\n    return\n  }\n\n  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {\n    throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload)\n  }\n\n  if (!reply[kReplyHeaders]['content-length']) {\n    reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload)\n  } else if (req.raw.method !== 'HEAD' && reply[kReplyHeaders]['content-length'] !== Buffer.byteLength(payload)) {\n    reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload)\n  }\n\n  reply[kReplySent] = true\n\n  res.writeHead(statusCode, reply[kReplyHeaders])\n\n  // avoid ArgumentsAdaptorTrampoline from V8\n  res.end(payload, null, null)\n}\n\nfunction logStreamError (logger, err, res) {\n  if (err.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n    if (!logger[kDisableRequestLogging]) {\n      logger.info({ res }, 'stream closed prematurely')\n    }\n  } else {\n    logger.warn({ err }, 'response terminated with an error with headers already sent')\n  }\n}\n\nfunction sendStream (payload, res, reply) {\n  let sourceOpen = true\n  let errorLogged = false\n\n  eos(payload, { readable: true, writable: false }, function (err) {\n    sourceOpen = false\n    if (err != null) {\n      if (res.headersSent) {\n        if (!errorLogged) {\n          errorLogged = true\n          logStreamError(reply.log, err, res)\n        }\n        res.destroy()\n      } else {\n        onErrorHook(reply, err)\n      }\n    }\n    // there is nothing to do if there is not an error\n  })\n\n  eos(res, function (err) {\n    if (sourceOpen) {\n      if (err != null && res.headersSent && !errorLogged) {\n        errorLogged = true\n        logStreamError(reply.log, err, res)\n      }\n      if (typeof payload.destroy === 'function') {\n        payload.destroy()\n      } else if (typeof payload.close === 'function') {\n        payload.close(noop)\n      } else if (typeof payload.abort === 'function') {\n        payload.abort()\n      } else {\n        reply.log.warn('stream payload does not end properly')\n      }\n    }\n  })\n\n  // streams will error asynchronously, and we want to handle that error\n  // appropriately, e.g. a 404 for a missing file. So we cannot use\n  // writeHead, and we need to resort to setHeader, which will trigger\n  // a writeHead when there is data to send.\n  if (!res.headersSent) {\n    for (const key in reply[kReplyHeaders]) {\n      res.setHeader(key, reply[kReplyHeaders][key])\n    }\n  } else {\n    reply.log.warn('response will send, but you shouldn\\'t use res.writeHead in stream mode')\n  }\n  payload.pipe(res)\n}\n\nfunction onErrorHook (reply, error, cb) {\n  reply[kReplySent] = true\n  if (reply.context.onError !== null && reply[kReplyErrorHandlerCalled] === true) {\n    reply[kReplyIsRunningOnErrorHook] = true\n    onSendHookRunner(\n      reply.context.onError,\n      reply.request,\n      reply,\n      error,\n      () => handleError(reply, error, cb)\n    )\n  } else {\n    handleError(reply, error, cb)\n  }\n}\n\nfunction handleError (reply, error, cb) {\n  reply[kReplyIsRunningOnErrorHook] = false\n  const res = reply.raw\n  let statusCode = res.statusCode\n  statusCode = (statusCode >= 400) ? statusCode : 500\n  // treat undefined and null as same\n  if (error != null) {\n    if (error.headers !== undefined) {\n      reply.headers(error.headers)\n    }\n    if (error.status >= 400) {\n      statusCode = error.status\n    } else if (error.statusCode >= 400) {\n      statusCode = error.statusCode\n    }\n  }\n\n  res.statusCode = statusCode\n\n  const errorHandler = reply.context.errorHandler\n  if (errorHandler && reply[kReplyErrorHandlerCalled] === false) {\n    reply[kReplySent] = false\n    reply[kReplyIsError] = false\n    reply[kReplyErrorHandlerCalled] = true\n    // remove header is needed in here, because when we pipe to a stream\n    // `undefined` value header will directly passed to node response\n    reply.removeHeader('content-length')\n    const result = errorHandler(error, reply.request, reply)\n    if (result !== undefined) {\n      if (result !== null && typeof result.then === 'function') {\n        wrapThenable(result, reply)\n      } else {\n        reply.send(result)\n      }\n    }\n    return\n  }\n\n  let payload\n  try {\n    const serializerFn = getSchemaSerializer(reply.context, statusCode)\n    payload = (serializerFn === false)\n      ? serializeError({\n          error: statusCodes[statusCode + ''],\n          code: error.code,\n          message: error.message || '',\n          statusCode: statusCode\n        })\n      : serializerFn(Object.create(error, {\n        error: { value: statusCodes[statusCode + ''] },\n        message: { value: error.message || '' },\n        statusCode: { value: statusCode }\n      }))\n\n    if (serializerFn !== false && typeof payload !== 'string') {\n      throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload)\n    }\n  } catch (err) {\n    // error is always FST_ERR_SCH_SERIALIZATION_BUILD because this is called from route/compileSchemasForSerialization\n    reply.log.error({ err, statusCode: res.statusCode }, 'The serializer for the given status code failed')\n    res.statusCode = 500\n    payload = serializeError({\n      error: statusCodes['500'],\n      code: err.code,\n      message: err.message,\n      statusCode: 500\n    })\n  }\n\n  flatstr(payload)\n  reply[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON\n  reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload)\n\n  if (cb) {\n    cb(reply, payload)\n    return\n  }\n\n  reply[kReplySent] = true\n  res.writeHead(res.statusCode, reply[kReplyHeaders])\n  res.end(payload)\n}\n\nfunction setupResponseListeners (reply) {\n  reply[kReplyStartTime] = now()\n\n  const onResFinished = err => {\n    reply[kReplyEndTime] = now()\n    reply.raw.removeListener('finish', onResFinished)\n    reply.raw.removeListener('error', onResFinished)\n\n    const ctx = reply.context\n\n    if (ctx && ctx.onResponse !== null) {\n      hookRunner(\n        ctx.onResponse,\n        onResponseIterator,\n        reply.request,\n        reply,\n        onResponseCallback\n      )\n    } else {\n      onResponseCallback(err, reply.request, reply)\n    }\n  }\n\n  reply.raw.on('finish', onResFinished)\n  reply.raw.on('error', onResFinished)\n}\n\nfunction onResponseIterator (fn, request, reply, next) {\n  return fn(request, reply, next)\n}\n\nfunction onResponseCallback (err, request, reply) {\n  if (reply.log[kDisableRequestLogging]) {\n    return\n  }\n\n  const responseTime = reply.getResponseTime()\n\n  if (err != null) {\n    reply.log.error({\n      res: reply,\n      err,\n      responseTime\n    }, 'request errored')\n    return\n  }\n\n  reply.log.info({\n    res: reply,\n    responseTime\n  }, 'request completed')\n}\n\nfunction buildReply (R) {\n  const props = [...R.props]\n\n  function _Reply (res, request, log) {\n    this.raw = res\n    this[kReplyIsError] = false\n    this[kReplyErrorHandlerCalled] = false\n    this[kReplySent] = false\n    this[kReplySentOverwritten] = false\n    this[kReplySerializer] = null\n    this.request = request\n    this[kReplyHeaders] = {}\n    this[kReplyStartTime] = undefined\n    this[kReplyEndTime] = undefined\n    this.log = log\n\n    // eslint-disable-next-line no-var\n    var prop\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < props.length; i++) {\n      prop = props[i]\n      this[prop.key] = prop.value\n    }\n  }\n  _Reply.prototype = new R()\n  _Reply.props = props\n  return _Reply\n}\n\nfunction notFound (reply) {\n  reply[kReplySent] = false\n  reply[kReplyIsError] = false\n\n  if (reply.context[kFourOhFourContext] === null) {\n    reply.log.warn('Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.')\n    reply.code(404).send('404 Not Found')\n    return\n  }\n\n  reply.request.context = reply.context[kFourOhFourContext]\n\n  // preHandler hook\n  if (reply.context.preHandler !== null) {\n    hookRunner(\n      reply.context.preHandler,\n      hookIterator,\n      reply.request,\n      reply,\n      internals.preHandlerCallback\n    )\n  } else {\n    internals.preHandlerCallback(null, reply.request, reply)\n  }\n}\n\n/**\n * This function runs when a payload that is not a string|buffer|stream or null\n * should be serialized to be streamed to the response.\n * This is the default serializer that can be customized by the user using the replySerializer\n *\n * @param {object} context the request context\n * @param {object} data the JSON payload to serialize\n * @param {number} statusCode the http status code\n * @returns {string} the serialized payload\n */\nfunction serialize (context, data, statusCode) {\n  const fnSerialize = getSchemaSerializer(context, statusCode)\n  if (fnSerialize) {\n    return fnSerialize(data)\n  }\n  return JSON.stringify(data)\n}\n\n/**\n * Search for the right JSON schema compiled function in the request context\n * setup by the route configuration `schema.response`.\n * It will look for the exact match (eg 200) or generic (eg 2xx)\n *\n * @param {object} context the request context\n * @param {number} statusCode the http status code\n * @returns {function|boolean} the right JSON Schema function to serialize\n * the reply or false if it is not set\n */\nfunction getSchemaSerializer (context, statusCode) {\n  const responseSchemaDef = context[kSchemaResponse]\n  if (!responseSchemaDef) {\n    return false\n  }\n  if (responseSchemaDef[statusCode]) {\n    return responseSchemaDef[statusCode]\n  }\n  const fallbackStatusCode = (statusCode + '')[0] + 'xx'\n  if (responseSchemaDef[fallbackStatusCode]) {\n    return responseSchemaDef[fallbackStatusCode]\n  }\n  return false\n}\n\nfunction noop () { }\n\nmodule.exports = Reply\nmodule.exports.buildReply = buildReply\nmodule.exports.setupResponseListeners = setupResponseListeners\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/reply.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/reqIdGenFactory.js":
/*!************************************************************!*\
  !*** ../../../node_modules/fastify/lib/reqIdGenFactory.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function () {\n  // 2,147,483,647 (2^31 − 1) stands for max SMI value (an internal optimization of V8).\n  // With this upper bound, if you'll be generating 1k ids/sec, you're going to hit it in ~25 days.\n  // This is very likely to happen in real-world applications, hence the limit is enforced.\n  // Growing beyond this value will make the id generation slower and cause a deopt.\n  // In the worst cases, it will become a float, losing accuracy.\n  const maxInt = 2147483647\n  let nextReqId = 0\n  return function genReqId (req) {\n    nextReqId = (nextReqId + 1) & maxInt\n    return `req-${nextReqId.toString(36)}`\n  }\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/reqIdGenFactory.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/request.js":
/*!****************************************************!*\
  !*** ../../../node_modules/fastify/lib/request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst proxyAddr = __webpack_require__(/*! proxy-addr */ \"../../../node_modules/proxy-addr/index.js\")\nconst semver = __webpack_require__(/*! semver */ \"../../../node_modules/semver/index.js\")\nconst warning = __webpack_require__(/*! ./warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\n\nfunction Request (id, params, req, query, log, context) {\n  this.id = id\n  this.context = context\n  this.params = params\n  this.raw = req\n  this.query = query\n  this.log = log\n  this.body = null\n}\nRequest.props = []\n\nfunction getTrustProxyFn (tp) {\n  if (typeof tp === 'function') {\n    return tp\n  }\n  if (tp === true) {\n    // Support plain true/false\n    return function () { return true }\n  }\n  if (typeof tp === 'number') {\n    // Support trusting hop count\n    return function (a, i) { return i < tp }\n  }\n  if (typeof tp === 'string') {\n    // Support comma-separated tps\n    const vals = tp.split(',').map(it => it.trim())\n    return proxyAddr.compile(vals)\n  }\n  return proxyAddr.compile(tp)\n}\n\nfunction buildRequest (R, trustProxy) {\n  if (trustProxy) {\n    return buildRequestWithTrustProxy(R, trustProxy)\n  }\n\n  return buildRegularRequest(R)\n}\n\nfunction buildRegularRequest (R) {\n  const props = [...R.props]\n  function _Request (id, params, req, query, log, context) {\n    this.id = id\n    this.context = context\n    this.params = params\n    this.raw = req\n    this.query = query\n    this.log = log\n    this.body = null\n\n    // eslint-disable-next-line no-var\n    var prop\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < props.length; i++) {\n      prop = props[i]\n      this[prop.key] = prop.value\n    }\n  }\n  _Request.prototype = new R()\n  _Request.props = props\n\n  return _Request\n}\n\nfunction getLastEntryInMultiHeaderValue (headerValue) {\n  // we use the last one if the header is set more than once\n  const lastIndex = headerValue.lastIndexOf(',')\n  return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim()\n}\n\nfunction buildRequestWithTrustProxy (R, trustProxy) {\n  const _Request = buildRegularRequest(R)\n  const proxyFn = getTrustProxyFn(trustProxy)\n\n  Object.defineProperties(_Request.prototype, {\n    ip: {\n      get () {\n        return proxyAddr(this.raw, proxyFn)\n      }\n    },\n    ips: {\n      get () {\n        return proxyAddr.all(this.raw, proxyFn)\n      }\n    },\n    hostname: {\n      get () {\n        if (this.ip !== undefined && this.headers['x-forwarded-host']) {\n          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-host'])\n        }\n        return this.headers.host || this.headers[':authority']\n      }\n    },\n    protocol: {\n      get () {\n        if (this.headers['x-forwarded-proto']) {\n          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-proto'])\n        }\n        if (this.socket) {\n          return this.socket.encrypted ? 'https' : 'http'\n        }\n      }\n    }\n  })\n\n  return _Request\n}\n\nObject.defineProperties(Request.prototype, {\n  req: {\n    get () {\n      warning.emit('FSTDEP001')\n      return this.raw\n    }\n  },\n  url: {\n    get () {\n      return this.raw.url\n    }\n  },\n  method: {\n    get () {\n      return this.raw.method\n    }\n  },\n  routerPath: {\n    get () {\n      return this.context.config.url\n    }\n  },\n  routerMethod: {\n    get () {\n      return this.context.config.method\n    }\n  },\n  is404: {\n    get () {\n      return this.context.config.url === undefined\n    }\n  },\n  connection: {\n    get () {\n      /* istanbul ignore next */\n      if (semver.gte(process.versions.node, '13.0.0')) {\n        warning.emit('FSTDEP005')\n      }\n      return this.raw.connection\n    }\n  },\n  socket: {\n    get () {\n      return this.raw.socket\n    }\n  },\n  ip: {\n    get () {\n      if (this.socket) {\n        return this.socket.remoteAddress\n      }\n    }\n  },\n  hostname: {\n    get () {\n      return this.raw.headers.host || this.raw.headers[':authority']\n    }\n  },\n  protocol: {\n    get () {\n      if (this.socket) {\n        return this.socket.encrypted ? 'https' : 'http'\n      }\n    }\n  },\n  headers: {\n    get () {\n      if (this.additionalHeaders) {\n        return Object.assign({}, this.raw.headers, this.additionalHeaders)\n      }\n      return this.raw.headers\n    },\n    set (headers) {\n      this.additionalHeaders = headers\n    }\n  },\n  server: {\n    value: null,\n    writable: true\n  }\n})\n\nmodule.exports = Request\nmodule.exports.buildRequest = buildRequest\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/request.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/route.js":
/*!**************************************************!*\
  !*** ../../../node_modules/fastify/lib/route.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst FindMyWay = __webpack_require__(/*! find-my-way */ \"../../../node_modules/find-my-way/index.js\")\nconst Context = __webpack_require__(/*! ./context */ \"../../../node_modules/fastify/lib/context.js\")\nconst handleRequest = __webpack_require__(/*! ./handleRequest */ \"../../../node_modules/fastify/lib/handleRequest.js\")\nconst { hookRunner, hookIterator, lifecycleHooks } = __webpack_require__(/*! ./hooks */ \"../../../node_modules/fastify/lib/hooks.js\")\nconst supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS']\nconst { normalizeSchema } = __webpack_require__(/*! ./schemas */ \"../../../node_modules/fastify/lib/schemas.js\")\nconst { parseHeadOnSendHandlers } = __webpack_require__(/*! ./headRoute */ \"../../../node_modules/fastify/lib/headRoute.js\")\nconst warning = __webpack_require__(/*! ./warnings */ \"../../../node_modules/fastify/lib/warnings.js\")\nconst { kRequestAcceptVersion } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst {\n  compileSchemasForValidation,\n  compileSchemasForSerialization\n} = __webpack_require__(/*! ./validation */ \"../../../node_modules/fastify/lib/validation.js\")\n\nconst {\n  FST_ERR_SCH_VALIDATION_BUILD,\n  FST_ERR_SCH_SERIALIZATION_BUILD,\n  FST_ERR_DEFAULT_ROUTE_INVALID_TYPE,\n  FST_ERR_INVALID_URL\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nconst {\n  kRoutePrefix,\n  kLogLevel,\n  kLogSerializers,\n  kHooks,\n  kHooksDeprecatedPreParsing,\n  kSchemaController,\n  kOptions,\n  kContentTypeParser,\n  kReply,\n  kReplySerializerDefault,\n  kReplyIsError,\n  kRequest,\n  kRequestPayloadStream,\n  kDisableRequestLogging,\n  kSchemaErrorFormatter,\n  kErrorHandler\n} = __webpack_require__(/*! ./symbols.js */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nfunction buildRouting (options) {\n  const { keepAliveConnections } = options\n  const router = FindMyWay(options.config)\n\n  let avvio\n  let fourOhFour\n  let requestIdHeader\n  let querystringParser\n  let requestIdLogLabel\n  let logger\n  let hasLogger\n  let setupResponseListeners\n  let throwIfAlreadyStarted\n  let genReqId\n  let disableRequestLogging\n  let ignoreTrailingSlash\n  let return503OnClosing\n  let globalExposeHeadRoutes\n\n  let closing = false\n\n  return {\n    setup (options, fastifyArgs) {\n      avvio = fastifyArgs.avvio\n      fourOhFour = fastifyArgs.fourOhFour\n      logger = fastifyArgs.logger\n      hasLogger = fastifyArgs.hasLogger\n      setupResponseListeners = fastifyArgs.setupResponseListeners\n      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted\n\n      globalExposeHeadRoutes = options.exposeHeadRoutes\n      requestIdHeader = options.requestIdHeader\n      querystringParser = options.querystringParser\n      requestIdLogLabel = options.requestIdLogLabel\n      genReqId = options.genReqId\n      disableRequestLogging = options.disableRequestLogging\n      ignoreTrailingSlash = options.ignoreTrailingSlash\n      return503OnClosing = Object.prototype.hasOwnProperty.call(options, 'return503OnClosing') ? options.return503OnClosing : true\n    },\n    routing: router.lookup.bind(router), // router func to find the right handler to call\n    route, // configure a route in the fastify instance\n    prepareRoute,\n    getDefaultRoute: function () {\n      return router.defaultRoute\n    },\n    setDefaultRoute: function (defaultRoute) {\n      if (typeof defaultRoute !== 'function') {\n        throw new FST_ERR_DEFAULT_ROUTE_INVALID_TYPE()\n      }\n\n      router.defaultRoute = defaultRoute\n    },\n    routeHandler,\n    closeRoutes: () => { closing = true },\n    printRoutes: router.prettyPrint.bind(router)\n  }\n\n  // Convert shorthand to extended route declaration\n  function prepareRoute (method, url, options, handler) {\n    if (typeof url !== 'string') {\n      throw new FST_ERR_INVALID_URL(typeof url)\n    }\n\n    if (!handler && typeof options === 'function') {\n      handler = options // for support over direct function calls such as fastify.get() options are reused as the handler\n      options = {}\n    } else if (handler && typeof handler === 'function') {\n      if (Object.prototype.toString.call(options) !== '[object Object]') {\n        throw new Error(`Options for ${method}:${url} route must be an object`)\n      } else if (options.handler) {\n        if (typeof options.handler === 'function') {\n          throw new Error(`Duplicate handler for ${method}:${url} route is not allowed!`)\n        } else {\n          throw new Error(`Handler for ${method}:${url} route must be a function`)\n        }\n      }\n    }\n\n    options = Object.assign({}, options, {\n      method,\n      url,\n      path: url,\n      handler: handler || (options && options.handler)\n    })\n\n    return route.call(this, options)\n  }\n\n  // Route management\n  function route (options) {\n    // Since we are mutating/assigning only top level props, it is fine to have a shallow copy using the spread operator\n    const opts = { ...options }\n\n    throwIfAlreadyStarted('Cannot add route when fastify instance is already started!')\n\n    if (Array.isArray(opts.method)) {\n      // eslint-disable-next-line no-var\n      for (var i = 0; i < opts.method.length; ++i) {\n        const method = opts.method[i]\n        if (supportedMethods.indexOf(method) === -1) {\n          throw new Error(`${method} method is not supported!`)\n        }\n      }\n    } else {\n      if (supportedMethods.indexOf(opts.method) === -1) {\n        throw new Error(`${opts.method} method is not supported!`)\n      }\n    }\n\n    const path = opts.url || opts.path\n\n    if (!opts.handler) {\n      throw new Error(`Missing handler function for ${opts.method}:${path} route.`)\n    }\n\n    if (opts.errorHandler !== undefined && typeof opts.errorHandler !== 'function') {\n      throw new Error(`Error Handler for ${opts.method}:${path} route, if defined, must be a function`)\n    }\n\n    validateBodyLimitOption(opts.bodyLimit)\n\n    const prefix = this[kRoutePrefix]\n\n    this.after((notHandledErr, done) => {\n      if (path === '/' && prefix.length && opts.method !== 'HEAD') {\n        switch (opts.prefixTrailingSlash) {\n          case 'slash':\n            afterRouteAdded.call(this, { path }, notHandledErr, done)\n            break\n          case 'no-slash':\n            afterRouteAdded.call(this, { path: '' }, notHandledErr, done)\n            break\n          case 'both':\n          default:\n            afterRouteAdded.call(this, { path: '' }, notHandledErr, done)\n            // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.\n            if (ignoreTrailingSlash !== true) {\n              afterRouteAdded.call(this, { path, prefixing: true }, notHandledErr, done)\n            }\n        }\n      } else if (path && path[0] === '/' && prefix.endsWith('/')) {\n        // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'\n        afterRouteAdded.call(this, { path: path.slice(1) }, notHandledErr, done)\n      } else {\n        afterRouteAdded.call(this, { path }, notHandledErr, done)\n      }\n    })\n\n    // chainable api\n    return this\n\n    /**\n     * This function sets up a new route, its log serializers, and triggers route hooks.\n     *\n     * @param {object} opts contains route `path` and `prefixing` flag which indicates if this is an auto-prefixed route, e.g. `fastify.register(routes, { prefix: '/foo' })`\n     * @param {*} notHandledErr error object to be passed back to the original invoker\n     * @param {*} done callback\n     */\n    function afterRouteAdded ({ path, prefixing = false }, notHandledErr, done) {\n      const url = prefix + path\n\n      opts.url = url\n      opts.path = url\n      opts.routePath = path\n      opts.prefix = prefix\n      opts.logLevel = opts.logLevel || this[kLogLevel]\n\n      if (this[kLogSerializers] || opts.logSerializers) {\n        opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers)\n      }\n\n      if (opts.attachValidation == null) {\n        opts.attachValidation = false\n      }\n\n      if (prefixing === false) {\n      // run 'onRoute' hooks\n        for (const hook of this[kHooks].onRoute) {\n          try {\n            hook.call(this, opts)\n          } catch (error) {\n            done(error)\n            return\n          }\n        }\n      }\n\n      const config = {\n        ...opts.config,\n        url,\n        method: opts.method\n      }\n      const constraints = opts.constraints || {}\n      if (opts.version) {\n        warning.emit('FSTDEP008')\n        constraints.version = opts.version\n      }\n\n      const context = new Context(\n        opts.schema,\n        opts.handler.bind(this),\n        this[kReply],\n        this[kRequest],\n        this[kContentTypeParser],\n        config,\n        opts.errorHandler || this[kErrorHandler],\n        opts.bodyLimit,\n        opts.logLevel,\n        opts.logSerializers,\n        opts.attachValidation,\n        this[kReplySerializerDefault],\n        opts.schemaErrorFormatter || this[kSchemaErrorFormatter]\n      )\n\n      const headRouteExists = router.find('HEAD', url, constraints) != null\n\n      try {\n        router.on(opts.method, opts.url, { constraints }, routeHandler, context)\n      } catch (err) {\n        done(err)\n        return\n      }\n\n      const { exposeHeadRoute } = opts\n      const hasRouteExposeHeadRouteFlag = exposeHeadRoute != null\n      const shouldExposeHead = hasRouteExposeHeadRouteFlag ? exposeHeadRoute : globalExposeHeadRoutes\n\n      if (shouldExposeHead && options.method === 'GET' && !headRouteExists) {\n        const onSendHandlers = parseHeadOnSendHandlers(opts.onSend)\n        prepareRoute.call(this, 'HEAD', path, { ...opts, onSend: onSendHandlers })\n      } else if (headRouteExists && exposeHeadRoute) {\n        warning.emit('FSTDEP007')\n      }\n\n      // It can happen that a user registers a plugin with some hooks *after*\n      // the route registration. To be sure to also load those hooks,\n      // we must listen for the avvio's preReady event, and update the context object accordingly.\n      avvio.once('preReady', () => {\n        for (const hook of lifecycleHooks) {\n          const toSet = this[kHooks][hook]\n            .concat(opts[hook] || [])\n            .map(h => {\n              const bound = h.bind(this)\n\n              // Track hooks deprecation markers\n              if (hook === 'preParsing') {\n                // Check for deprecation syntax\n                if (h.length === (h.constructor.name === 'AsyncFunction' ? 2 : 3)) {\n                  warning.emit('FSTDEP004')\n                  bound[kHooksDeprecatedPreParsing] = true\n                }\n              }\n\n              return bound\n            })\n          context[hook] = toSet.length ? toSet : null\n        }\n\n        // Must store the 404 Context in 'preReady' because it is only guaranteed to\n        // be available after all of the plugins and routes have been loaded.\n        fourOhFour.setContext(this, context)\n\n        if (opts.schema) {\n          context.schema = normalizeSchema(context.schema, this.initialConfig)\n\n          const schemaController = this[kSchemaController]\n          if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {\n            schemaController.setupValidator(this[kOptions])\n          }\n          try {\n            compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler)\n          } catch (error) {\n            throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message)\n          }\n\n          if (opts.schema.response && !opts.serializerCompiler) {\n            schemaController.setupSerializer(this[kOptions])\n          }\n          try {\n            compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler)\n          } catch (error) {\n            throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message)\n          }\n        }\n      })\n\n      done(notHandledErr)\n    }\n  }\n\n  // HTTP request entry point, the routing has already been executed\n  function routeHandler (req, res, params, context) {\n    if (closing === true) {\n      /* istanbul ignore next mac, windows */\n      if (req.httpVersionMajor !== 2) {\n        res.once('finish', () => req.destroy())\n        res.setHeader('Connection', 'close')\n      }\n\n      if (return503OnClosing) {\n        const headers = {\n          'Content-Type': 'application/json',\n          'Content-Length': '80'\n        }\n        res.writeHead(503, headers)\n        res.end('{\"error\":\"Service Unavailable\",\"message\":\"Service Unavailable\",\"statusCode\":503}')\n        return\n      }\n    }\n\n    // When server.forceCloseConnections is true, we will collect any requests\n    // that have indicated they want persistence so that they can be reaped\n    // on server close. Otherwise, the container is a noop container.\n    const connHeader = String.prototype.toLowerCase.call(req.headers.connection || '')\n    if (connHeader === 'keep-alive') {\n      if (keepAliveConnections.has(req.socket) === false) {\n        keepAliveConnections.add(req.socket)\n        req.socket.on('close', removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }))\n      }\n    }\n\n    // we revert the changes in defaultRoute\n    if (req.headers[kRequestAcceptVersion] !== undefined) {\n      req.headers['accept-version'] = req.headers[kRequestAcceptVersion]\n      req.headers[kRequestAcceptVersion] = undefined\n    }\n\n    const id = req.headers[requestIdHeader] || genReqId(req)\n\n    const loggerBinding = {\n      [requestIdLogLabel]: id\n    }\n\n    const loggerOpts = {\n      level: context.logLevel\n    }\n\n    if (context.logSerializers) {\n      loggerOpts.serializers = context.logSerializers\n    }\n    const childLogger = logger.child(loggerBinding, loggerOpts)\n    childLogger[kDisableRequestLogging] = disableRequestLogging\n\n    const queryPrefix = req.url.indexOf('?')\n    const query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : '')\n    const request = new context.Request(id, params, req, query, childLogger, context)\n    const reply = new context.Reply(res, request, childLogger)\n\n    if (disableRequestLogging === false) {\n      childLogger.info({ req: request }, 'incoming request')\n    }\n\n    if (hasLogger === true || context.onResponse !== null) {\n      setupResponseListeners(reply)\n    }\n\n    if (context.onRequest !== null) {\n      hookRunner(\n        context.onRequest,\n        hookIterator,\n        request,\n        reply,\n        runPreParsing\n      )\n    } else {\n      runPreParsing(null, request, reply)\n    }\n\n    if (context.onTimeout !== null) {\n      if (!request.raw.socket._meta) {\n        request.raw.socket.on('timeout', handleTimeout)\n      }\n      request.raw.socket._meta = { context, request, reply }\n    }\n  }\n}\n\nfunction handleTimeout () {\n  const { context, request, reply } = this._meta\n  hookRunner(\n    context.onTimeout,\n    hookIterator,\n    request,\n    reply,\n    noop\n  )\n}\n\nfunction validateBodyLimitOption (bodyLimit) {\n  if (bodyLimit === undefined) return\n  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {\n    throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${bodyLimit}'`)\n  }\n}\n\nfunction runPreParsing (err, request, reply) {\n  if (reply.sent === true) return\n  if (err != null) {\n    reply.send(err)\n    return\n  }\n\n  request[kRequestPayloadStream] = request.raw\n\n  if (reply.context.preParsing !== null) {\n    preParsingHookRunner(reply.context.preParsing, request, reply, handleRequest)\n  } else {\n    handleRequest(null, request, reply)\n  }\n}\n\nfunction preParsingHookRunner (functions, request, reply, cb) {\n  let i = 0\n\n  function next (err, stream) {\n    if (reply.sent) {\n      return\n    }\n\n    if (typeof stream !== 'undefined') {\n      request[kRequestPayloadStream] = stream\n    }\n\n    if (err || i === functions.length) {\n      if (err && !(err instanceof Error)) {\n        reply[kReplyIsError] = true\n      }\n\n      cb(err, request, reply)\n      return\n    }\n\n    const fn = functions[i++]\n    let result\n    try {\n      if (fn[kHooksDeprecatedPreParsing]) {\n        result = fn(request, reply, next)\n      } else {\n        result = fn(request, reply, request[kRequestPayloadStream], next)\n      }\n    } catch (error) {\n      next(error)\n      return\n    }\n\n    if (result && typeof result.then === 'function') {\n      result.then(handleResolve, handleReject)\n    }\n  }\n\n  function handleResolve (stream) {\n    next(null, stream)\n  }\n\n  function handleReject (err) {\n    next(err)\n  }\n\n  next(null, request[kRequestPayloadStream])\n}\n\n/**\n * Used within the route handler as a `net.Socket.close` event handler.\n * The purpose is to remove a socket from the tracked sockets collection when\n * the socket has naturally timed out.\n */\nfunction removeTrackedSocket () {\n  this.keepAliveConnections.delete(this.socket)\n}\n\nfunction noop () { }\n\nmodule.exports = { buildRouting, validateBodyLimitOption }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/route.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/schema-compilers.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/fastify/lib/schema-compilers.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastJsonStringify = __webpack_require__(/*! fast-json-stringify */ \"../../../node_modules/fast-json-stringify/index.js\")\n\nfunction serializerFactory (externalSchemas, serializerOpts) {\n  const opts = Object.assign({}, serializerOpts, { schema: externalSchemas })\n  return function responseSchemaCompiler ({ schema /* method, url, httpStatus */ }) {\n    return fastJsonStringify(schema, opts)\n  }\n}\n\nmodule.exports.serializerCompiler = serializerFactory\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/schema-compilers.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/schema-controller.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/fastify/lib/schema-controller.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { buildSchemas } = __webpack_require__(/*! ./schemas */ \"../../../node_modules/fastify/lib/schemas.js\")\nconst { serializerCompiler } = __webpack_require__(/*! ./schema-compilers */ \"../../../node_modules/fastify/lib/schema-compilers.js\")\nconst ValidatorSelector = __webpack_require__(/*! @fastify/ajv-compiler */ \"../../../node_modules/@fastify/ajv-compiler/index.js\")\n\n/**\n * Called at every fastify context that is being created.\n * @param {object} parentSchemaCtrl: the SchemaController instance of the Fastify parent context\n * @param {object} opts: the `schemaController` server option. It can be undefined when a parentSchemaCtrl is set\n * @return {object}:a new SchemaController\n */\nfunction buildSchemaController (parentSchemaCtrl, opts) {\n  if (parentSchemaCtrl) {\n    return new SchemaController(parentSchemaCtrl, opts)\n  }\n\n  let compilersFactory = {\n    buildValidator: ValidatorSelector(),\n    buildSerializer: serializerCompiler\n  }\n  if (opts && opts.compilersFactory) {\n    compilersFactory = Object.assign(compilersFactory, opts.compilersFactory)\n  }\n\n  const option = {\n    bucket: (opts && opts.bucket) || buildSchemas,\n    compilersFactory: compilersFactory\n  }\n\n  return new SchemaController(undefined, option)\n}\n\nclass SchemaController {\n  constructor (parent, options) {\n    this.opts = options || (parent && parent.opts)\n    this.addedSchemas = false\n\n    this.compilersFactory = this.opts.compilersFactory\n\n    if (parent) {\n      this.schemaBucket = this.opts.bucket(parent.getSchemas())\n      this.validatorCompiler = parent.getValidatorCompiler()\n      this.serializerCompiler = parent.getSerializerCompiler()\n      this.parent = parent\n    } else {\n      this.schemaBucket = this.opts.bucket()\n    }\n  }\n\n  // Bucket interface\n  add (schema) {\n    this.addedSchemas = true\n    return this.schemaBucket.add(schema)\n  }\n\n  getSchema (schemaId) {\n    return this.schemaBucket.getSchema(schemaId)\n  }\n\n  getSchemas () {\n    return this.schemaBucket.getSchemas()\n  }\n\n  // Schema Controller compilers holder\n  setValidatorCompiler (validatorCompiler) {\n    this.validatorCompiler = validatorCompiler\n  }\n\n  setSerializerCompiler (serializerCompiler) {\n    this.serializerCompiler = serializerCompiler\n  }\n\n  getValidatorCompiler () {\n    return this.validatorCompiler || (this.parent && this.parent.getValidatorCompiler())\n  }\n\n  getSerializerCompiler () {\n    return this.serializerCompiler || (this.parent && this.parent.getSerializerCompiler())\n  }\n\n  getSerializerBuilder () {\n    return this.compilersFactory.buildSerializer || (this.parent && this.parent.getSerializerBuilder())\n  }\n\n  getValidatorBuilder () {\n    return this.compilersFactory.buildValidator || (this.parent && this.parent.getValidatorBuilder())\n  }\n\n  /**\n   * This method will be called when a validator must be setup.\n   * Do not setup the compiler more than once\n   * @param {object} serverOptions: the fastify server option\n   */\n  setupValidator (serverOption) {\n    const isReady = this.validatorCompiler !== undefined && !this.addedSchemas\n    if (isReady) {\n      return\n    }\n    this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOption.ajv)\n  }\n\n  /**\n   * This method will be called when a serializer must be setup.\n   * Do not setup the compiler more than once\n   * @param {object} serverOptions: the fastify server option\n   */\n  setupSerializer (serverOption) {\n    const isReady = this.serializerCompiler !== undefined && !this.addedSchemas\n    if (isReady) {\n      return\n    }\n\n    this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOption.serializerOpts)\n  }\n}\n\nSchemaController.buildSchemaController = buildSchemaController\nmodule.exports = SchemaController\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/schema-controller.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/schemas.js":
/*!****************************************************!*\
  !*** ../../../node_modules/fastify/lib/schemas.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastClone = __webpack_require__(/*! rfdc */ \"../../../node_modules/rfdc/index.js\")({ circles: false, proto: true })\nconst { kSchemaVisited } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\nconst kFluentSchema = Symbol.for('fluent-schema-object')\n\nconst {\n  FST_ERR_SCH_MISSING_ID,\n  FST_ERR_SCH_ALREADY_PRESENT,\n  FST_ERR_SCH_DUPLICATE\n} = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nconst SCHEMAS_SOURCE = ['params', 'body', 'querystring', 'query', 'headers']\n\nfunction Schemas (initStore) {\n  this.store = initStore || {}\n}\n\nSchemas.prototype.add = function (inputSchema) {\n  const schema = fastClone((inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema])\n    ? inputSchema.valueOf()\n    : inputSchema\n  )\n\n  // devs can add schemas without $id, but with $def instead\n  const id = schema.$id\n  if (!id) {\n    throw new FST_ERR_SCH_MISSING_ID()\n  }\n\n  if (this.store[id]) {\n    throw new FST_ERR_SCH_ALREADY_PRESENT(id)\n  }\n\n  this.store[id] = schema\n}\n\nSchemas.prototype.getSchemas = function () {\n  return Object.assign({}, this.store)\n}\n\nSchemas.prototype.getSchema = function (schemaId) {\n  return this.store[schemaId]\n}\n\nfunction normalizeSchema (routeSchemas, serverOptions) {\n  if (routeSchemas[kSchemaVisited]) {\n    return routeSchemas\n  }\n\n  // alias query to querystring schema\n  if (routeSchemas.query) {\n    // check if our schema has both querystring and query\n    if (routeSchemas.querystring) {\n      throw new FST_ERR_SCH_DUPLICATE('querystring')\n    }\n    routeSchemas.querystring = routeSchemas.query\n  }\n\n  generateFluentSchema(routeSchemas)\n\n  // let's check if our schemas have a custom prototype\n  for (const key of ['headers', 'querystring', 'params', 'body']) {\n    if (typeof routeSchemas[key] === 'object' && Object.getPrototypeOf(routeSchemas[key]) !== Object.prototype) {\n      return routeSchemas\n    }\n  }\n\n  if (routeSchemas.body) {\n    routeSchemas.body = getSchemaAnyway(routeSchemas.body, serverOptions.jsonShorthand)\n  }\n\n  if (routeSchemas.headers) {\n    routeSchemas.headers = getSchemaAnyway(routeSchemas.headers, serverOptions.jsonShorthand)\n  }\n\n  if (routeSchemas.querystring) {\n    routeSchemas.querystring = getSchemaAnyway(routeSchemas.querystring, serverOptions.jsonShorthand)\n  }\n\n  if (routeSchemas.params) {\n    routeSchemas.params = getSchemaAnyway(routeSchemas.params, serverOptions.jsonShorthand)\n  }\n\n  if (routeSchemas.response) {\n    const httpCodes = Object.keys(routeSchemas.response)\n    for (const code of httpCodes) {\n      routeSchemas.response[code] = getSchemaAnyway(routeSchemas.response[code], serverOptions.jsonShorthand)\n    }\n  }\n\n  routeSchemas[kSchemaVisited] = true\n  return routeSchemas\n}\n\nfunction generateFluentSchema (schema) {\n  for (const key of SCHEMAS_SOURCE) {\n    if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {\n      schema[key] = schema[key].valueOf()\n    }\n  }\n\n  if (schema.response) {\n    const httpCodes = Object.keys(schema.response)\n    for (const code of httpCodes) {\n      if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {\n        schema.response[code] = schema.response[code].valueOf()\n      }\n    }\n  }\n}\n\nfunction getSchemaAnyway (schema, jsonShorthand) {\n  if (!jsonShorthand || schema.$ref || schema.oneOf || schema.allOf || schema.anyOf || schema.$merge || schema.$patch) return schema\n  if (!schema.type && !schema.properties) {\n    return {\n      type: 'object',\n      properties: schema\n    }\n  }\n  return schema\n}\n\nmodule.exports = {\n  buildSchemas (initStore) { return new Schemas(initStore) },\n  normalizeSchema\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/schemas.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/server.js":
/*!***************************************************!*\
  !*** ../../../node_modules/fastify/lib/server.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst https = __webpack_require__(/*! https */ \"https\")\n\nconst { kState, kOptions } = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\nconst { FST_ERR_HTTP2_INVALID_VERSION, FST_ERR_REOPENED_CLOSE_SERVER, FST_ERR_REOPENED_SERVER } = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nfunction createServer (options, httpHandler) {\n  assert(options, 'Missing options')\n  assert(httpHandler, 'Missing http handler')\n\n  let server = null\n  if (options.serverFactory) {\n    server = options.serverFactory(httpHandler, options)\n  } else if (options.http2) {\n    if (options.https) {\n      server = http2().createSecureServer(options.https, httpHandler)\n    } else {\n      server = http2().createServer(httpHandler)\n    }\n    server.on('session', sessionTimeout(options.http2SessionTimeout))\n  } else {\n    // this is http1\n    if (options.https) {\n      server = https.createServer(options.https, httpHandler)\n    } else {\n      server = http.createServer(httpHandler)\n    }\n    server.keepAliveTimeout = options.keepAliveTimeout\n    server.requestTimeout = options.requestTimeout\n    // we treat zero as null\n    // and null is the default setting from nodejs\n    // so we do not pass the option to server\n    if (options.maxRequestsPerSocket > 0) {\n      server.maxRequestsPerSocket = options.maxRequestsPerSocket\n    }\n  }\n\n  if (!options.serverFactory) {\n    server.setTimeout(options.connectionTimeout)\n  }\n\n  return { server, listen }\n\n  // `this` is the Fastify object\n  function listen () {\n    const normalizeListenArgs = (args) => {\n      if (args.length === 0) {\n        return { port: 0, host: 'localhost' }\n      }\n\n      const cb = typeof args[args.length - 1] === 'function' ? args.pop() : undefined\n      const options = { cb: cb }\n\n      const firstArg = args[0]\n      const argsLength = args.length\n      const lastArg = args[argsLength - 1]\n      /* Deal with listen (options) || (handle[, backlog]) */\n      if (typeof firstArg === 'object' && firstArg !== null) {\n        options.backlog = argsLength > 1 ? lastArg : undefined\n        Object.assign(options, firstArg)\n      } else if (typeof firstArg === 'string' && isNaN(firstArg)) {\n        /* Deal with listen (pipe[, backlog]) */\n        options.path = firstArg\n        options.backlog = argsLength > 1 ? lastArg : undefined\n      } else {\n        /* Deal with listen ([port[, host[, backlog]]]) */\n        options.port = argsLength >= 1 && firstArg ? firstArg : 0\n        // This will listen to what localhost is.\n        // It can be 127.0.0.1 or ::1, depending on the operating system.\n        // Fixes https://github.com/fastify/fastify/issues/1022.\n        options.host = argsLength >= 2 && args[1] ? args[1] : 'localhost'\n        options.backlog = argsLength >= 3 ? args[2] : undefined\n      }\n\n      return options\n    }\n\n    const listenOptions = normalizeListenArgs(Array.from(arguments))\n    const cb = listenOptions.cb\n\n    const wrap = err => {\n      server.removeListener('error', wrap)\n      if (!err) {\n        const address = logServerAddress()\n        cb(null, address)\n      } else {\n        this[kState].listening = false\n        cb(err, null)\n      }\n    }\n\n    const listenPromise = (listenOptions) => {\n      if (this[kState].listening && this[kState].closing) {\n        return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER())\n      } else if (this[kState].listening) {\n        return Promise.reject(new FST_ERR_REOPENED_SERVER())\n      }\n\n      return this.ready().then(() => {\n        let errEventHandler\n        const errEvent = new Promise((resolve, reject) => {\n          errEventHandler = (err) => {\n            this[kState].listening = false\n            reject(err)\n          }\n          server.once('error', errEventHandler)\n        })\n        const listen = new Promise((resolve, reject) => {\n          server.listen(listenOptions, () => {\n            server.removeListener('error', errEventHandler)\n            resolve(logServerAddress())\n          })\n          // we set it afterwards because listen can throw\n          this[kState].listening = true\n        })\n\n        return Promise.race([\n          errEvent, // e.g invalid port range error is always emitted before the server listening\n          listen\n        ])\n      })\n    }\n\n    const logServerAddress = () => {\n      let address = server.address()\n      const isUnixSocket = typeof address === 'string'\n      /* istanbul ignore next */\n      if (!isUnixSocket) {\n        if (address.address.indexOf(':') === -1) {\n          address = address.address + ':' + address.port\n        } else {\n          address = '[' + address.address + ']:' + address.port\n        }\n      }\n      /* istanbul ignore next */\n      address = (isUnixSocket ? '' : ('http' + (this[kOptions].https ? 's' : '') + '://')) + address\n      this.log.info('Server listening at ' + address)\n      return address\n    }\n\n    if (cb === undefined) return listenPromise(listenOptions)\n\n    this.ready(err => {\n      if (err != null) return cb(err)\n\n      if (this[kState].listening && this[kState].closing) {\n        return cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null)\n      } else if (this[kState].listening) {\n        return cb(new FST_ERR_REOPENED_SERVER(), null)\n      }\n\n      server.once('error', wrap)\n      server.listen(listenOptions, wrap)\n\n      this[kState].listening = true\n    })\n  }\n}\n\nfunction http2 () {\n  try {\n    return __webpack_require__(/*! http2 */ \"http2\")\n  } catch (err) {\n    throw new FST_ERR_HTTP2_INVALID_VERSION()\n  }\n}\n\nfunction sessionTimeout (timeout) {\n  return function (session) {\n    session.setTimeout(timeout, close)\n  }\n}\n\nfunction close () {\n  this.close()\n}\n\nmodule.exports = { createServer }\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/server.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/symbols.js":
/*!****************************************************!*\
  !*** ../../../node_modules/fastify/lib/symbols.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst keys = {\n  kAvvioBoot: Symbol('fastify.avvioBoot'),\n  kChildren: Symbol('fastify.children'),\n  kBodyLimit: Symbol('fastify.bodyLimit'),\n  kRoutePrefix: Symbol('fastify.routePrefix'),\n  kLogLevel: Symbol('fastify.logLevel'),\n  kLogSerializers: Symbol('fastify.logSerializers'),\n  kHooks: Symbol('fastify.hooks'),\n  kHooksDeprecatedPreParsing: Symbol('fastify.hooks.DeprecatedPreParsing'),\n  kSchemaController: Symbol('fastify.schemaController'),\n  kSchemaHeaders: Symbol('headers-schema'),\n  kSchemaParams: Symbol('params-schema'),\n  kSchemaQuerystring: Symbol('querystring-schema'),\n  kSchemaBody: Symbol('body-schema'),\n  kSchemaResponse: Symbol('response-schema'),\n  kSchemaErrorFormatter: Symbol('fastify.schemaErrorFormatter'),\n  kReplySerializerDefault: Symbol('fastify.replySerializerDefault'),\n  kContentTypeParser: Symbol('fastify.contentTypeParser'),\n  kReply: Symbol('fastify.Reply'),\n  kRequest: Symbol('fastify.Request'),\n  kRequestPayloadStream: Symbol('fastify.RequestPayloadStream'),\n  kRequestAcceptVersion: Symbol('fastify.RequestAcceptVersion'),\n  kCanSetNotFoundHandler: Symbol('fastify.canSetNotFoundHandler'),\n  kFourOhFour: Symbol('fastify.404'),\n  kFourOhFourLevelInstance: Symbol('fastify.404LogLevelInstance'),\n  kFourOhFourContext: Symbol('fastify.404ContextKey'),\n  kDefaultJsonParse: Symbol('fastify.defaultJSONParse'),\n  kReplySerializer: Symbol('fastify.reply.serializer'),\n  kReplyIsError: Symbol('fastify.reply.isError'),\n  kReplyHeaders: Symbol('fastify.reply.headers'),\n  kReplyHasStatusCode: Symbol('fastify.reply.hasStatusCode'),\n  kReplySent: Symbol('fastify.reply.sent'),\n  kReplySentOverwritten: Symbol('fastify.reply.sentOverwritten'),\n  kReplyStartTime: Symbol('fastify.reply.startTime'),\n  kReplyEndTime: Symbol('fastify.reply.endTime'),\n  kReplyErrorHandlerCalled: Symbol('fastify.reply.errorHandlerCalled'),\n  kReplyIsRunningOnErrorHook: Symbol('fastify.reply.isRunningOnErrorHook'),\n  kSchemaVisited: Symbol('fastify.schemas.visited'),\n  kState: Symbol('fastify.state'),\n  kOptions: Symbol('fastify.options'),\n  kDisableRequestLogging: Symbol('fastify.disableRequestLogging'),\n  kPluginNameChain: Symbol('fastify.pluginNameChain'),\n  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose\n  kTestInternals: Symbol('fastify.testInternals'),\n  kErrorHandler: Symbol('fastify.errorHandler'),\n  kKeepAliveConnections: Symbol('fastify.keepAliveConnections')\n}\n\nmodule.exports = keys\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/symbols.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/validation.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/fastify/lib/validation.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kSchemaHeaders: headersSchema,\n  kSchemaParams: paramsSchema,\n  kSchemaQuerystring: querystringSchema,\n  kSchemaBody: bodySchema,\n  kSchemaResponse: responseSchema\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nfunction compileSchemasForSerialization (context, compile) {\n  if (!context.schema || !context.schema.response) {\n    return\n  }\n\n  const { method, url } = context.config || {}\n  context[responseSchema] = Object.keys(context.schema.response)\n    .reduce(function (acc, statusCode) {\n      acc[statusCode] = compile({\n        schema: context.schema.response[statusCode],\n        url,\n        method,\n        httpStatus: statusCode\n      })\n      return acc\n    }, {})\n}\n\nfunction compileSchemasForValidation (context, compile) {\n  if (!context.schema) {\n    return\n  }\n\n  const { method, url } = context.config || {}\n\n  const headers = context.schema.headers\n  if (headers && Object.getPrototypeOf(headers) !== Object.prototype) {\n    // do not mess with non-literals, e.g. Joi schemas\n    context[headersSchema] = compile({ schema: headers, method, url, httpPart: 'headers' })\n  } else if (headers) {\n    // The header keys are case insensitive\n    //  https://tools.ietf.org/html/rfc2616#section-4.2\n    const headersSchemaLowerCase = {}\n    Object.keys(headers).forEach(k => { headersSchemaLowerCase[k] = headers[k] })\n    if (headersSchemaLowerCase.required instanceof Array) {\n      headersSchemaLowerCase.required = headersSchemaLowerCase.required.map(h => h.toLowerCase())\n    }\n    if (headers.properties) {\n      headersSchemaLowerCase.properties = {}\n      Object.keys(headers.properties).forEach(k => {\n        headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k]\n      })\n    }\n    context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: 'headers' })\n  }\n\n  if (context.schema.body) {\n    context[bodySchema] = compile({ schema: context.schema.body, method, url, httpPart: 'body' })\n  }\n\n  if (context.schema.querystring) {\n    context[querystringSchema] = compile({ schema: context.schema.querystring, method, url, httpPart: 'querystring' })\n  }\n\n  if (context.schema.params) {\n    context[paramsSchema] = compile({ schema: context.schema.params, method, url, httpPart: 'params' })\n  }\n}\n\nfunction validateParam (validatorFunction, request, paramName) {\n  const ret = validatorFunction && validatorFunction(request[paramName])\n  if (ret === false) return validatorFunction.errors\n  if (ret && ret.error) return ret.error\n  if (ret && ret.value) request[paramName] = ret.value\n  return false\n}\n\nfunction validate (context, request) {\n  const params = validateParam(context[paramsSchema], request, 'params')\n\n  if (params) {\n    return wrapValidationError(params, 'params', context.schemaErrorFormatter)\n  }\n  const body = validateParam(context[bodySchema], request, 'body')\n  if (body) {\n    return wrapValidationError(body, 'body', context.schemaErrorFormatter)\n  }\n  const query = validateParam(context[querystringSchema], request, 'query')\n  if (query) {\n    return wrapValidationError(query, 'querystring', context.schemaErrorFormatter)\n  }\n  const headers = validateParam(context[headersSchema], request, 'headers')\n  if (headers) {\n    return wrapValidationError(headers, 'headers', context.schemaErrorFormatter)\n  }\n  return null\n}\n\nfunction wrapValidationError (result, dataVar, schemaErrorFormatter) {\n  if (result instanceof Error) {\n    result.validationContext = result.validationContext || dataVar\n    return result\n  }\n\n  const error = schemaErrorFormatter(result, dataVar)\n  error.validation = result\n  error.validationContext = dataVar\n  return error\n}\n\nmodule.exports = {\n  symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },\n  compileSchemasForValidation,\n  compileSchemasForSerialization,\n  validate\n}\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/validation.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/warnings.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/fastify/lib/warnings.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst warning = __webpack_require__(/*! process-warning */ \"../../../node_modules/process-warning/index.js\")()\n\n/**\n * Deprecation codes:\n *   - FSTDEP001\n *   - FSTDEP002\n *   - FSTDEP003\n *   - FSTDEP004\n *   - FSTDEP005\n */\n\nwarning.create('FastifyDeprecation', 'FSTDEP001', 'You are accessing the Node.js core request object via \"request.req\", Use \"request.raw\" instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP002', 'You are accessing the Node.js core response object via \"reply.res\", Use \"reply.raw\" instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP003', 'You are using the legacy Content Type Parser function signature. Use the one suggested in the documentation instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP004', 'You are using the legacy preParsing hook signature. Use the one suggested in the documentation instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP005', 'You are accessing the deprecated \"request.connection\" property. Use \"request.socket\" instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP006', 'You are decorating Request/Reply with a reference type. This reference is shared amongst all requests. Use onRequest hook instead. Property: %s')\n\nwarning.create('FastifyDeprecation', 'FSTDEP007', 'You are trying to set a HEAD route using \"exposeHeadRoute\" route flag when a sibling route is already set. See documentation for more info.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP008', 'You are using route constraints via the route { version: \"...\" } option, use { constraints: { version: \"...\" } } option instead.')\n\nwarning.create('FastifyDeprecation', 'FSTDEP009', 'You are using a custom route versioning strategy via the server { versioning: \"...\" } option, use { constraints: { version: \"...\" } } option instead.')\n\nmodule.exports = warning\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/warnings.js?");

/***/ }),

/***/ "../../../node_modules/fastify/lib/wrapThenable.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/fastify/lib/wrapThenable.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kReplyIsError,\n  kReplySent,\n  kReplySentOverwritten\n} = __webpack_require__(/*! ./symbols */ \"../../../node_modules/fastify/lib/symbols.js\")\n\nconst { FST_ERR_PROMISE_NOT_FULFILLED } = __webpack_require__(/*! ./errors */ \"../../../node_modules/fastify/lib/errors.js\")\n\nfunction wrapThenable (thenable, reply) {\n  thenable.then(function (payload) {\n    if (reply[kReplySentOverwritten] === true) {\n      return\n    }\n\n    // this is for async functions that\n    // are using reply.send directly\n    if (payload !== undefined || (reply.raw.statusCode === 204 && reply[kReplySent] === false)) {\n      // we use a try-catch internally to avoid adding a catch to another\n      // promise, increase promise perf by 10%\n      try {\n        reply.send(payload)\n      } catch (err) {\n        reply[kReplySent] = false\n        reply[kReplyIsError] = true\n        reply.send(err)\n      }\n    } else if (reply[kReplySent] === false) {\n      reply.log.error({ err: new FST_ERR_PROMISE_NOT_FULFILLED() }, \"Promise may not be fulfilled with 'undefined' when statusCode is not 204\")\n    }\n  }, function (err) {\n    if (reply[kReplySentOverwritten] === true || reply.sent === true) {\n      reply.log.error({ err }, 'Promise errored, but reply.sent = true was set')\n      return\n    }\n\n    reply[kReplySent] = false\n    reply[kReplyIsError] = true\n    reply.send(err)\n  })\n}\n\nmodule.exports = wrapThenable\n\n\n//# sourceURL=webpack://qui/../../../node_modules/fastify/lib/wrapThenable.js?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/refs/data.json":
/*!****************************************************!*\
  !*** ../../../node_modules/ajv/lib/refs/data.json ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON Schema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/refs/data.json?");

/***/ }),

/***/ "../../../node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!********************************************************************!*\
  !*** ../../../node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n//# sourceURL=webpack://qui/../../../node_modules/ajv/lib/refs/json-schema-draft-07.json?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/refs/data.json":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/refs/data.json ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/refs/data.json?");

/***/ }),

/***/ "../../../node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json ***!
  \***************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n//# sourceURL=webpack://qui/../../../node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json?");

/***/ }),

/***/ "../../../node_modules/mime/types.json":
/*!*********************************************!*\
  !*** ../../../node_modules/mime/types.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"application/andrew-inset\":[\"ez\"],\"application/applixware\":[\"aw\"],\"application/atom+xml\":[\"atom\"],\"application/atomcat+xml\":[\"atomcat\"],\"application/atomsvc+xml\":[\"atomsvc\"],\"application/bdoc\":[\"bdoc\"],\"application/ccxml+xml\":[\"ccxml\"],\"application/cdmi-capability\":[\"cdmia\"],\"application/cdmi-container\":[\"cdmic\"],\"application/cdmi-domain\":[\"cdmid\"],\"application/cdmi-object\":[\"cdmio\"],\"application/cdmi-queue\":[\"cdmiq\"],\"application/cu-seeme\":[\"cu\"],\"application/dash+xml\":[\"mpd\"],\"application/davmount+xml\":[\"davmount\"],\"application/docbook+xml\":[\"dbk\"],\"application/dssc+der\":[\"dssc\"],\"application/dssc+xml\":[\"xdssc\"],\"application/ecmascript\":[\"ecma\"],\"application/emma+xml\":[\"emma\"],\"application/epub+zip\":[\"epub\"],\"application/exi\":[\"exi\"],\"application/font-tdpfr\":[\"pfr\"],\"application/font-woff\":[],\"application/font-woff2\":[],\"application/geo+json\":[\"geojson\"],\"application/gml+xml\":[\"gml\"],\"application/gpx+xml\":[\"gpx\"],\"application/gxf\":[\"gxf\"],\"application/gzip\":[\"gz\"],\"application/hyperstudio\":[\"stk\"],\"application/inkml+xml\":[\"ink\",\"inkml\"],\"application/ipfix\":[\"ipfix\"],\"application/java-archive\":[\"jar\",\"war\",\"ear\"],\"application/java-serialized-object\":[\"ser\"],\"application/java-vm\":[\"class\"],\"application/javascript\":[\"js\",\"mjs\"],\"application/json\":[\"json\",\"map\"],\"application/json5\":[\"json5\"],\"application/jsonml+json\":[\"jsonml\"],\"application/ld+json\":[\"jsonld\"],\"application/lost+xml\":[\"lostxml\"],\"application/mac-binhex40\":[\"hqx\"],\"application/mac-compactpro\":[\"cpt\"],\"application/mads+xml\":[\"mads\"],\"application/manifest+json\":[\"webmanifest\"],\"application/marc\":[\"mrc\"],\"application/marcxml+xml\":[\"mrcx\"],\"application/mathematica\":[\"ma\",\"nb\",\"mb\"],\"application/mathml+xml\":[\"mathml\"],\"application/mbox\":[\"mbox\"],\"application/mediaservercontrol+xml\":[\"mscml\"],\"application/metalink+xml\":[\"metalink\"],\"application/metalink4+xml\":[\"meta4\"],\"application/mets+xml\":[\"mets\"],\"application/mods+xml\":[\"mods\"],\"application/mp21\":[\"m21\",\"mp21\"],\"application/mp4\":[\"mp4s\",\"m4p\"],\"application/msword\":[\"doc\",\"dot\"],\"application/mxf\":[\"mxf\"],\"application/octet-stream\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"],\"application/oda\":[\"oda\"],\"application/oebps-package+xml\":[\"opf\"],\"application/ogg\":[\"ogx\"],\"application/omdoc+xml\":[\"omdoc\"],\"application/onenote\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"],\"application/oxps\":[\"oxps\"],\"application/patch-ops-error+xml\":[\"xer\"],\"application/pdf\":[\"pdf\"],\"application/pgp-encrypted\":[\"pgp\"],\"application/pgp-signature\":[\"asc\",\"sig\"],\"application/pics-rules\":[\"prf\"],\"application/pkcs10\":[\"p10\"],\"application/pkcs7-mime\":[\"p7m\",\"p7c\"],\"application/pkcs7-signature\":[\"p7s\"],\"application/pkcs8\":[\"p8\"],\"application/pkix-attr-cert\":[\"ac\"],\"application/pkix-cert\":[\"cer\"],\"application/pkix-crl\":[\"crl\"],\"application/pkix-pkipath\":[\"pkipath\"],\"application/pkixcmp\":[\"pki\"],\"application/pls+xml\":[\"pls\"],\"application/postscript\":[\"ai\",\"eps\",\"ps\"],\"application/prs.cww\":[\"cww\"],\"application/pskc+xml\":[\"pskcxml\"],\"application/raml+yaml\":[\"raml\"],\"application/rdf+xml\":[\"rdf\"],\"application/reginfo+xml\":[\"rif\"],\"application/relax-ng-compact-syntax\":[\"rnc\"],\"application/resource-lists+xml\":[\"rl\"],\"application/resource-lists-diff+xml\":[\"rld\"],\"application/rls-services+xml\":[\"rs\"],\"application/rpki-ghostbusters\":[\"gbr\"],\"application/rpki-manifest\":[\"mft\"],\"application/rpki-roa\":[\"roa\"],\"application/rsd+xml\":[\"rsd\"],\"application/rss+xml\":[\"rss\"],\"application/rtf\":[\"rtf\"],\"application/sbml+xml\":[\"sbml\"],\"application/scvp-cv-request\":[\"scq\"],\"application/scvp-cv-response\":[\"scs\"],\"application/scvp-vp-request\":[\"spq\"],\"application/scvp-vp-response\":[\"spp\"],\"application/sdp\":[\"sdp\"],\"application/set-payment-initiation\":[\"setpay\"],\"application/set-registration-initiation\":[\"setreg\"],\"application/shf+xml\":[\"shf\"],\"application/smil+xml\":[\"smi\",\"smil\"],\"application/sparql-query\":[\"rq\"],\"application/sparql-results+xml\":[\"srx\"],\"application/srgs\":[\"gram\"],\"application/srgs+xml\":[\"grxml\"],\"application/sru+xml\":[\"sru\"],\"application/ssdl+xml\":[\"ssdl\"],\"application/ssml+xml\":[\"ssml\"],\"application/tei+xml\":[\"tei\",\"teicorpus\"],\"application/thraud+xml\":[\"tfi\"],\"application/timestamped-data\":[\"tsd\"],\"application/vnd.3gpp.pic-bw-large\":[\"plb\"],\"application/vnd.3gpp.pic-bw-small\":[\"psb\"],\"application/vnd.3gpp.pic-bw-var\":[\"pvb\"],\"application/vnd.3gpp2.tcap\":[\"tcap\"],\"application/vnd.3m.post-it-notes\":[\"pwn\"],\"application/vnd.accpac.simply.aso\":[\"aso\"],\"application/vnd.accpac.simply.imp\":[\"imp\"],\"application/vnd.acucobol\":[\"acu\"],\"application/vnd.acucorp\":[\"atc\",\"acutc\"],\"application/vnd.adobe.air-application-installer-package+zip\":[\"air\"],\"application/vnd.adobe.formscentral.fcdt\":[\"fcdt\"],\"application/vnd.adobe.fxp\":[\"fxp\",\"fxpl\"],\"application/vnd.adobe.xdp+xml\":[\"xdp\"],\"application/vnd.adobe.xfdf\":[\"xfdf\"],\"application/vnd.ahead.space\":[\"ahead\"],\"application/vnd.airzip.filesecure.azf\":[\"azf\"],\"application/vnd.airzip.filesecure.azs\":[\"azs\"],\"application/vnd.amazon.ebook\":[\"azw\"],\"application/vnd.americandynamics.acc\":[\"acc\"],\"application/vnd.amiga.ami\":[\"ami\"],\"application/vnd.android.package-archive\":[\"apk\"],\"application/vnd.anser-web-certificate-issue-initiation\":[\"cii\"],\"application/vnd.anser-web-funds-transfer-initiation\":[\"fti\"],\"application/vnd.antix.game-component\":[\"atx\"],\"application/vnd.apple.installer+xml\":[\"mpkg\"],\"application/vnd.apple.mpegurl\":[\"m3u8\"],\"application/vnd.apple.pkpass\":[\"pkpass\"],\"application/vnd.aristanetworks.swi\":[\"swi\"],\"application/vnd.astraea-software.iota\":[\"iota\"],\"application/vnd.audiograph\":[\"aep\"],\"application/vnd.blueice.multipass\":[\"mpm\"],\"application/vnd.bmi\":[\"bmi\"],\"application/vnd.businessobjects\":[\"rep\"],\"application/vnd.chemdraw+xml\":[\"cdxml\"],\"application/vnd.chipnuts.karaoke-mmd\":[\"mmd\"],\"application/vnd.cinderella\":[\"cdy\"],\"application/vnd.claymore\":[\"cla\"],\"application/vnd.cloanto.rp9\":[\"rp9\"],\"application/vnd.clonk.c4group\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"],\"application/vnd.cluetrust.cartomobile-config\":[\"c11amc\"],\"application/vnd.cluetrust.cartomobile-config-pkg\":[\"c11amz\"],\"application/vnd.commonspace\":[\"csp\"],\"application/vnd.contact.cmsg\":[\"cdbcmsg\"],\"application/vnd.cosmocaller\":[\"cmc\"],\"application/vnd.crick.clicker\":[\"clkx\"],\"application/vnd.crick.clicker.keyboard\":[\"clkk\"],\"application/vnd.crick.clicker.palette\":[\"clkp\"],\"application/vnd.crick.clicker.template\":[\"clkt\"],\"application/vnd.crick.clicker.wordbank\":[\"clkw\"],\"application/vnd.criticaltools.wbs+xml\":[\"wbs\"],\"application/vnd.ctc-posml\":[\"pml\"],\"application/vnd.cups-ppd\":[\"ppd\"],\"application/vnd.curl.car\":[\"car\"],\"application/vnd.curl.pcurl\":[\"pcurl\"],\"application/vnd.dart\":[\"dart\"],\"application/vnd.data-vision.rdz\":[\"rdz\"],\"application/vnd.dece.data\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"],\"application/vnd.dece.ttml+xml\":[\"uvt\",\"uvvt\"],\"application/vnd.dece.unspecified\":[\"uvx\",\"uvvx\"],\"application/vnd.dece.zip\":[\"uvz\",\"uvvz\"],\"application/vnd.denovo.fcselayout-link\":[\"fe_launch\"],\"application/vnd.dna\":[\"dna\"],\"application/vnd.dolby.mlp\":[\"mlp\"],\"application/vnd.dpgraph\":[\"dpg\"],\"application/vnd.dreamfactory\":[\"dfac\"],\"application/vnd.ds-keypoint\":[\"kpxx\"],\"application/vnd.dvb.ait\":[\"ait\"],\"application/vnd.dvb.service\":[\"svc\"],\"application/vnd.dynageo\":[\"geo\"],\"application/vnd.ecowin.chart\":[\"mag\"],\"application/vnd.enliven\":[\"nml\"],\"application/vnd.epson.esf\":[\"esf\"],\"application/vnd.epson.msf\":[\"msf\"],\"application/vnd.epson.quickanime\":[\"qam\"],\"application/vnd.epson.salt\":[\"slt\"],\"application/vnd.epson.ssf\":[\"ssf\"],\"application/vnd.eszigno3+xml\":[\"es3\",\"et3\"],\"application/vnd.ezpix-album\":[\"ez2\"],\"application/vnd.ezpix-package\":[\"ez3\"],\"application/vnd.fdf\":[\"fdf\"],\"application/vnd.fdsn.mseed\":[\"mseed\"],\"application/vnd.fdsn.seed\":[\"seed\",\"dataless\"],\"application/vnd.flographit\":[\"gph\"],\"application/vnd.fluxtime.clip\":[\"ftc\"],\"application/vnd.framemaker\":[\"fm\",\"frame\",\"maker\",\"book\"],\"application/vnd.frogans.fnc\":[\"fnc\"],\"application/vnd.frogans.ltf\":[\"ltf\"],\"application/vnd.fsc.weblaunch\":[\"fsc\"],\"application/vnd.fujitsu.oasys\":[\"oas\"],\"application/vnd.fujitsu.oasys2\":[\"oa2\"],\"application/vnd.fujitsu.oasys3\":[\"oa3\"],\"application/vnd.fujitsu.oasysgp\":[\"fg5\"],\"application/vnd.fujitsu.oasysprs\":[\"bh2\"],\"application/vnd.fujixerox.ddd\":[\"ddd\"],\"application/vnd.fujixerox.docuworks\":[\"xdw\"],\"application/vnd.fujixerox.docuworks.binder\":[\"xbd\"],\"application/vnd.fuzzysheet\":[\"fzs\"],\"application/vnd.genomatix.tuxedo\":[\"txd\"],\"application/vnd.geogebra.file\":[\"ggb\"],\"application/vnd.geogebra.tool\":[\"ggt\"],\"application/vnd.geometry-explorer\":[\"gex\",\"gre\"],\"application/vnd.geonext\":[\"gxt\"],\"application/vnd.geoplan\":[\"g2w\"],\"application/vnd.geospace\":[\"g3w\"],\"application/vnd.gmx\":[\"gmx\"],\"application/vnd.google-apps.document\":[\"gdoc\"],\"application/vnd.google-apps.presentation\":[\"gslides\"],\"application/vnd.google-apps.spreadsheet\":[\"gsheet\"],\"application/vnd.google-earth.kml+xml\":[\"kml\"],\"application/vnd.google-earth.kmz\":[\"kmz\"],\"application/vnd.grafeq\":[\"gqf\",\"gqs\"],\"application/vnd.groove-account\":[\"gac\"],\"application/vnd.groove-help\":[\"ghf\"],\"application/vnd.groove-identity-message\":[\"gim\"],\"application/vnd.groove-injector\":[\"grv\"],\"application/vnd.groove-tool-message\":[\"gtm\"],\"application/vnd.groove-tool-template\":[\"tpl\"],\"application/vnd.groove-vcard\":[\"vcg\"],\"application/vnd.hal+xml\":[\"hal\"],\"application/vnd.handheld-entertainment+xml\":[\"zmm\"],\"application/vnd.hbci\":[\"hbci\"],\"application/vnd.hhe.lesson-player\":[\"les\"],\"application/vnd.hp-hpgl\":[\"hpgl\"],\"application/vnd.hp-hpid\":[\"hpid\"],\"application/vnd.hp-hps\":[\"hps\"],\"application/vnd.hp-jlyt\":[\"jlt\"],\"application/vnd.hp-pcl\":[\"pcl\"],\"application/vnd.hp-pclxl\":[\"pclxl\"],\"application/vnd.hydrostatix.sof-data\":[\"sfd-hdstx\"],\"application/vnd.ibm.minipay\":[\"mpy\"],\"application/vnd.ibm.modcap\":[\"afp\",\"listafp\",\"list3820\"],\"application/vnd.ibm.rights-management\":[\"irm\"],\"application/vnd.ibm.secure-container\":[\"sc\"],\"application/vnd.iccprofile\":[\"icc\",\"icm\"],\"application/vnd.igloader\":[\"igl\"],\"application/vnd.immervision-ivp\":[\"ivp\"],\"application/vnd.immervision-ivu\":[\"ivu\"],\"application/vnd.insors.igm\":[\"igm\"],\"application/vnd.intercon.formnet\":[\"xpw\",\"xpx\"],\"application/vnd.intergeo\":[\"i2g\"],\"application/vnd.intu.qbo\":[\"qbo\"],\"application/vnd.intu.qfx\":[\"qfx\"],\"application/vnd.ipunplugged.rcprofile\":[\"rcprofile\"],\"application/vnd.irepository.package+xml\":[\"irp\"],\"application/vnd.is-xpr\":[\"xpr\"],\"application/vnd.isac.fcs\":[\"fcs\"],\"application/vnd.jam\":[\"jam\"],\"application/vnd.jcp.javame.midlet-rms\":[\"rms\"],\"application/vnd.jisp\":[\"jisp\"],\"application/vnd.joost.joda-archive\":[\"joda\"],\"application/vnd.kahootz\":[\"ktz\",\"ktr\"],\"application/vnd.kde.karbon\":[\"karbon\"],\"application/vnd.kde.kchart\":[\"chrt\"],\"application/vnd.kde.kformula\":[\"kfo\"],\"application/vnd.kde.kivio\":[\"flw\"],\"application/vnd.kde.kontour\":[\"kon\"],\"application/vnd.kde.kpresenter\":[\"kpr\",\"kpt\"],\"application/vnd.kde.kspread\":[\"ksp\"],\"application/vnd.kde.kword\":[\"kwd\",\"kwt\"],\"application/vnd.kenameaapp\":[\"htke\"],\"application/vnd.kidspiration\":[\"kia\"],\"application/vnd.kinar\":[\"kne\",\"knp\"],\"application/vnd.koan\":[\"skp\",\"skd\",\"skt\",\"skm\"],\"application/vnd.kodak-descriptor\":[\"sse\"],\"application/vnd.las.las+xml\":[\"lasxml\"],\"application/vnd.llamagraphics.life-balance.desktop\":[\"lbd\"],\"application/vnd.llamagraphics.life-balance.exchange+xml\":[\"lbe\"],\"application/vnd.lotus-1-2-3\":[\"123\"],\"application/vnd.lotus-approach\":[\"apr\"],\"application/vnd.lotus-freelance\":[\"pre\"],\"application/vnd.lotus-notes\":[\"nsf\"],\"application/vnd.lotus-organizer\":[\"org\"],\"application/vnd.lotus-screencam\":[\"scm\"],\"application/vnd.lotus-wordpro\":[\"lwp\"],\"application/vnd.macports.portpkg\":[\"portpkg\"],\"application/vnd.mcd\":[\"mcd\"],\"application/vnd.medcalcdata\":[\"mc1\"],\"application/vnd.mediastation.cdkey\":[\"cdkey\"],\"application/vnd.mfer\":[\"mwf\"],\"application/vnd.mfmp\":[\"mfm\"],\"application/vnd.micrografx.flo\":[\"flo\"],\"application/vnd.micrografx.igx\":[\"igx\"],\"application/vnd.mif\":[\"mif\"],\"application/vnd.mobius.daf\":[\"daf\"],\"application/vnd.mobius.dis\":[\"dis\"],\"application/vnd.mobius.mbk\":[\"mbk\"],\"application/vnd.mobius.mqy\":[\"mqy\"],\"application/vnd.mobius.msl\":[\"msl\"],\"application/vnd.mobius.plc\":[\"plc\"],\"application/vnd.mobius.txf\":[\"txf\"],\"application/vnd.mophun.application\":[\"mpn\"],\"application/vnd.mophun.certificate\":[\"mpc\"],\"application/vnd.mozilla.xul+xml\":[\"xul\"],\"application/vnd.ms-artgalry\":[\"cil\"],\"application/vnd.ms-cab-compressed\":[\"cab\"],\"application/vnd.ms-excel\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"],\"application/vnd.ms-excel.addin.macroenabled.12\":[\"xlam\"],\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":[\"xlsb\"],\"application/vnd.ms-excel.sheet.macroenabled.12\":[\"xlsm\"],\"application/vnd.ms-excel.template.macroenabled.12\":[\"xltm\"],\"application/vnd.ms-fontobject\":[\"eot\"],\"application/vnd.ms-htmlhelp\":[\"chm\"],\"application/vnd.ms-ims\":[\"ims\"],\"application/vnd.ms-lrm\":[\"lrm\"],\"application/vnd.ms-officetheme\":[\"thmx\"],\"application/vnd.ms-outlook\":[\"msg\"],\"application/vnd.ms-pki.seccat\":[\"cat\"],\"application/vnd.ms-pki.stl\":[\"stl\"],\"application/vnd.ms-powerpoint\":[\"ppt\",\"pps\",\"pot\"],\"application/vnd.ms-powerpoint.addin.macroenabled.12\":[\"ppam\"],\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":[\"pptm\"],\"application/vnd.ms-powerpoint.slide.macroenabled.12\":[\"sldm\"],\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":[\"ppsm\"],\"application/vnd.ms-powerpoint.template.macroenabled.12\":[\"potm\"],\"application/vnd.ms-project\":[\"mpp\",\"mpt\"],\"application/vnd.ms-word.document.macroenabled.12\":[\"docm\"],\"application/vnd.ms-word.template.macroenabled.12\":[\"dotm\"],\"application/vnd.ms-works\":[\"wps\",\"wks\",\"wcm\",\"wdb\"],\"application/vnd.ms-wpl\":[\"wpl\"],\"application/vnd.ms-xpsdocument\":[\"xps\"],\"application/vnd.mseq\":[\"mseq\"],\"application/vnd.musician\":[\"mus\"],\"application/vnd.muvee.style\":[\"msty\"],\"application/vnd.mynfc\":[\"taglet\"],\"application/vnd.neurolanguage.nlu\":[\"nlu\"],\"application/vnd.nitf\":[\"ntf\",\"nitf\"],\"application/vnd.noblenet-directory\":[\"nnd\"],\"application/vnd.noblenet-sealer\":[\"nns\"],\"application/vnd.noblenet-web\":[\"nnw\"],\"application/vnd.nokia.n-gage.data\":[\"ngdat\"],\"application/vnd.nokia.n-gage.symbian.install\":[\"n-gage\"],\"application/vnd.nokia.radio-preset\":[\"rpst\"],\"application/vnd.nokia.radio-presets\":[\"rpss\"],\"application/vnd.novadigm.edm\":[\"edm\"],\"application/vnd.novadigm.edx\":[\"edx\"],\"application/vnd.novadigm.ext\":[\"ext\"],\"application/vnd.oasis.opendocument.chart\":[\"odc\"],\"application/vnd.oasis.opendocument.chart-template\":[\"otc\"],\"application/vnd.oasis.opendocument.database\":[\"odb\"],\"application/vnd.oasis.opendocument.formula\":[\"odf\"],\"application/vnd.oasis.opendocument.formula-template\":[\"odft\"],\"application/vnd.oasis.opendocument.graphics\":[\"odg\"],\"application/vnd.oasis.opendocument.graphics-template\":[\"otg\"],\"application/vnd.oasis.opendocument.image\":[\"odi\"],\"application/vnd.oasis.opendocument.image-template\":[\"oti\"],\"application/vnd.oasis.opendocument.presentation\":[\"odp\"],\"application/vnd.oasis.opendocument.presentation-template\":[\"otp\"],\"application/vnd.oasis.opendocument.spreadsheet\":[\"ods\"],\"application/vnd.oasis.opendocument.spreadsheet-template\":[\"ots\"],\"application/vnd.oasis.opendocument.text\":[\"odt\"],\"application/vnd.oasis.opendocument.text-master\":[\"odm\"],\"application/vnd.oasis.opendocument.text-template\":[\"ott\"],\"application/vnd.oasis.opendocument.text-web\":[\"oth\"],\"application/vnd.olpc-sugar\":[\"xo\"],\"application/vnd.oma.dd2+xml\":[\"dd2\"],\"application/vnd.openofficeorg.extension\":[\"oxt\"],\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":[\"pptx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slide\":[\"sldx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":[\"ppsx\"],\"application/vnd.openxmlformats-officedocument.presentationml.template\":[\"potx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":[\"xlsx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":[\"xltx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":[\"docx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":[\"dotx\"],\"application/vnd.osgeo.mapguide.package\":[\"mgp\"],\"application/vnd.osgi.dp\":[\"dp\"],\"application/vnd.osgi.subsystem\":[\"esa\"],\"application/vnd.palm\":[\"pdb\",\"pqa\",\"oprc\"],\"application/vnd.pawaafile\":[\"paw\"],\"application/vnd.pg.format\":[\"str\"],\"application/vnd.pg.osasli\":[\"ei6\"],\"application/vnd.picsel\":[\"efif\"],\"application/vnd.pmi.widget\":[\"wg\"],\"application/vnd.pocketlearn\":[\"plf\"],\"application/vnd.powerbuilder6\":[\"pbd\"],\"application/vnd.previewsystems.box\":[\"box\"],\"application/vnd.proteus.magazine\":[\"mgz\"],\"application/vnd.publishare-delta-tree\":[\"qps\"],\"application/vnd.pvi.ptid1\":[\"ptid\"],\"application/vnd.quark.quarkxpress\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"],\"application/vnd.realvnc.bed\":[\"bed\"],\"application/vnd.recordare.musicxml\":[\"mxl\"],\"application/vnd.recordare.musicxml+xml\":[\"musicxml\"],\"application/vnd.rig.cryptonote\":[\"cryptonote\"],\"application/vnd.rim.cod\":[\"cod\"],\"application/vnd.rn-realmedia\":[\"rm\"],\"application/vnd.rn-realmedia-vbr\":[\"rmvb\"],\"application/vnd.route66.link66+xml\":[\"link66\"],\"application/vnd.sailingtracker.track\":[\"st\"],\"application/vnd.seemail\":[\"see\"],\"application/vnd.sema\":[\"sema\"],\"application/vnd.semd\":[\"semd\"],\"application/vnd.semf\":[\"semf\"],\"application/vnd.shana.informed.formdata\":[\"ifm\"],\"application/vnd.shana.informed.formtemplate\":[\"itp\"],\"application/vnd.shana.informed.interchange\":[\"iif\"],\"application/vnd.shana.informed.package\":[\"ipk\"],\"application/vnd.simtech-mindmapper\":[\"twd\",\"twds\"],\"application/vnd.smaf\":[\"mmf\"],\"application/vnd.smart.teacher\":[\"teacher\"],\"application/vnd.solent.sdkm+xml\":[\"sdkm\",\"sdkd\"],\"application/vnd.spotfire.dxp\":[\"dxp\"],\"application/vnd.spotfire.sfs\":[\"sfs\"],\"application/vnd.stardivision.calc\":[\"sdc\"],\"application/vnd.stardivision.draw\":[\"sda\"],\"application/vnd.stardivision.impress\":[\"sdd\"],\"application/vnd.stardivision.math\":[\"smf\"],\"application/vnd.stardivision.writer\":[\"sdw\",\"vor\"],\"application/vnd.stardivision.writer-global\":[\"sgl\"],\"application/vnd.stepmania.package\":[\"smzip\"],\"application/vnd.stepmania.stepchart\":[\"sm\"],\"application/vnd.sun.wadl+xml\":[\"wadl\"],\"application/vnd.sun.xml.calc\":[\"sxc\"],\"application/vnd.sun.xml.calc.template\":[\"stc\"],\"application/vnd.sun.xml.draw\":[\"sxd\"],\"application/vnd.sun.xml.draw.template\":[\"std\"],\"application/vnd.sun.xml.impress\":[\"sxi\"],\"application/vnd.sun.xml.impress.template\":[\"sti\"],\"application/vnd.sun.xml.math\":[\"sxm\"],\"application/vnd.sun.xml.writer\":[\"sxw\"],\"application/vnd.sun.xml.writer.global\":[\"sxg\"],\"application/vnd.sun.xml.writer.template\":[\"stw\"],\"application/vnd.sus-calendar\":[\"sus\",\"susp\"],\"application/vnd.svd\":[\"svd\"],\"application/vnd.symbian.install\":[\"sis\",\"sisx\"],\"application/vnd.syncml+xml\":[\"xsm\"],\"application/vnd.syncml.dm+wbxml\":[\"bdm\"],\"application/vnd.syncml.dm+xml\":[\"xdm\"],\"application/vnd.tao.intent-module-archive\":[\"tao\"],\"application/vnd.tcpdump.pcap\":[\"pcap\",\"cap\",\"dmp\"],\"application/vnd.tmobile-livetv\":[\"tmo\"],\"application/vnd.trid.tpt\":[\"tpt\"],\"application/vnd.triscape.mxs\":[\"mxs\"],\"application/vnd.trueapp\":[\"tra\"],\"application/vnd.ufdl\":[\"ufd\",\"ufdl\"],\"application/vnd.uiq.theme\":[\"utz\"],\"application/vnd.umajin\":[\"umj\"],\"application/vnd.unity\":[\"unityweb\"],\"application/vnd.uoml+xml\":[\"uoml\"],\"application/vnd.vcx\":[\"vcx\"],\"application/vnd.visio\":[\"vsd\",\"vst\",\"vss\",\"vsw\"],\"application/vnd.visionary\":[\"vis\"],\"application/vnd.vsf\":[\"vsf\"],\"application/vnd.wap.wbxml\":[\"wbxml\"],\"application/vnd.wap.wmlc\":[\"wmlc\"],\"application/vnd.wap.wmlscriptc\":[\"wmlsc\"],\"application/vnd.webturbo\":[\"wtb\"],\"application/vnd.wolfram.player\":[\"nbp\"],\"application/vnd.wordperfect\":[\"wpd\"],\"application/vnd.wqd\":[\"wqd\"],\"application/vnd.wt.stf\":[\"stf\"],\"application/vnd.xara\":[\"xar\"],\"application/vnd.xfdl\":[\"xfdl\"],\"application/vnd.yamaha.hv-dic\":[\"hvd\"],\"application/vnd.yamaha.hv-script\":[\"hvs\"],\"application/vnd.yamaha.hv-voice\":[\"hvp\"],\"application/vnd.yamaha.openscoreformat\":[\"osf\"],\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":[\"osfpvg\"],\"application/vnd.yamaha.smaf-audio\":[\"saf\"],\"application/vnd.yamaha.smaf-phrase\":[\"spf\"],\"application/vnd.yellowriver-custom-menu\":[\"cmp\"],\"application/vnd.zul\":[\"zir\",\"zirz\"],\"application/vnd.zzazz.deck+xml\":[\"zaz\"],\"application/voicexml+xml\":[\"vxml\"],\"application/wasm\":[\"wasm\"],\"application/widget\":[\"wgt\"],\"application/winhlp\":[\"hlp\"],\"application/wsdl+xml\":[\"wsdl\"],\"application/wspolicy+xml\":[\"wspolicy\"],\"application/x-7z-compressed\":[\"7z\"],\"application/x-abiword\":[\"abw\"],\"application/x-ace-compressed\":[\"ace\"],\"application/x-apple-diskimage\":[],\"application/x-arj\":[\"arj\"],\"application/x-authorware-bin\":[\"aab\",\"x32\",\"u32\",\"vox\"],\"application/x-authorware-map\":[\"aam\"],\"application/x-authorware-seg\":[\"aas\"],\"application/x-bcpio\":[\"bcpio\"],\"application/x-bdoc\":[],\"application/x-bittorrent\":[\"torrent\"],\"application/x-blorb\":[\"blb\",\"blorb\"],\"application/x-bzip\":[\"bz\"],\"application/x-bzip2\":[\"bz2\",\"boz\"],\"application/x-cbr\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"],\"application/x-cdlink\":[\"vcd\"],\"application/x-cfs-compressed\":[\"cfs\"],\"application/x-chat\":[\"chat\"],\"application/x-chess-pgn\":[\"pgn\"],\"application/x-chrome-extension\":[\"crx\"],\"application/x-cocoa\":[\"cco\"],\"application/x-conference\":[\"nsc\"],\"application/x-cpio\":[\"cpio\"],\"application/x-csh\":[\"csh\"],\"application/x-debian-package\":[\"udeb\"],\"application/x-dgc-compressed\":[\"dgc\"],\"application/x-director\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"],\"application/x-doom\":[\"wad\"],\"application/x-dtbncx+xml\":[\"ncx\"],\"application/x-dtbook+xml\":[\"dtb\"],\"application/x-dtbresource+xml\":[\"res\"],\"application/x-dvi\":[\"dvi\"],\"application/x-envoy\":[\"evy\"],\"application/x-eva\":[\"eva\"],\"application/x-font-bdf\":[\"bdf\"],\"application/x-font-ghostscript\":[\"gsf\"],\"application/x-font-linux-psf\":[\"psf\"],\"application/x-font-pcf\":[\"pcf\"],\"application/x-font-snf\":[\"snf\"],\"application/x-font-type1\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"],\"application/x-freearc\":[\"arc\"],\"application/x-futuresplash\":[\"spl\"],\"application/x-gca-compressed\":[\"gca\"],\"application/x-glulx\":[\"ulx\"],\"application/x-gnumeric\":[\"gnumeric\"],\"application/x-gramps-xml\":[\"gramps\"],\"application/x-gtar\":[\"gtar\"],\"application/x-hdf\":[\"hdf\"],\"application/x-httpd-php\":[\"php\"],\"application/x-install-instructions\":[\"install\"],\"application/x-iso9660-image\":[],\"application/x-java-archive-diff\":[\"jardiff\"],\"application/x-java-jnlp-file\":[\"jnlp\"],\"application/x-latex\":[\"latex\"],\"application/x-lua-bytecode\":[\"luac\"],\"application/x-lzh-compressed\":[\"lzh\",\"lha\"],\"application/x-makeself\":[\"run\"],\"application/x-mie\":[\"mie\"],\"application/x-mobipocket-ebook\":[\"prc\",\"mobi\"],\"application/x-ms-application\":[\"application\"],\"application/x-ms-shortcut\":[\"lnk\"],\"application/x-ms-wmd\":[\"wmd\"],\"application/x-ms-wmz\":[\"wmz\"],\"application/x-ms-xbap\":[\"xbap\"],\"application/x-msaccess\":[\"mdb\"],\"application/x-msbinder\":[\"obd\"],\"application/x-mscardfile\":[\"crd\"],\"application/x-msclip\":[\"clp\"],\"application/x-msdos-program\":[],\"application/x-msdownload\":[\"com\",\"bat\"],\"application/x-msmediaview\":[\"mvb\",\"m13\",\"m14\"],\"application/x-msmetafile\":[\"wmf\",\"emf\",\"emz\"],\"application/x-msmoney\":[\"mny\"],\"application/x-mspublisher\":[\"pub\"],\"application/x-msschedule\":[\"scd\"],\"application/x-msterminal\":[\"trm\"],\"application/x-mswrite\":[\"wri\"],\"application/x-netcdf\":[\"nc\",\"cdf\"],\"application/x-ns-proxy-autoconfig\":[\"pac\"],\"application/x-nzb\":[\"nzb\"],\"application/x-perl\":[\"pl\",\"pm\"],\"application/x-pilot\":[],\"application/x-pkcs12\":[\"p12\",\"pfx\"],\"application/x-pkcs7-certificates\":[\"p7b\",\"spc\"],\"application/x-pkcs7-certreqresp\":[\"p7r\"],\"application/x-rar-compressed\":[\"rar\"],\"application/x-redhat-package-manager\":[\"rpm\"],\"application/x-research-info-systems\":[\"ris\"],\"application/x-sea\":[\"sea\"],\"application/x-sh\":[\"sh\"],\"application/x-shar\":[\"shar\"],\"application/x-shockwave-flash\":[\"swf\"],\"application/x-silverlight-app\":[\"xap\"],\"application/x-sql\":[\"sql\"],\"application/x-stuffit\":[\"sit\"],\"application/x-stuffitx\":[\"sitx\"],\"application/x-subrip\":[\"srt\"],\"application/x-sv4cpio\":[\"sv4cpio\"],\"application/x-sv4crc\":[\"sv4crc\"],\"application/x-t3vm-image\":[\"t3\"],\"application/x-tads\":[\"gam\"],\"application/x-tar\":[\"tar\"],\"application/x-tcl\":[\"tcl\",\"tk\"],\"application/x-tex\":[\"tex\"],\"application/x-tex-tfm\":[\"tfm\"],\"application/x-texinfo\":[\"texinfo\",\"texi\"],\"application/x-tgif\":[\"obj\"],\"application/x-ustar\":[\"ustar\"],\"application/x-virtualbox-hdd\":[\"hdd\"],\"application/x-virtualbox-ova\":[\"ova\"],\"application/x-virtualbox-ovf\":[\"ovf\"],\"application/x-virtualbox-vbox\":[\"vbox\"],\"application/x-virtualbox-vbox-extpack\":[\"vbox-extpack\"],\"application/x-virtualbox-vdi\":[\"vdi\"],\"application/x-virtualbox-vhd\":[\"vhd\"],\"application/x-virtualbox-vmdk\":[\"vmdk\"],\"application/x-wais-source\":[\"src\"],\"application/x-web-app-manifest+json\":[\"webapp\"],\"application/x-x509-ca-cert\":[\"der\",\"crt\",\"pem\"],\"application/x-xfig\":[\"fig\"],\"application/x-xliff+xml\":[\"xlf\"],\"application/x-xpinstall\":[\"xpi\"],\"application/x-xz\":[\"xz\"],\"application/x-zmachine\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"],\"application/xaml+xml\":[\"xaml\"],\"application/xcap-diff+xml\":[\"xdf\"],\"application/xenc+xml\":[\"xenc\"],\"application/xhtml+xml\":[\"xhtml\",\"xht\"],\"application/xml\":[\"xml\",\"xsl\",\"xsd\",\"rng\"],\"application/xml-dtd\":[\"dtd\"],\"application/xop+xml\":[\"xop\"],\"application/xproc+xml\":[\"xpl\"],\"application/xslt+xml\":[\"xslt\"],\"application/xspf+xml\":[\"xspf\"],\"application/xv+xml\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"],\"application/yang\":[\"yang\"],\"application/yin+xml\":[\"yin\"],\"application/zip\":[\"zip\"],\"audio/3gpp\":[],\"audio/adpcm\":[\"adp\"],\"audio/basic\":[\"au\",\"snd\"],\"audio/midi\":[\"mid\",\"midi\",\"kar\",\"rmi\"],\"audio/mp3\":[],\"audio/mp4\":[\"m4a\",\"mp4a\"],\"audio/mpeg\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"],\"audio/ogg\":[\"oga\",\"ogg\",\"spx\"],\"audio/s3m\":[\"s3m\"],\"audio/silk\":[\"sil\"],\"audio/vnd.dece.audio\":[\"uva\",\"uvva\"],\"audio/vnd.digital-winds\":[\"eol\"],\"audio/vnd.dra\":[\"dra\"],\"audio/vnd.dts\":[\"dts\"],\"audio/vnd.dts.hd\":[\"dtshd\"],\"audio/vnd.lucent.voice\":[\"lvp\"],\"audio/vnd.ms-playready.media.pya\":[\"pya\"],\"audio/vnd.nuera.ecelp4800\":[\"ecelp4800\"],\"audio/vnd.nuera.ecelp7470\":[\"ecelp7470\"],\"audio/vnd.nuera.ecelp9600\":[\"ecelp9600\"],\"audio/vnd.rip\":[\"rip\"],\"audio/wav\":[\"wav\"],\"audio/wave\":[],\"audio/webm\":[\"weba\"],\"audio/x-aac\":[\"aac\"],\"audio/x-aiff\":[\"aif\",\"aiff\",\"aifc\"],\"audio/x-caf\":[\"caf\"],\"audio/x-flac\":[\"flac\"],\"audio/x-m4a\":[],\"audio/x-matroska\":[\"mka\"],\"audio/x-mpegurl\":[\"m3u\"],\"audio/x-ms-wax\":[\"wax\"],\"audio/x-ms-wma\":[\"wma\"],\"audio/x-pn-realaudio\":[\"ram\",\"ra\"],\"audio/x-pn-realaudio-plugin\":[\"rmp\"],\"audio/x-realaudio\":[],\"audio/x-wav\":[],\"audio/xm\":[\"xm\"],\"chemical/x-cdx\":[\"cdx\"],\"chemical/x-cif\":[\"cif\"],\"chemical/x-cmdf\":[\"cmdf\"],\"chemical/x-cml\":[\"cml\"],\"chemical/x-csml\":[\"csml\"],\"chemical/x-xyz\":[\"xyz\"],\"font/collection\":[\"ttc\"],\"font/otf\":[\"otf\"],\"font/ttf\":[\"ttf\"],\"font/woff\":[\"woff\"],\"font/woff2\":[\"woff2\"],\"image/apng\":[\"apng\"],\"image/bmp\":[\"bmp\"],\"image/cgm\":[\"cgm\"],\"image/g3fax\":[\"g3\"],\"image/gif\":[\"gif\"],\"image/ief\":[\"ief\"],\"image/jp2\":[\"jp2\",\"jpg2\"],\"image/jpeg\":[\"jpeg\",\"jpg\",\"jpe\"],\"image/jpm\":[\"jpm\"],\"image/jpx\":[\"jpx\",\"jpf\"],\"image/ktx\":[\"ktx\"],\"image/png\":[\"png\"],\"image/prs.btif\":[\"btif\"],\"image/sgi\":[\"sgi\"],\"image/svg+xml\":[\"svg\",\"svgz\"],\"image/tiff\":[\"tiff\",\"tif\"],\"image/vnd.adobe.photoshop\":[\"psd\"],\"image/vnd.dece.graphic\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"],\"image/vnd.djvu\":[\"djvu\",\"djv\"],\"image/vnd.dvb.subtitle\":[],\"image/vnd.dwg\":[\"dwg\"],\"image/vnd.dxf\":[\"dxf\"],\"image/vnd.fastbidsheet\":[\"fbs\"],\"image/vnd.fpx\":[\"fpx\"],\"image/vnd.fst\":[\"fst\"],\"image/vnd.fujixerox.edmics-mmr\":[\"mmr\"],\"image/vnd.fujixerox.edmics-rlc\":[\"rlc\"],\"image/vnd.ms-modi\":[\"mdi\"],\"image/vnd.ms-photo\":[\"wdp\"],\"image/vnd.net-fpx\":[\"npx\"],\"image/vnd.wap.wbmp\":[\"wbmp\"],\"image/vnd.xiff\":[\"xif\"],\"image/webp\":[\"webp\"],\"image/x-3ds\":[\"3ds\"],\"image/x-cmu-raster\":[\"ras\"],\"image/x-cmx\":[\"cmx\"],\"image/x-freehand\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"],\"image/x-icon\":[\"ico\"],\"image/x-jng\":[\"jng\"],\"image/x-mrsid-image\":[\"sid\"],\"image/x-ms-bmp\":[],\"image/x-pcx\":[\"pcx\"],\"image/x-pict\":[\"pic\",\"pct\"],\"image/x-portable-anymap\":[\"pnm\"],\"image/x-portable-bitmap\":[\"pbm\"],\"image/x-portable-graymap\":[\"pgm\"],\"image/x-portable-pixmap\":[\"ppm\"],\"image/x-rgb\":[\"rgb\"],\"image/x-tga\":[\"tga\"],\"image/x-xbitmap\":[\"xbm\"],\"image/x-xpixmap\":[\"xpm\"],\"image/x-xwindowdump\":[\"xwd\"],\"message/rfc822\":[\"eml\",\"mime\"],\"model/gltf+json\":[\"gltf\"],\"model/gltf-binary\":[\"glb\"],\"model/iges\":[\"igs\",\"iges\"],\"model/mesh\":[\"msh\",\"mesh\",\"silo\"],\"model/vnd.collada+xml\":[\"dae\"],\"model/vnd.dwf\":[\"dwf\"],\"model/vnd.gdl\":[\"gdl\"],\"model/vnd.gtw\":[\"gtw\"],\"model/vnd.mts\":[\"mts\"],\"model/vnd.vtu\":[\"vtu\"],\"model/vrml\":[\"wrl\",\"vrml\"],\"model/x3d+binary\":[\"x3db\",\"x3dbz\"],\"model/x3d+vrml\":[\"x3dv\",\"x3dvz\"],\"model/x3d+xml\":[\"x3d\",\"x3dz\"],\"text/cache-manifest\":[\"appcache\",\"manifest\"],\"text/calendar\":[\"ics\",\"ifb\"],\"text/coffeescript\":[\"coffee\",\"litcoffee\"],\"text/css\":[\"css\"],\"text/csv\":[\"csv\"],\"text/hjson\":[\"hjson\"],\"text/html\":[\"html\",\"htm\",\"shtml\"],\"text/jade\":[\"jade\"],\"text/jsx\":[\"jsx\"],\"text/less\":[\"less\"],\"text/markdown\":[\"markdown\",\"md\"],\"text/mathml\":[\"mml\"],\"text/n3\":[\"n3\"],\"text/plain\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"],\"text/prs.lines.tag\":[\"dsc\"],\"text/richtext\":[\"rtx\"],\"text/rtf\":[],\"text/sgml\":[\"sgml\",\"sgm\"],\"text/slim\":[\"slim\",\"slm\"],\"text/stylus\":[\"stylus\",\"styl\"],\"text/tab-separated-values\":[\"tsv\"],\"text/troff\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"],\"text/turtle\":[\"ttl\"],\"text/uri-list\":[\"uri\",\"uris\",\"urls\"],\"text/vcard\":[\"vcard\"],\"text/vnd.curl\":[\"curl\"],\"text/vnd.curl.dcurl\":[\"dcurl\"],\"text/vnd.curl.mcurl\":[\"mcurl\"],\"text/vnd.curl.scurl\":[\"scurl\"],\"text/vnd.dvb.subtitle\":[\"sub\"],\"text/vnd.fly\":[\"fly\"],\"text/vnd.fmi.flexstor\":[\"flx\"],\"text/vnd.graphviz\":[\"gv\"],\"text/vnd.in3d.3dml\":[\"3dml\"],\"text/vnd.in3d.spot\":[\"spot\"],\"text/vnd.sun.j2me.app-descriptor\":[\"jad\"],\"text/vnd.wap.wml\":[\"wml\"],\"text/vnd.wap.wmlscript\":[\"wmls\"],\"text/vtt\":[\"vtt\"],\"text/x-asm\":[\"s\",\"asm\"],\"text/x-c\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"],\"text/x-component\":[\"htc\"],\"text/x-fortran\":[\"f\",\"for\",\"f77\",\"f90\"],\"text/x-handlebars-template\":[\"hbs\"],\"text/x-java-source\":[\"java\"],\"text/x-lua\":[\"lua\"],\"text/x-markdown\":[\"mkd\"],\"text/x-nfo\":[\"nfo\"],\"text/x-opml\":[\"opml\"],\"text/x-org\":[],\"text/x-pascal\":[\"p\",\"pas\"],\"text/x-processing\":[\"pde\"],\"text/x-sass\":[\"sass\"],\"text/x-scss\":[\"scss\"],\"text/x-setext\":[\"etx\"],\"text/x-sfv\":[\"sfv\"],\"text/x-suse-ymp\":[\"ymp\"],\"text/x-uuencode\":[\"uu\"],\"text/x-vcalendar\":[\"vcs\"],\"text/x-vcard\":[\"vcf\"],\"text/xml\":[],\"text/yaml\":[\"yaml\",\"yml\"],\"video/3gpp\":[\"3gp\",\"3gpp\"],\"video/3gpp2\":[\"3g2\"],\"video/h261\":[\"h261\"],\"video/h263\":[\"h263\"],\"video/h264\":[\"h264\"],\"video/jpeg\":[\"jpgv\"],\"video/jpm\":[\"jpgm\"],\"video/mj2\":[\"mj2\",\"mjp2\"],\"video/mp2t\":[\"ts\"],\"video/mp4\":[\"mp4\",\"mp4v\",\"mpg4\"],\"video/mpeg\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"],\"video/ogg\":[\"ogv\"],\"video/quicktime\":[\"qt\",\"mov\"],\"video/vnd.dece.hd\":[\"uvh\",\"uvvh\"],\"video/vnd.dece.mobile\":[\"uvm\",\"uvvm\"],\"video/vnd.dece.pd\":[\"uvp\",\"uvvp\"],\"video/vnd.dece.sd\":[\"uvs\",\"uvvs\"],\"video/vnd.dece.video\":[\"uvv\",\"uvvv\"],\"video/vnd.dvb.file\":[\"dvb\"],\"video/vnd.fvt\":[\"fvt\"],\"video/vnd.mpegurl\":[\"mxu\",\"m4u\"],\"video/vnd.ms-playready.media.pyv\":[\"pyv\"],\"video/vnd.uvvu.mp4\":[\"uvu\",\"uvvu\"],\"video/vnd.vivo\":[\"viv\"],\"video/webm\":[\"webm\"],\"video/x-f4v\":[\"f4v\"],\"video/x-fli\":[\"fli\"],\"video/x-flv\":[\"flv\"],\"video/x-m4v\":[\"m4v\"],\"video/x-matroska\":[\"mkv\",\"mk3d\",\"mks\"],\"video/x-mng\":[\"mng\"],\"video/x-ms-asf\":[\"asf\",\"asx\"],\"video/x-ms-vob\":[\"vob\"],\"video/x-ms-wm\":[\"wm\"],\"video/x-ms-wmv\":[\"wmv\"],\"video/x-ms-wmx\":[\"wmx\"],\"video/x-ms-wvx\":[\"wvx\"],\"video/x-msvideo\":[\"avi\"],\"video/x-sgi-movie\":[\"movie\"],\"video/x-smv\":[\"smv\"],\"x-conference/x-cooltalk\":[\"ice\"]}');\n\n//# sourceURL=webpack://qui/../../../node_modules/mime/types.json?");

/***/ }),

/***/ "../../../node_modules/pino/package.json":
/*!***********************************************!*\
  !*** ../../../node_modules/pino/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"pino\",\"version\":\"6.13.4\",\"description\":\"super fast, all natural json logger\",\"main\":\"pino.js\",\"browser\":\"./browser.js\",\"files\":[\"pino.js\",\"bin.js\",\"browser.js\",\"pretty.js\",\"usage.txt\",\"test\",\"docs\",\"example.js\",\"lib\"],\"scripts\":{\"docs\":\"docsify serve\",\"browser-test\":\"airtap --local 8080 test/browser*test.js\",\"lint\":\"eslint .\",\"test\":\"npm run lint && tap --100 test/*test.js test/*/*test.js\",\"test-ci\":\"npm run lint && tap test/*test.js test/*/*test.js --coverage-report=lcovonly\",\"cov-ui\":\"tap --coverage-report=html test/*test.js test/*/*test.js\",\"bench\":\"node benchmarks/utils/runbench all\",\"bench-basic\":\"node benchmarks/utils/runbench basic\",\"bench-object\":\"node benchmarks/utils/runbench object\",\"bench-deep-object\":\"node benchmarks/utils/runbench deep-object\",\"bench-multi-arg\":\"node benchmarks/utils/runbench multi-arg\",\"bench-longs-tring\":\"node benchmarks/utils/runbench long-string\",\"bench-child\":\"node benchmarks/utils/runbench child\",\"bench-child-child\":\"node benchmarks/utils/runbench child-child\",\"bench-child-creation\":\"node benchmarks/utils/runbench child-creation\",\"bench-formatters\":\"node benchmarks/utils/runbench formatters\",\"update-bench-doc\":\"node benchmarks/utils/generate-benchmark-doc > docs/benchmarks.md\"},\"bin\":{\"pino\":\"./bin.js\"},\"precommit\":\"test\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pinojs/pino.git\"},\"keywords\":[\"fast\",\"logger\",\"stream\",\"json\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"contributors\":[\"David Mark Clements <huperekchuno@googlemail.com>\",\"James Sumners <james.sumners@gmail.com>\",\"Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)\"],\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/pinojs/pino/issues\"},\"homepage\":\"http://getpino.io\",\"devDependencies\":{\"airtap\":\"4.0.3\",\"benchmark\":\"^2.1.4\",\"bole\":\"^4.0.0\",\"bunyan\":\"^1.8.14\",\"docsify-cli\":\"^4.4.1\",\"eslint\":\"^7.17.0\",\"eslint-config-standard\":\"^16.0.2\",\"eslint-plugin-import\":\"^2.22.1\",\"eslint-plugin-node\":\"^11.1.0\",\"eslint-plugin-promise\":\"^5.1.0\",\"execa\":\"^5.0.0\",\"fastbench\":\"^1.0.1\",\"flush-write-stream\":\"^2.0.0\",\"import-fresh\":\"^3.2.1\",\"log\":\"^6.0.0\",\"loglevel\":\"^1.6.7\",\"pino-pretty\":\"^5.0.0\",\"pre-commit\":\"^1.2.2\",\"proxyquire\":\"^2.1.3\",\"pump\":\"^3.0.0\",\"semver\":\"^7.0.0\",\"split2\":\"^3.1.1\",\"steed\":\"^1.1.3\",\"strip-ansi\":\"^6.0.0\",\"tap\":\"^15.0.1\",\"tape\":\"^5.0.0\",\"through2\":\"^4.0.0\",\"winston\":\"^3.3.3\"},\"dependencies\":{\"fast-redact\":\"^3.0.0\",\"fast-safe-stringify\":\"^2.0.8\",\"process-warning\":\"^1.0.0\",\"flatstr\":\"^1.0.12\",\"pino-std-serializers\":\"^3.1.0\",\"quick-format-unescaped\":\"^4.0.3\",\"sonic-boom\":\"^1.0.2\"}}');\n\n//# sourceURL=webpack://qui/../../../node_modules/pino/package.json?");

/***/ }),

/***/ "../../../node_modules/statuses/codes.json":
/*!*************************************************!*\
  !*** ../../../node_modules/statuses/codes.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"100\":\"Continue\",\"101\":\"Switching Protocols\",\"102\":\"Processing\",\"103\":\"Early Hints\",\"200\":\"OK\",\"201\":\"Created\",\"202\":\"Accepted\",\"203\":\"Non-Authoritative Information\",\"204\":\"No Content\",\"205\":\"Reset Content\",\"206\":\"Partial Content\",\"207\":\"Multi-Status\",\"208\":\"Already Reported\",\"226\":\"IM Used\",\"300\":\"Multiple Choices\",\"301\":\"Moved Permanently\",\"302\":\"Found\",\"303\":\"See Other\",\"304\":\"Not Modified\",\"305\":\"Use Proxy\",\"306\":\"(Unused)\",\"307\":\"Temporary Redirect\",\"308\":\"Permanent Redirect\",\"400\":\"Bad Request\",\"401\":\"Unauthorized\",\"402\":\"Payment Required\",\"403\":\"Forbidden\",\"404\":\"Not Found\",\"405\":\"Method Not Allowed\",\"406\":\"Not Acceptable\",\"407\":\"Proxy Authentication Required\",\"408\":\"Request Timeout\",\"409\":\"Conflict\",\"410\":\"Gone\",\"411\":\"Length Required\",\"412\":\"Precondition Failed\",\"413\":\"Payload Too Large\",\"414\":\"URI Too Long\",\"415\":\"Unsupported Media Type\",\"416\":\"Range Not Satisfiable\",\"417\":\"Expectation Failed\",\"418\":\"I\\'m a teapot\",\"421\":\"Misdirected Request\",\"422\":\"Unprocessable Entity\",\"423\":\"Locked\",\"424\":\"Failed Dependency\",\"425\":\"Unordered Collection\",\"426\":\"Upgrade Required\",\"428\":\"Precondition Required\",\"429\":\"Too Many Requests\",\"431\":\"Request Header Fields Too Large\",\"451\":\"Unavailable For Legal Reasons\",\"500\":\"Internal Server Error\",\"501\":\"Not Implemented\",\"502\":\"Bad Gateway\",\"503\":\"Service Unavailable\",\"504\":\"Gateway Timeout\",\"505\":\"HTTP Version Not Supported\",\"506\":\"Variant Also Negotiates\",\"507\":\"Insufficient Storage\",\"508\":\"Loop Detected\",\"509\":\"Bandwidth Limit Exceeded\",\"510\":\"Not Extended\",\"511\":\"Network Authentication Required\"}');\n\n//# sourceURL=webpack://qui/../../../node_modules/statuses/codes.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./server.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});